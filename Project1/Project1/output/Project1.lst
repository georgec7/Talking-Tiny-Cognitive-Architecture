0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0001) ; Generated by PSoC Designer ???
                                   (0002) ;
                                   (0003) ;@Id: boot.tpl#895 @
                                   (0004) ;=============================================================================
                                   (0005) ;  FILENAME:   boot.asm
                                   (0006) ;  VERSION:    4.18
                                   (0007) ;  DATE:       28 June 2007
                                   (0008) ;
                                   (0009) ;  DESCRIPTION:
                                   (0010) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0011) ;
                                   (0012) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
                                   (0013) ;
                                   (0014) ; NOTES:
                                   (0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                   (0016) ; the project's root directory to create BOOT.ASM. Any changes made to
                                   (0017) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                   (0020) ; are not accidentally modified.
                                   (0021) ;
                                   (0022) ;=============================================================================
                                   (0023) 
                                   (0024) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                   (0025) include "m8c.inc"			;Part specific file
                                   (0026) include "m8ssc.inc"			;Part specific file
                                   (0027) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                   (0028) 
                                   (0029) ;--------------------------------------
                                   (0030) ; Export Declarations
                                   (0031) ;--------------------------------------
                                   (0032) 
                                   (0033) export __Start
                                   (0034) IF	(TOOLCHAIN & HITECH)
                                   (0035) ELSE
                                   (0036) export __bss_start
                                   (0037) export __data_start
                                   (0038) export __idata_start
                                   (0039) export __func_lit_start
                                   (0040) export __text_start
                                   (0041) ENDIF
                                   (0042) export  _bGetPowerSetting
                                   (0043) export   bGetPowerSetting
                                   (0044) 
                                   (0045) 
                                   (0046) ;--------------------------------------
                                   (0047) ; Optimization flags
                                   (0048) ;--------------------------------------
                                   (0049) ;
                                   (0050) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0051) ; boot.asm. See the notes in the banner comment at the beginning of
                                   (0052) ; this file.
                                   (0053) 
                                   (0054) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0055) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                   (0056) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0057) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0058) ;
                                   (0059) IF	(TOOLCHAIN & HITECH)
                                   (0060) ; The C compiler will customize the startup code - it's not required here
                                   (0061) 
                                   (0062) C_LANGUAGE_SUPPORT:              equ 0
                                   (0063) ELSE
                                   (0064) C_LANGUAGE_SUPPORT:              equ 1
                                   (0065) ENDIF
                                   (0066) 
                                   (0067) 
                                   (0068) ; The following equate is required for proper operation. Reseting its value
                                   (0069) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0070) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0071) ; and PLL_Lock must take place within user code. See the family data sheet for
                                   (0072) ; the requirements of starting the ECO and PLL lock mode.
                                   (0073) ;
                                   (0074) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0075) ;                invoking main
                                   (0076) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                   (0077) ;               the time code in main starts executing.
                                   (0078) ;
                                   (0079) WAIT_FOR_32K:                    equ 1
                                   (0080) 
                                   (0081) 
                                   (0082) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0083) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0084) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0085) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0086) ; bytes on the stack which are otherwise required for the return address. If
                                   (0087) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0088) ; release, the C compiler automatically places an infinite loop at the end
                                   (0089) ; of main, rather than a return instruction.)
                                   (0090) ;
                                   (0091) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0092) 
                                   (0093) 
                                   (0094) ;-----------------------------------------------------------------------------
                                   (0095) ; Interrupt Vector Table
                                   (0096) ;-----------------------------------------------------------------------------
                                   (0097) ;
                                   (0098) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0099) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0100) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0101) ; vector jump targets are modified automatically according to the user
                                   (0102) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0103) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0104) ; configuration files. If you need to hard code a vector, update the
                                   (0105) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0106) ; of this file.
                                   (0107) ;-----------------------------------------------------------------------------
                                   (0108) 
                                   (0109)     AREA TOP (ROM, ABS, CON)
                                   (0110) 
                                   (0111)     org   0                        ;Reset Interrupt Vector
                                   (0112) IF	(TOOLCHAIN & HITECH)
                                   (0113) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0114) ELSE
                                   (0115)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0116) ENDIF
                                   (0117) 
                                   (0118)     org   04h                      ;Supply Monitor Interrupt Vector
0004: 30       HALT                (0119)     halt                           ;Stop execution if power falls too low
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0120) 
                                   (0121)     org   08h                      ;Analog Column 0 Interrupt Vector
                                   (0122)     // call	void_handler
0008: 7E       RETI                (0123)     reti
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0124) 
                                   (0125)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                   (0126)     // call	void_handler
000C: 7E       RETI                (0127)     reti
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0128) 
                                   (0129)     org   10h                      ;Analog Column 2 Interrupt Vector
                                   (0130)     // call	void_handler
0010: 7E       RETI                (0131)     reti
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0132) 
                                   (0133)     org   14h                      ;Analog Column 3 Interrupt Vector
                                   (0134)     // call	void_handler
0014: 7E       RETI                (0135)     reti
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0136) 
                                   (0137)     org   18h                      ;VC3 Interrupt Vector
                                   (0138)     // call	void_handler
0018: 7E       RETI                (0139)     reti
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0140) 
                                   (0141)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0142)     // call	void_handler
001C: 7E       RETI                (0143)     reti
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0144) 
                                   (0145)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0146)     // call	void_handler
0020: 7E       RETI                (0147)     reti
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0148) 
                                   (0149)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0150)     // call	void_handler
0024: 7E       RETI                (0151)     reti
0025: 30       HALT  
0026: 30       HALT  
0027: 30       HALT  
                                   (0152) 
                                   (0153)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0154)     // call	void_handler
0028: 7E       RETI                (0155)     reti
0029: 30       HALT  
002A: 30       HALT  
002B: 30       HALT  
                                   (0156) 
                                   (0157)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0158)     // call	void_handler
002C: 7E       RETI                (0159)     reti
002D: 30       HALT  
002E: 30       HALT  
002F: 30       HALT  
                                   (0160) 
                                   (0161)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                   (0162)     // call	void_handler
0030: 7E       RETI                (0163)     reti
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0164) 
                                   (0165)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0166)     // call	void_handler
0034: 7E       RETI                (0167)     reti
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0168) 
                                   (0169)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0170)     // call	void_handler
0038: 7E       RETI                (0171)     reti
0039: 30       HALT  
003A: 30       HALT  
003B: 30       HALT  
                                   (0172) 
                                   (0173)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                   (0174)     // call	void_handler
003C: 7E       RETI                (0175)     reti
003D: 30       HALT  
003E: 30       HALT  
003F: 30       HALT  
                                   (0176) 
                                   (0177)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
0040: 7D 03 F8 LJMP  0x03F8        (0178)     ljmp	_DUALADC_1_CNT1_ISR
0043: 7E       RETI                (0179)     reti
                                   (0180) 
                                   (0181)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                   (0182)     // call	void_handler
0044: 7E       RETI                (0183)     reti
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0184) 
                                   (0185)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
0048: 7D 03 FE LJMP  0x03FE        (0186)     ljmp	_DUALADC_1_PWM16_ISR
004B: 7E       RETI                (0187)     reti
                                   (0188) 
                                   (0189)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
004C: 7D 03 FB LJMP  0x03FB        (0190)     ljmp	_DUALADC_1_CNT2_ISR
004F: 7E       RETI                (0191)     reti
                                   (0192) 
                                   (0193)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                   (0194)     // call	void_handler
0050: 7E       RETI                (0195)     reti
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0196) 
                                   (0197)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                   (0198)     // call	void_handler
0054: 7E       RETI                (0199)     reti
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0200) 
                                   (0201)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                   (0202)     // call	void_handler
0058: 7E       RETI                (0203)     reti
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0204) 
                                   (0205)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                   (0206)     // call	void_handler
005C: 7E       RETI                (0207)     reti
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0208) 
                                   (0209)     org   60h                      ;PSoC I2C Interrupt Vector
                                   (0210)     // call	void_handler
0060: 7E       RETI                (0211)     reti
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0212) 
                                   (0213)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0214)     // call	void_handler
0064: 7E       RETI                (0215)     reti
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0216) 
                                   (0217) ;-----------------------------------------------------------------------------
                                   (0218) ;  Start of Execution.
                                   (0219) ;-----------------------------------------------------------------------------
                                   (0220) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0221) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0222) ;
                                   (0223) 
                                   (0224) IF	(TOOLCHAIN & HITECH)
                                   (0225)  	AREA PD_startup(CODE, REL, CON)
                                   (0226) ELSE
                                   (0227)     org 68h
                                   (0228) ENDIF
                                   (0229) __Start:
                                   (0230) 
                                   (0231)     ; initialize SMP values for voltage stabilization, if required,
                                   (0232)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0233)     ; least for now. 
                                   (0234)     ;
0068: 71 10    OR    F,16          (0235)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[250],0    (0236)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 87 MOV   REG[227],135  (0237)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,239         (0238)     M8C_SetBank0
                                   (0239) 
                                   (0240)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,32          (0241)     mov   A, 20h
0074: 28       ROMX                (0242)     romx
0075: 50 40    MOV   A,64          (0243)     mov   A, 40h
0077: 28       ROMX                (0244)     romx
0078: 50 60    MOV   A,96          (0245)     mov   A, 60h
007A: 28       ROMX                (0246)     romx
                                   (0247)     ; %45%20%46%46% End workaround
                                   (0248) 
                                   (0249) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0250)     M8C_EnableWatchDog
                                   (0251) ENDIF
                                   (0252) 
                                   (0253) IF ( SELECT_32K )
                                   (0254)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0255) ELSE
007B: 41 FE FB AND   REG[254],251  (0256)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0257) ENDIF
                                   (0258) 
                                   (0259)     ;---------------------------
                                   (0260)     ; Set up the Temporary stack
                                   (0261)     ;---------------------------
                                   (0262)     ; A temporary stack is set up for the SSC instructions.
                                   (0263)     ; The real stack start will be assigned later.
                                   (0264)     ;
                                   (0265) _stack_start:          equ 80h
007E: 50 80    MOV   A,128         (0266)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0080: 4E       SWAP  SP,A          (0267)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0268) 
                                   (0269)     ;-----------------------------------------------
                                   (0270)     ; Set Power-related Trim & the AGND Bypass bit.
                                   (0271)     ;-----------------------------------------------
                                   (0272) 
                                   (0273) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                   (0274)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0275)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0276)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0277)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0278)   IF ( AGND_BYPASS )
                                   (0279)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0280)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0281)     ; bit in the write-only BDG_TR register. Recalculate the register
                                   (0282)     ; value using the proper trim values.
                                   (0283)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0284)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0285)   ENDIF
                                   (0286)  ENDIF
                                   (0287) ENDIF ; 5.0 V Operation
                                   (0288) 
                                   (0289) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0290)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0291)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0292)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0293)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0294)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0295)  ENDIF
                                   (0296) ENDIF ; 3.3 Volt Operation
                                   (0297) 
0081: 55 F8 00 MOV   [248],0       (0298)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0084: 55 F9 00 MOV   [249],0       (0299)     mov  [bSSC_KEYSP], 0
                                   (0300) 
                                   (0301)     ;---------------------------------------
                                   (0302)     ; Initialize Crystal Oscillator and PLL
                                   (0303)     ;---------------------------------------
                                   (0304) 
                                   (0305) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0306)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0307)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0308)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                   (0309)     ; the ECO to stabilize.
                                   (0310)     ;
                                   (0311)     M8C_SetBank1
                                   (0312)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0313)     M8C_SetBank0
                                   (0314)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0315)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0316)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0317) .WaitFor1s:
                                   (0318)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0319)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0320)                                           ;   since interrupts are not globally enabled
                                   (0321) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0322)     ; Either no ECO, or waiting for stable clock is to be done in main
0087: 71 10    OR    F,16          (0323)     M8C_SetBank1
0089: 62 E0 02 MOV   REG[224],2    (0324)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
008C: 70 EF    AND   F,239         (0325)     M8C_SetBank0
008E: 62 E3 38 MOV   REG[227],56   (0326)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0327) 
                                   (0328) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0329) 
                                   (0330) IF ( PLL_MODE )
                                   (0331)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                   (0332)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                   (0333)     ;
                                   (0334)     M8C_SetBank1
                                   (0335)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0336)     M8C_SetBank0
                                   (0337)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0338)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                   (0339) 
                                   (0340) .WaitFor16ms:
                                   (0341)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                   (0342)     jz   .WaitFor16ms
                                   (0343)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                   (0344)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                   (0345)     M8C_SetBank0
                                   (0346) 
                                   (0347) IF      ( WAIT_FOR_32K )
                                   (0348) ELSE ; !( WAIT_FOR_32K )
                                   (0349)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                   (0350)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                   (0351) ENDIF ;(WAIT_FOR_32K)
                                   (0352) ENDIF ;(PLL_MODE)
                                   (0353) 
                                   (0354)     ;------------------------
                                   (0355)     ; Close CT leakage path.
                                   (0356)     ;------------------------
0091: 62 71 05 MOV   REG[113],5    (0357)     mov   reg[ACB00CR0], 05h
0094: 62 75 05 MOV   REG[117],5    (0358)     mov   reg[ACB01CR0], 05h
0097: 62 79 05 MOV   REG[121],5    (0359)     mov   reg[ACB02CR0], 05h
009A: 62 7D 05 MOV   REG[125],5    (0360)     mov   reg[ACB03CR0], 05h
                                   (0361) 
                                   (0362) 
                                   (0363) IF	(TOOLCHAIN & HITECH)
                                   (0364)     ;---------------------------------------------
                                   (0365)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0366)     ;---------------------------------------------
                                   (0367) 	global		__Lstackps
                                   (0368) 	mov     a,low __Lstackps
                                   (0369) 	swap    a,sp
                                   (0370) 
                                   (0371) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0372)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0373)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0374)     RAM_SETPAGE_CUR 0
                                   (0375)     RAM_SETPAGE_MVW 0
                                   (0376)     RAM_SETPAGE_MVR 0
                                   (0377)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0378)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0379)     ELSE
                                   (0380)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0381)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0382) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0383) ELSE
                                   (0384)     ;---------------------------------------------
                                   (0385)     ; ImageCraft Enter the Large Memory Model, if applicable
                                   (0386)     ;---------------------------------------------
                                   (0387) IF ( SYSTEM_LARGE_MEMORY_MODEL )
009D: 62 D1 07 MOV   REG[209],7    (0388)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00A0: 50 00    MOV   A,0           (0389)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00A2: 4E       SWAP  SP,A          (0390)     swap  A, SP
00A3: 62 D3 07 MOV   REG[211],7    (0391)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00A6: 62 D0 00 MOV   REG[208],0    (0392)     RAM_SETPAGE_CUR 0
00A9: 62 D5 00 MOV   REG[213],0    (0393)     RAM_SETPAGE_MVW 0
00AC: 62 D4 00 MOV   REG[212],0    (0394)     RAM_SETPAGE_MVR 0
                                   (0395) 
                                   (0396)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00AF: 71 C0    OR    F,192         (0397)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0398)   ELSE
                                   (0399)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0400)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0401) ELSE
                                   (0402)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                   (0403)     swap  SP, A
                                   (0404) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0405) ENDIF ;	TOOLCHAIN
                                   (0406) 
                                   (0407)     ;-------------------------
                                   (0408)     ; Load Base Configuration
                                   (0409)     ;-------------------------
                                   (0410)     ; Load global parameter settings and load the user modules in the
                                   (0411)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0412)     ; to minimize start up time; (2) We may still need to play with the
                                   (0413)     ; Sleep Timer.
                                   (0414)     ;
00B1: 7C 03 7F LCALL 0x037F        (0415)     lcall LoadConfigInit
                                   (0416) 
                                   (0417)     ;-----------------------------------
                                   (0418)     ; Initialize C Run-Time Environment
                                   (0419)     ;-----------------------------------
                                   (0420) IF ( C_LANGUAGE_SUPPORT )
                                   (0421) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                   (0422)     mov  A,0                           ; clear the 'bss' segment to zero
                                   (0423)     mov  [__r0],<__bss_start
                                   (0424) BssLoop:
                                   (0425)     cmp  [__r0],<__bss_end
                                   (0426)     jz   BssDone
                                   (0427)     mvi  [__r0],A
                                   (0428)     jmp  BssLoop
                                   (0429) BssDone:
                                   (0430)     mov  A,>__idata_start              ; copy idata to data segment
                                   (0431)     mov  X,<__idata_start
                                   (0432)     mov  [__r0],<__data_start
                                   (0433) IDataLoop:
                                   (0434)     cmp  [__r0],<__data_end
                                   (0435)     jz   C_RTE_Done
                                   (0436)     push A
                                   (0437)     romx
                                   (0438)     mvi  [__r0],A
                                   (0439)     pop  A
                                   (0440)     inc  X
                                   (0441)     adc  A,0
                                   (0442)     jmp  IDataLoop
                                   (0443) 
                                   (0444) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0445) 
                                   (0446) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00B4: 62 D0 00 MOV   REG[208],0    (0447)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0448)                                        ; to use the Virtual Register page.
                                   (0449) 
                                   (0450)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0451)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0452)     ; text segment and may have been relocated by the Code Compressor.
                                   (0453)     ;
00B7: 50 03    MOV   A,3           (0454)     mov   A, >__pXIData                ; Get the address of the flash
00B9: 57 7D    MOV   X,125         (0455)     mov   X, <__pXIData                ;   pointer to the xidata area.
00BB: 08       PUSH  A             (0456)     push  A
00BC: 28       ROMX                (0457)     romx                               ; get the MSB of xidata's address
00BD: 53 0C    MOV   [__r0],A      (0458)     mov   [__r0], A
00BF: 18       POP   A             (0459)     pop   A
00C0: 75       INC   X             (0460)     inc   X
00C1: 09 00    ADC   A,0           (0461)     adc   A, 0
00C3: 28       ROMX                (0462)     romx                               ; get the LSB of xidata's address
00C4: 4B       SWAP  A,X           (0463)     swap  A, X
00C5: 51 0C    MOV   A,[12]        (0464)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0465)                                        ;   XIData structure list in flash
00C7: 80 04    JMP   0x00CC        (0466)     jmp   .AccessStruct
                                   (0467) 
                                   (0468)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0469)     ; values of C variables. Each structure contains 3 member elements.
                                   (0470)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0471)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0472)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0473)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0474)     ; value in the second member element, an unsigned byte:
                                   (0475)     ; (1) If the value of the second element is non-zero, it represents
                                   (0476)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0477)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0478)     ; the bytes are copied to the block of RAM.
                                   (0479)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0480)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0481)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0482) 
                                   (0483) .AccessNextStructLoop:
00C9: 75       INC   X             (0484)     inc   X                            ; pXIData++
00CA: 09 00    ADC   A,0           (0485)     adc   A, 0
                                   (0486) .AccessStruct:                         ; Entry point for first block
                                   (0487)     ;
                                   (0488)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0489)     ;
00CC: 62 E3 00 MOV   REG[227],0    (0490)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CF: 08       PUSH  A             (0491)     push  A
00D0: 28       ROMX                (0492)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00D1: 60 D5    MOV   REG[213],A    (0493)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00D3: 74       INC   A             (0494)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00D4: A0 4B    JZ    0x0120        (0495)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D6: 18       POP   A             (0496)     pop   A                            ; restore pXIData to [A,X]
00D7: 75       INC   X             (0497)     inc   X                            ; pXIData++
00D8: 09 00    ADC   A,0           (0498)     adc   A, 0
00DA: 08       PUSH  A             (0499)     push  A
00DB: 28       ROMX                (0500)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00DC: 53 0C    MOV   [__r0],A      (0501)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00DE: 18       POP   A             (0502)     pop   A                            ; restore pXIData to [A,X]
00DF: 75       INC   X             (0503)     inc   X                            ; pXIData++ (point to size)
00E0: 09 00    ADC   A,0           (0504)     adc   A, 0
00E2: 08       PUSH  A             (0505)     push  A
00E3: 28       ROMX                (0506)     romx                               ; Get the size (CPU.A <- *pXIData)
00E4: A0 1C    JZ    0x0101        (0507)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E6: 53 0B    MOV   [__r1],A      (0508)     mov   [__r1], A                    ;             else downcount in __r1
00E8: 18       POP   A             (0509)     pop   A                            ; restore pXIData to [A,X]
                                   (0510) 
                                   (0511) .CopyNextByteLoop:
                                   (0512)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0513)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0514)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0515)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0516)     ;
00E9: 75       INC   X             (0517)     inc   X                            ; pXIData++ (point to next data byte)
00EA: 09 00    ADC   A,0           (0518)     adc   A, 0
00EC: 08       PUSH  A             (0519)     push  A
00ED: 28       ROMX                (0520)     romx                               ; Get the data value (CPU.A <- *pXIData)
00EE: 3F 0C    MVI   [__r0],A      (0521)     mvi   [__r0], A                    ; Transfer the data to RAM
00F0: 47 0C FF TST   [12],255      (0522)     tst   [__r0], 0xff                 ; Check for page crossing
00F3: B0 06    JNZ   0x00FA        (0523)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F5: 5D D5    MOV   A,REG[213]    (0524)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F7: 74       INC   A             (0525)     inc   A
00F8: 60 D5    MOV   REG[213],A    (0526)     mov   reg[ MVW_PP], A
                                   (0527) .CopyLoopTail:
00FA: 18       POP   A             (0528)     pop   A                            ; restore pXIData to [A,X]
00FB: 7A 0B    DEC   [__r1]        (0529)     dec   [__r1]                       ; End of this array in flash?
00FD: BF EB    JNZ   0x00E9        (0530)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FF: 8F C9    JMP   0x00C9        (0531)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0532) 
                                   (0533) .ClearRAMBlockToZero:
0101: 18       POP   A             (0534)     pop   A                            ; restore pXIData to [A,X]
0102: 75       INC   X             (0535)     inc   X                            ; pXIData++ (point to next data byte)
0103: 09 00    ADC   A,0           (0536)     adc   A, 0
0105: 08       PUSH  A             (0537)     push  A
0106: 28       ROMX                (0538)     romx                               ; Get the run length (CPU.A <- *pXIData)
0107: 53 0B    MOV   [__r1],A      (0539)     mov   [__r1], A                    ; Initialize downcounter
0109: 50 00    MOV   A,0           (0540)     mov   A, 0                         ; Initialize source data
                                   (0541) 
                                   (0542) .ClearRAMBlockLoop:
                                   (0543)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0544)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0545)     ;
010B: 3F 0C    MVI   [__r0],A      (0546)     mvi   [__r0], A                    ; Clear a byte
010D: 47 0C FF TST   [12],255      (0547)     tst   [__r0], 0xff                 ; Check for page crossing
0110: B0 08    JNZ   0x0119        (0548)     jnz   .ClearLoopTail               ;   No crossing, keep going
0112: 5D D5    MOV   A,REG[213]    (0549)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0114: 74       INC   A             (0550)     inc   A
0115: 60 D5    MOV   REG[213],A    (0551)     mov   reg[ MVW_PP], A
0117: 50 00    MOV   A,0           (0552)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0553) .ClearLoopTail:
0119: 7A 0B    DEC   [__r1]        (0554)     dec   [__r1]                       ; Was this the last byte?
011B: BF EF    JNZ   0x010B        (0555)     jnz   .ClearRAMBlockLoop           ;   No,  continue
011D: 18       POP   A             (0556)     pop   A                            ;   Yes, restore pXIData to [A,X] and
011E: 8F AA    JMP   0x00C9        (0557)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0558) 
                                   (0559) .C_RTE_WrapUp:
0120: 18       POP   A             (0560)     pop   A                            ; balance stack
                                   (0561) 
                                   (0562) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                   (0563) 
                                   (0564) C_RTE_Done:
                                   (0565) 
                                   (0566) ENDIF ; C_LANGUAGE_SUPPORT
                                   (0567) 
                                   (0568)     ;-------------------------------
                                   (0569)     ; Voltage Stabilization for SMP
                                   (0570)     ;-------------------------------
                                   (0571) 
                                   (0572) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                   (0573) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                   (0574)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0575)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                   (0576)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                   (0577)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0578)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                   (0579)     M8C_SetBank1
                                   (0580)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                   (0581)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                   (0582)     M8C_SetBank0
                                   (0583)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                   (0584)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                   (0585) .WaitFor2ms:
                                   (0586)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                   (0587)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                   (0588) ENDIF ; SMP is operational
                                   (0589) ENDIF ; 5.0V Operation
                                   (0590) 
                                   (0591)     ;-------------------------------
                                   (0592)     ; Set Power-On Reset (POR) Level
                                   (0593)     ;-------------------------------
                                   (0594) 
                                   (0595)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                   (0596)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                   (0597)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                   (0598)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                   (0599)     ;  lead to corruption of PSoC flash.
                                   (0600) 
0121: 71 10    OR    F,16          (0601)     M8C_SetBank1
                                   (0602) 
                                   (0603) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                   (0604)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                   (0605)  ELSE                                       ;    No, fast mode
                                   (0606)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                   (0607)                                             ;       no, set midpoint POR in user code, if desired
                                   (0608)   ELSE ; 24HMz                              ;
0123: 43 E3 20 OR    REG[227],32   (0609)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
                                   (0610)   ENDIF ; 24MHz
                                   (0611)  ENDIF ; Slow Mode
                                   (0612) ENDIF ; 5.0V Operation
                                   (0613) 
0126: 70 EF    AND   F,239         (0614)     M8C_SetBank0
                                   (0615) 
                                   (0616)     ;----------------------------
                                   (0617)     ; Wrap up and invoke "main"
                                   (0618)     ;----------------------------
                                   (0619) 
                                   (0620)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                   (0621)     ; no interrupts should be enabled now, so may as well clear the register.
                                   (0622)     ;
0128: 62 E0 00 MOV   REG[224],0    (0623)     mov  reg[INT_MSK0],0
                                   (0624) 
                                   (0625)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                   (0626)     ; And put decimator in full mode so it does not consume too much current.
                                   (0627)     ;
012B: 71 10    OR    F,16          (0628)     M8C_SetBank1
012D: 62 E0 03 MOV   REG[224],3    (0629)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0130: 43 E7 80 OR    REG[231],128  (0630)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0133: 70 EF    AND   F,239         (0631)     M8C_SetBank0
                                   (0632) 
                                   (0633)     ; Global Interrupt are NOT enabled, this should be done in main().
                                   (0634)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                   (0635)     ; Global Interrupts should be enabled as soon as possible in main().
                                   (0636)     ;
0135: 62 E2 00 MOV   REG[226],0    (0637)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                   (0638)                                    ; have been set during the boot process.
                                   (0639) IF	(TOOLCHAIN & HITECH)
                                   (0640) 	ljmp  startup                  ; Jump to C compiler startup code
                                   (0641) ELSE
                                   (0642) IF ENABLE_LJMP_TO_MAIN
                                   (0643)     ljmp  _main                    ; goto main (no return)
                                   (0644) ELSE
0138: 7C 04 BC LCALL _main         (0645)     lcall _main                    ; call main
                                   (0646) .Exit:
013B: 8F FF    JMP   0x013B        (0647)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                   (0648) ENDIF
                                   (0649) ENDIF ; TOOLCHAIN
                                   (0650) 
                                   (0651)     ;---------------------------------
                                   (0652)     ; Library Access to Global Parms
                                   (0653)     ;---------------------------------
                                   (0654)     ;
                                   (0655)  bGetPowerSetting:
                                   (0656) _bGetPowerSetting:
                                   (0657)     ; Returns value of POWER_SETTING in the A register.
                                   (0658)     ; No inputs. No Side Effects.
                                   (0659)     ;
013D: 50 10    MOV   A,16          (0660)     mov   A, POWER_SETTING
013F: 7F       RET                 (0661)     ret
0140: 30       HALT  
0141: 30       HALT  
0142: 30       HALT  
0143: 30       HALT  
0144: 30       HALT  
0145: 30       HALT  
0146: 30       HALT  
0147: 30       HALT  
0148: 30       HALT  
0149: 30       HALT  
014A: 30       HALT  
014B: 30       HALT  
014C: 30       HALT  
014D: 30       HALT  
014E: 30       HALT  
014F: 30       HALT  
0150: 30       HALT  
0151: 30       HALT  
0152: 30       HALT  
0153: 30       HALT  
0154: 30       HALT  
0155: 30       HALT  
0156: 30       HALT  
0157: 30       HALT  
0158: 30       HALT  
0159: 30       HALT  
015A: 30       HALT  
015B: 30       HALT  
015C: 30       HALT  
015D: 30       HALT  
015E: 30       HALT  
015F: 30       HALT  
0160: 30       HALT  
0161: 30       HALT  
0162: 30       HALT  
0163: 30       HALT  
0164: 30       HALT  
0165: 30       HALT  
0166: 30       HALT  
0167: 30       HALT  
0168: 30       HALT  
0169: 30       HALT  
016A: 30       HALT  
016B: 30       HALT  
016C: 30       HALT  
016D: 30       HALT  
016E: 30       HALT  
016F: 30       HALT  
0170: 30       HALT  
0171: 30       HALT  
0172: 30       HALT  
0173: 30       HALT  
0174: 30       HALT  
0175: 30       HALT  
0176: 30       HALT  
0177: 30       HALT  
0178: 30       HALT  
0179: 30       HALT  
017A: 30       HALT  
017B: 30       HALT  
017C: 30       HALT  
017D: 30       HALT  
017E: 30       HALT  
017F: 30       HALT  
0180: 30       HALT  
0181: 30       HALT  
0182: 30       HALT  
0183: 30       HALT  
0184: 30       HALT  
0185: 30       HALT  
0186: 30       HALT  
0187: 30       HALT  
0188: 30       HALT  
0189: 30       HALT  
018A: 30       HALT  
018B: 30       HALT  
018C: 30       HALT  
018D: 30       HALT  
018E: 30       HALT  
018F: 30       HALT  
0190: 30       HALT  
0191: 30       HALT  
0192: 30       HALT  
0193: 30       HALT  
0194: 30       HALT  
0195: 30       HALT  
0196: 30       HALT  
0197: 30       HALT  
0198: 30       HALT  
0199: 30       HALT  
019A: 30       HALT  
019B: 30       HALT  
019C: 30       HALT  
019D: 30       HALT  
019E: 30       HALT  
019F: 30       HALT  

FILE: lib\psocconfigtbl.asm
                                   (0001) ; Generated by PSoC Designer ???
                                   (0002) ;
                                   (0003) include "m8c.inc"
                                   (0004) ;  Personalization tables 
                                   (0005) export LoadConfigTBL_project1_Bank1
                                   (0006) export LoadConfigTBL_project1_Bank0
                                   (0007) export LoadConfigTBL_project1_Ordered
                                   (0008) AREA lit(rom, rel)
                                   (0009) LoadConfigTBL_project1_Ordered:
                                   (0010) ;  Ordered Global Register values
01A0: 71 10    OR    F,16          (0011) 	M8C_SetBank1
01A2: 62 00 00 MOV   REG[0],0      (0012) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
01A5: 62 01 FF MOV   REG[1],255    (0013) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
01A8: 70 EF    AND   F,239         (0014) 	M8C_SetBank0
01AA: 62 03 FF MOV   REG[3],255    (0015) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
01AD: 62 02 00 MOV   REG[2],0      (0016) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
01B0: 71 10    OR    F,16          (0017) 	M8C_SetBank1
01B2: 62 02 00 MOV   REG[2],0      (0018) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
01B5: 62 03 00 MOV   REG[3],0      (0019) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
01B8: 70 EF    AND   F,239         (0020) 	M8C_SetBank0
01BA: 62 01 00 MOV   REG[1],0      (0021) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
01BD: 71 10    OR    F,16          (0022) 	M8C_SetBank1
01BF: 62 04 00 MOV   REG[4],0      (0023) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
01C2: 62 05 FF MOV   REG[5],255    (0024) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
01C5: 70 EF    AND   F,239         (0025) 	M8C_SetBank0
01C7: 62 07 FF MOV   REG[7],255    (0026) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
01CA: 62 06 00 MOV   REG[6],0      (0027) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
01CD: 71 10    OR    F,16          (0028) 	M8C_SetBank1
01CF: 62 06 00 MOV   REG[6],0      (0029) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
01D2: 62 07 00 MOV   REG[7],0      (0030) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
01D5: 70 EF    AND   F,239         (0031) 	M8C_SetBank0
01D7: 62 05 00 MOV   REG[5],0      (0032) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
01DA: 71 10    OR    F,16          (0033) 	M8C_SetBank1
01DC: 62 08 7F MOV   REG[8],127    (0034) 	mov	reg[08h], 7fh		; Port_2_DriveMode_0 register (PRT2DM0)
01DF: 62 09 80 MOV   REG[9],128    (0035) 	mov	reg[09h], 80h		; Port_2_DriveMode_1 register (PRT2DM1)
01E2: 70 EF    AND   F,239         (0036) 	M8C_SetBank0
01E4: 62 0B 80 MOV   REG[11],128   (0037) 	mov	reg[0bh], 80h		; Port_2_DriveMode_2 register (PRT2DM2)
01E7: 62 0A 00 MOV   REG[10],0     (0038) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
01EA: 71 10    OR    F,16          (0039) 	M8C_SetBank1
01EC: 62 0A 00 MOV   REG[10],0     (0040) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
01EF: 62 0B 00 MOV   REG[11],0     (0041) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
01F2: 70 EF    AND   F,239         (0042) 	M8C_SetBank0
01F4: 62 09 00 MOV   REG[9],0      (0043) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
01F7: 71 10    OR    F,16          (0044) 	M8C_SetBank1
01F9: 62 0C 00 MOV   REG[12],0     (0045) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
01FC: 62 0D 00 MOV   REG[13],0     (0046) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
01FF: 70 EF    AND   F,239         (0047) 	M8C_SetBank0
0201: 62 0F 00 MOV   REG[15],0     (0048) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
0204: 62 0E 00 MOV   REG[14],0     (0049) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0207: 71 10    OR    F,16          (0050) 	M8C_SetBank1
0209: 62 0E 00 MOV   REG[14],0     (0051) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
020C: 62 0F 00 MOV   REG[15],0     (0052) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
020F: 70 EF    AND   F,239         (0053) 	M8C_SetBank0
0211: 62 0D 00 MOV   REG[13],0     (0054) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0214: 71 10    OR    F,16          (0055) 	M8C_SetBank1
0216: 62 10 00 MOV   REG[16],0     (0056) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0219: 62 11 00 MOV   REG[17],0     (0057) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
021C: 70 EF    AND   F,239         (0058) 	M8C_SetBank0
021E: 62 13 00 MOV   REG[19],0     (0059) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
0221: 62 12 00 MOV   REG[18],0     (0060) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0224: 71 10    OR    F,16          (0061) 	M8C_SetBank1
0226: 62 12 00 MOV   REG[18],0     (0062) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0229: 62 13 00 MOV   REG[19],0     (0063) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
022C: 70 EF    AND   F,239         (0064) 	M8C_SetBank0
022E: 62 11 00 MOV   REG[17],0     (0065) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0231: 71 10    OR    F,16          (0066) 	M8C_SetBank1
0233: 62 14 00 MOV   REG[20],0     (0067) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0236: 62 15 00 MOV   REG[21],0     (0068) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0239: 70 EF    AND   F,239         (0069) 	M8C_SetBank0
023B: 62 17 00 MOV   REG[23],0     (0070) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
023E: 62 16 00 MOV   REG[22],0     (0071) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0241: 71 10    OR    F,16          (0072) 	M8C_SetBank1
0243: 62 16 00 MOV   REG[22],0     (0073) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0246: 62 17 00 MOV   REG[23],0     (0074) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0249: 70 EF    AND   F,239         (0075) 	M8C_SetBank0
024B: 62 15 00 MOV   REG[21],0     (0076) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
024E: 71 10    OR    F,16          (0077) 	M8C_SetBank1
0250: 62 18 00 MOV   REG[24],0     (0078) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
0253: 62 19 00 MOV   REG[25],0     (0079) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0256: 70 EF    AND   F,239         (0080) 	M8C_SetBank0
0258: 62 1B 00 MOV   REG[27],0     (0081) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
025B: 62 1A 00 MOV   REG[26],0     (0082) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
025E: 71 10    OR    F,16          (0083) 	M8C_SetBank1
0260: 62 1A 00 MOV   REG[26],0     (0084) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
0263: 62 1B 00 MOV   REG[27],0     (0085) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0266: 70 EF    AND   F,239         (0086) 	M8C_SetBank0
0268: 62 19 00 MOV   REG[25],0     (0087) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
026B: 71 10    OR    F,16          (0088) 	M8C_SetBank1
026D: 62 1C 00 MOV   REG[28],0     (0089) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0270: 62 1D 00 MOV   REG[29],0     (0090) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0273: 70 EF    AND   F,239         (0091) 	M8C_SetBank0
0275: 62 1F 00 MOV   REG[31],0     (0092) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
0278: 62 1E 00 MOV   REG[30],0     (0093) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
027B: 71 10    OR    F,16          (0094) 	M8C_SetBank1
027D: 62 1E 00 MOV   REG[30],0     (0095) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0280: 62 1F 00 MOV   REG[31],0     (0096) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0283: 70 EF    AND   F,239         (0097) 	M8C_SetBank0
0285: 62 1D 00 MOV   REG[29],0     (0098) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
0288: 7F       RET                 (0099) 	ret
0289: 60 28    MOV   REG[40],A
028B: 66 00    ASL   [X+0]
028D: 63 15 65 MOV   REG[X+21],101
0290: 00       SWI   
0291: E6 50    JACC  0x08E2
0293: E7 20    JACC  0x09B4
0295: D6 00    JNC   0x0896
0297: B0 00    JNZ   0x0298
0299: B1 00    JNZ   0x039A
029B: B2 00    JNZ   0x049C
029D: B3 33    JNZ   0x05D1
029F: B4 33    JNZ   0x06D3
02A1: B5 00    JNZ   0x07A2
02A3: B6 00    JNZ   0x08A4
02A5: B8 55    JNZ   0xFAFB
02A7: B9 00    JNZ   0xFBA8
02A9: BA 10    JNZ   0xFCBA
02AB: BB 33    JNZ   0xFDDF
02AD: BC 33    JNZ   0xFEE1
02AF: BD 00    JNZ   0xFFB0
02B1: BE 00    JNZ   0x00B2
02B3: C0 00    JC    0x02B4
02B5: C1 00    JC    0x03B6
02B7: C2 20    JC    0x04D8
02B9: C3 33    JC    0x05ED
02BB: C4 33    JC    0x06EF
02BD: C5 00    JC    0x07BE
02BF: C6 00    JC    0x08C0
02C1: C8 55    JC    0xFB17
02C3: C9 00    JC    0xFBC4
02C5: CA 30    JC    0xFCF6
02C7: CB 33    JC    0xFDFB
02C9: CC 33    JC    0xFEFD
02CB: CD 00    JC    0xFFCC
02CD: CE 00    JC    0x00CE
02CF: 6C 00    RLC   [X+0]
02D1: 6D       RRC   A
02D2: 00       SWI   
02D3: 6E 00    RRC   [0]
02D5: 6F 00    RRC   [X+0]
02D7: 90 90    CALL  0x0369
02D9: 91 A0    CALL  0x047B
02DB: 92 61    CALL  0x053E
02DD: 93 F0    CALL  0x06CF
02DF: 98 90    CALL  0xFB71
02E1: 99 A0    CALL  0xFC83
02E3: 9A 60    CALL  0xFD45
02E5: 9B F0    CALL  0xFED7
02E7: 43 00 41 OR    REG[0],65
02EA: 00       SWI   
02EB: 42 00 4F AND   REG[X+0],79
02EE: 00       SWI   
02EF: 4D 00    SWAP  X,[0]
02F1: 4E       SWAP  SP,A
02F2: 00       SWI   
02F3: 47 00 45 TST   [0],69
02F6: 00       SWI   
02F7: 46 00 4B XOR   REG[X+0],75
02FA: 00       SWI   
02FB: 49 00 4A TST   REG[0],74
02FE: 00       SWI   
02FF: 80 94    JMP   0x0394
0301: 81 88    JMP   0x048A
0303: 82 00    JMP   0x0504
0305: 83 24    JMP   0x062A
0307: 84 92    JMP   0x079A
0309: 85 40    JMP   0x084A
030B: 86 9F    JMP   0x09AB
030D: 87 20    JMP   0x0A2E
030F: 88 94    JMP   0xFBA4
0311: 89 88    JMP   0xFC9A
0313: 8A 00    JMP   0xFD14
0315: 8B 24    JMP   0xFE3A
0317: 8C 92    JMP   0xFFAA
0319: 8D 40    JMP   0x005A
031B: 8E 9F    JMP   0x01BB
031D: 8F 20    JMP   0x023E
031F: 71 FD    OR    F,253
0321: 72 A3    XOR   F,163
0323: 73       CPL   A
0324: 20       POP   X
0325: 70 00    AND   F,0
0327: 75       INC   X
0328: 1D 76    SBB   [X+118],A
032A: 21 77    AND   A,119
032C: 20       POP   X
032D: 74       INC   A
032E: 01 79    ADD   A,121
0330: FD 7A    INDEX 0x00AC
0332: A3 7B    JZ    0x06AE
0334: 20       POP   X
0335: 78       DEC   A
0336: 00       SWI   
0337: 7D 1D 7E LJMP  0x1D7E
033A: 21 7F    AND   A,127
033C: 20       POP   X
033D: 7C 01 FF LCALL 0x01FF
0340: 61 00    MOV   REG[X+0],A
0342: 69 00    ASR   [X+0]
0344: 60 00    MOV   REG[0],A
0346: 62 BC 67 MOV   REG[188],103
0349: 33 68    XOR   A,[X+104]
034B: 33 63    XOR   A,[X+99]
034D: 00       SWI   
034E: 66 00    ASL   [X+0]
0350: D1 00    JNC   0x0451
0352: D3 00    JNC   0x0653
0354: D0 00    JNC   0x0355
0356: D2 00    JNC   0x0557
0358: E1 27    JACC  0x0480
035A: E2 00    JACC  0x055B
035C: DF 19    JNC   0x0276
035E: DE 02    JNC   0x0161
0360: DD 00    JNC   0x0061
0362: E7 00    JACC  0x0A63
0364: 40       NOP   
0365: 21 41    AND   A,65
0367: 45 42 40 XOR   REG[66],64
036A: 4C 21    SWAP  A,[33]
036C: 4D 65    SWAP  X,[101]
036E: 4E       SWAP  SP,A
036F: 40       NOP   
0370: 44 01 45 OR    REG[X+1],69
0373: 15 46    SUB   [X+70],A
0375: 40       NOP   
0376: 48 21 49 TST   [X+33],73
0379: 35 4A    XOR   [X+74],A
037B: 40       NOP   
037C: FF 04    INDEX 0x0282
037E: BE 55    JNZ   0x01D4

FILE: lib\psocconfig.asm
                                   (0001) ; Generated by PSoC Designer ???
                                   (0002) ;
                                   (0003) ;==========================================================================
                                   (0004) ;  PSoCConfig.asm
                                   (0005) ;  @PSOC_VERSION
                                   (0006) ;
                                   (0007) ;  Version: 0.85
                                   (0008) ;  Revised: June 22, 2004
                                   (0009) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;
                                   (0011) ;  This file is generated by the Device Editor on Application Generation.
                                   (0012) ;  It contains code which loads the configuration data table generated in
                                   (0013) ;  the file PSoCConfigTBL.asm
                                   (0014) ;
                                   (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0016) ;  Edits to this file will not be preserved.
                                   (0017) ;==========================================================================
                                   (0018) ;
                                   (0019) include "m8c.inc"
                                   (0020) include "memory.inc"
                                   (0021) include "GlobalParams.inc"
                                   (0022) 
                                   (0023) export LoadConfigInit
                                   (0024) export _LoadConfigInit
                                   (0025) export LoadConfig_project1
                                   (0026) export _LoadConfig_project1
                                   (0027) export Port_2_Data_SHADE
                                   (0028) export _Port_2_Data_SHADE
                                   (0029) export Port_2_DriveMode_0_SHADE
                                   (0030) export _Port_2_DriveMode_0_SHADE
                                   (0031) export Port_2_DriveMode_1_SHADE
                                   (0032) export _Port_2_DriveMode_1_SHADE
                                   (0033) 
                                   (0034) 
                                   (0035) export NO_SHADOW
                                   (0036) export _NO_SHADOW
                                   (0037) 
                                   (0038) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0039) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0040) 
                                   (0041) AREA psoc_config(rom, rel)
                                   (0042) 
                                   (0043) ;---------------------------------------------------------------------------
                                   (0044) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0045) ;                  parameters handled by boot code, like CPU speed). This
                                   (0046) ;                  function can be called from user code, but typically it
                                   (0047) ;                  is only called from boot.
                                   (0048) ;
                                   (0049) ;       INPUTS: None.
                                   (0050) ;      RETURNS: Nothing.
                                   (0051) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0052) ;               In the large memory model currently only the page
                                   (0053) ;               pointer registers listed below are modified.  This does
                                   (0054) ;               not guarantee that in future implementations of this
                                   (0055) ;               function other page pointer registers will not be
                                   (0056) ;               modified.
                                   (0057) ;          
                                   (0058) ;               Page Pointer Registers Modified: 
                                   (0059) ;               CUR_PP
                                   (0060) ;
                                   (0061) _LoadConfigInit:
                                   (0062)  LoadConfigInit:
                                   (0063)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0064)     
0380: 00       SWI                 (0065) 	mov		[Port_2_Data_SHADE], 0h
0381: 00       SWI   
0382: 55 01 7F MOV   [1],127       (0066) 	mov		[Port_2_DriveMode_0_SHADE], 7fh
0385: 55 02 80 MOV   [2],128       (0067) 	mov		[Port_2_DriveMode_1_SHADE], 80h
                                   (0068) 
0388: 7C 01 A0 LCALL 0x01A0        (0069) 	lcall	LoadConfigTBL_project1_Ordered
038B: 7C 03 8F LCALL 0x038F        (0070) 	lcall	LoadConfig_project1
                                   (0071) 
                                   (0072) 
                                   (0073)     RAM_EPILOGUE RAM_USE_CLASS_4
038E: 7F       RET                 (0074)     ret
                                   (0075) 
                                   (0076) ;---------------------------------------------------------------------------
                                   (0077) ; Load Configuration project1
                                   (0078) ;
                                   (0079) ;    Load configuration registers for project1.
                                   (0080) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0081) ;
                                   (0082) ;       INPUTS: None.
                                   (0083) ;      RETURNS: Nothing.
                                   (0084) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0085) ;               modified as may the Page Pointer registers!
                                   (0086) ;               In the large memory model currently only the page
                                   (0087) ;               pointer registers listed below are modified.  This does
                                   (0088) ;               not guarantee that in future implementations of this
                                   (0089) ;               function other page pointer registers will not be
                                   (0090) ;               modified.
                                   (0091) ;          
                                   (0092) ;               Page Pointer Registers Modified: 
                                   (0093) ;               CUR_PP
                                   (0094) ;
                                   (0095) _LoadConfig_project1:
                                   (0096)  LoadConfig_project1:
                                   (0097)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0098) 
038F: 10       PUSH  X             (0099) 	push	x
0390: 70 EF    AND   F,239         (0100)     M8C_SetBank0                    ; Force bank 0
0392: 50 00    MOV   A,0           (0101)     mov     a, 0                    ; Specify bank 0
0394: 67       ASR   A             (0102)     asr     a                       ; Store in carry flag
                                   (0103)                                     ; Load bank 0 table:
0395: 50 02    MOV   A,2           (0104)     mov     A, >LoadConfigTBL_project1_Bank0
0397: 57 89    MOV   X,137         (0105)     mov     X, <LoadConfigTBL_project1_Bank0
0399: 7C 03 AA LCALL 0x03AA        (0106)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0107) 
039C: 50 01    MOV   A,1           (0108)     mov     a, 1                    ; Specify bank 1
039E: 67       ASR   A             (0109)     asr     a                       ; Store in carry flag
                                   (0110)                                     ; Load bank 1 table:
039F: 50 03    MOV   A,3           (0111)     mov     A, >LoadConfigTBL_project1_Bank1
03A1: 57 40    MOV   X,64          (0112)     mov     X, <LoadConfigTBL_project1_Bank1
03A3: 7C 03 AA LCALL 0x03AA        (0113)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0114) 
03A6: 70 EF    AND   F,239         (0115)     M8C_SetBank0                    ; Force return to bank 0
03A8: 20       POP   X             (0116) 	pop		x
                                   (0117) 
                                   (0118)     RAM_EPILOGUE RAM_USE_CLASS_4
03A9: 7F       RET                 (0119)     ret
                                   (0120) 
                                   (0121) 
                                   (0122) 
                                   (0123) 
                                   (0124) ;---------------------------------------------------------------------------
                                   (0125) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                   (0126) ;              pairs. Terminate on address=0xFF.
                                   (0127) ;
                                   (0128) ;  INPUTS:  [A,X] points to the table to be loaded
                                   (0129) ;           Flag Register Carry bit encodes the Register Bank
                                   (0130) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                   (0131) ;
                                   (0132) ;  RETURNS: nothing.
                                   (0133) ;
                                   (0134) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                   (0135) ;                X-3 Temporary store for register address
                                   (0136) ;                X-2 LSB of config table address
                                   (0137) ;                X-1 MSB of config table address
                                   (0138) ;
                                   (0139) LoadConfig:
                                   (0140)     RAM_PROLOGUE RAM_USE_CLASS_2
03AA: 38 02    ADD   SP,2          (0141)     add     SP, 2                   ; Set up local vars
03AC: 10       PUSH  X             (0142)     push    X                       ; Save config table address on stack
03AD: 08       PUSH  A             (0143)     push    A
03AE: 4F       MOV   X,SP          (0144)     mov     X, SP
03AF: 56 FC 00 MOV   [X-4],0       (0145)     mov     [X-4], 0                ; Set default Destination to Bank 0
03B2: D0 04    JNC   0x03B7        (0146)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
03B4: 56 FC 01 MOV   [X-4],1       (0147)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                   (0148) .BankSelectSaved:
03B7: 18       POP   A             (0149)     pop     A
03B8: 20       POP   X             (0150)     pop     X
                                   (0151) 
                                   (0152) LoadConfigLp:
03B9: 70 EF    AND   F,239         (0153)     M8C_SetBank0                    ; Switch to bank 0
03BB: 62 E3 00 MOV   REG[227],0    (0154)     M8C_ClearWDT                    ; Clear the watchdog for long inits
03BE: 10       PUSH  X             (0155)     push    X                       ; Preserve the config table address
03BF: 08       PUSH  A             (0156)     push    A
03C0: 28       ROMX                (0157)     romx                            ; Load register address from table
03C1: 39 FF    CMP   A,255         (0158)     cmp     A, END_CONFIG_TABLE     ; End of table?
03C3: A0 1F    JZ    0x03E3        (0159)     jz      EndLoadConfig           ;   Yes, go wrap it up
03C5: 4F       MOV   X,SP          (0160)     mov     X, SP                   ;
03C6: 48 FC 01 TST   [X-4],1       (0161)     tst     [X-4], 1                ; Loading IO Bank 1?
03C9: A0 03    JZ    0x03CD        (0162)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
03CB: 71 10    OR    F,16          (0163)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                   (0164) .IOBankNowSet:
03CD: 54 FD    MOV   [X-3],A       (0165)     mov     [X-3], A                ; Stash the register address
03CF: 18       POP   A             (0166)     pop     A                       ; Retrieve the table address
03D0: 20       POP   X             (0167)     pop     X
03D1: 75       INC   X             (0168)     inc     X                       ; Advance to the data byte
03D2: 09 00    ADC   A,0           (0169)     adc     A, 0
03D4: 10       PUSH  X             (0170)     push    X                       ; Save the config table address again
03D5: 08       PUSH  A             (0171)     push    A
03D6: 28       ROMX                (0172)     romx                            ; load config data from the table
03D7: 4F       MOV   X,SP          (0173)     mov     X, SP                   ; retrieve the register address
03D8: 59 FD    MOV   X,[X-3]       (0174)     mov     X, [X-3]
03DA: 61 00    MOV   REG[X+0],A    (0175)     mov     reg[X], A               ; Configure the register
03DC: 18       POP   A             (0176)     pop     A                       ; retrieve the table address
03DD: 20       POP   X             (0177)     pop     X
03DE: 75       INC   X             (0178)     inc     X                       ; advance to next table entry
03DF: 09 00    ADC   A,0           (0179)     adc     A, 0
03E1: 8F D7    JMP   0x03B9        (0180)     jmp     LoadConfigLp            ; loop to configure another register
                                   (0181) EndLoadConfig:
03E3: 38 FC    ADD   SP,252        (0182)     add     SP, -4
03E5: 70 3F    AND   F,63
03E7: 71 C0    OR    F,192         (0183)     RAM_EPILOGUE RAM_USE_CLASS_2
03E9: 7F       RET                 (0184)     ret
03EA: FF FE    INDEX 0x03EA
03EC: FC F8    INDEX 0x00E6
03EE: F0 E0    INDEX 0x04D0
03F0: C0 02    JC    0x03F3
03F2: 04 08    ADD   [8],A
03F4: 10       PUSH  X
03F5: 20       POP   X
03F6: 40       NOP   
03F7: 80 76    JMP   0x046E

FILE: lib\dualadc_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   DUALADC_1INT.asm
                                   (0004) ;;  Version: 2.2, Updated on 2008/11/17 at 11:17:43
                                   (0005) ;;  Generated by PSoC Designer ???
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: DualADC Interrupt Service Routines.
                                   (0008) ;;
                                   (0009) ;;-----------------------------------------------------------------------------
                                   (0010) ;;  Copyright (c) Cypress MicroSystems 2001-2003. All Rights Reserved.
                                   (0011) ;;*****************************************************************************
                                   (0012) ;;*****************************************************************************
                                   (0013) 
                                   (0014) include "m8c.inc"
                                   (0015) include "memory.inc"
                                   (0016) include "DUALADC_1.inc"
                                   (0017) 
                                   (0018) ;-----------------------------------------------
                                   (0019) ;  Global Symbols
                                   (0020) ;-----------------------------------------------
                                   (0021) export _DUALADC_1_CNT1_ISR
                                   (0022) export _DUALADC_1_CNT2_ISR
                                   (0023) export _DUALADC_1_PWM16_ISR
                                   (0024) 
                                   (0025) export  DUALADC_1_cCounter1U
                                   (0026) export  DUALADC_1_cCounter2U
                                   (0027) export _DUALADC_1_iResult1
                                   (0028) export  DUALADC_1_iResult1
                                   (0029) export _DUALADC_1_iResult2
                                   (0030) export  DUALADC_1_iResult2
                                   (0031) export _DUALADC_1_bfStatus
                                   (0032) export  DUALADC_1_bfStatus
                                   (0033) export  DUALADC_1_bSampC
                                   (0034) 
                                   (0035) 
                                   (0036) ;-----------------------------------------------
                                   (0037) ; Variable Allocation
                                   (0038) ;-----------------------------------------------
                                   (0039) AREA InterruptRAM(RAM, REL, CON)
                                   (0040) 
                                   (0041)  DUALADC_1_cCounter1U:     BLK   1  ;The Upper byte of the Counter
                                   (0042)  DUALADC_1_cCounter2U:     BLK   1  ;The Upper byte of the Counter
                                   (0043) _DUALADC_1_iResult1:
                                   (0044)  DUALADC_1_iResult1:       BLK   2  ;A/D value
                                   (0045) _DUALADC_1_iResult2:
                                   (0046)  DUALADC_1_iResult2:       BLK   2  ;A/D value
                                   (0047) _DUALADC_1_bfStatus:
                                   (0048)  DUALADC_1_bfStatus:       BLK   1  ;Data Valid Flag
                                   (0049)  DUALADC_1_bSampC:         BLK   1  ;# of times to run A/D
                                   (0050) 
                                   (0051) 
                                   (0052) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0053) ;---------------------------------------------------
                                   (0054) ; Insert your custom declarations below this banner
                                   (0055) ;---------------------------------------------------
                                   (0056) 
                                   (0057) ;------------------------
                                   (0058) ; Includes
                                   (0059) ;------------------------
                                   (0060) 
                                   (0061) 	
                                   (0062) ;------------------------
                                   (0063) ;  Constant Definitions
                                   (0064) ;------------------------
                                   (0065) 
                                   (0066) 
                                   (0067) ;------------------------
                                   (0068) ; Variable Allocation
                                   (0069) ;------------------------
                                   (0070) 
                                   (0071) 
                                   (0072) ;---------------------------------------------------
                                   (0073) ; Insert your custom declarations above this banner
                                   (0074) ;---------------------------------------------------
                                   (0075) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0076) 
                                   (0077) 
                                   (0078) ;-----------------------------------------------
                                   (0079) ;  EQUATES and TABLES
                                   (0080) ;-----------------------------------------------
                                   (0081) ; Constant Definitions
                                   (0082) LowByte:   equ 1
                                   (0083) HighByte:  equ 0
                                   (0084) 
                                   (0085) 
                                   (0086) AREA UserModules (ROM, REL)
                                   (0087) 
                                   (0088) 
                                   (0089) .LITERAL
                                   (0090) DUALADC_1MaxNegX4Table:
                                   (0091) ; Bits  7    8    9   10   11   12   13
                                   (0092)    DB  FFh, FEh, FCh, F8h, F0h, E0h, C0h
                                   (0093) 
                                   (0094) DUALADC_1MaxPosX4Table:
                                   (0095) IF (DUALADC_1_DATA_FORMAT)
                                   (0096) ; Bits (signed)    7    8    9   10   11   12   13
                                   (0097)               DB  01h, 02h, 04h, 08h, 10h, 20h, 40h
                                   (0098) ELSE
                                   (0099) ; Bits (unsigned)  7    8    9   10   11   12   13
                                   (0100)               DB  02h, 04h, 08h, 10h, 20h, 40h, 80h
                                   (0101) 
                                   (0102) ENDIF
                                   (0103) .ENDLITERAL
                                   (0104) 
                                   (0105) 
                                   (0106) ;-----------------------------------------------------------------------------
                                   (0107) ;  FUNCTION NAME: _DUALADC_1_CNT1_ISR (Counter8 Interrupt)
                                   (0108) ;
                                   (0109) ;
                                   (0110) ;  DESCRIPTION:
                                   (0111) ;    Increment the upper (software) half on the counter whenever the
                                   (0112) ;    lower (hardware) half of the counter underflows.  This counter
                                   (0113) ;    should start out at the most negative value (0xFF).
                                   (0114) ;
                                   (0115) ;-----------------------------------------------------------------------------
                                   (0116) ;
                                   (0117) _DUALADC_1_CNT1_ISR:
03F9: 03 7E    ADD   A,[X+126]     (0118)    inc [DUALADC_1_cCounter1U]
                                   (0119)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                   (0120)    ;---------------------------------------------------
                                   (0121)    ; Insert your custom code below this banner
                                   (0122)    ;---------------------------------------------------
                                   (0123)    ;   NOTE: interrupt service routines must preserve
                                   (0124)    ;   the values of the A and X CPU registers.
                                   (0125) 
                                   (0126)    ;---------------------------------------------------
                                   (0127)    ; Insert your custom code above this banner
                                   (0128)    ;---------------------------------------------------
                                   (0129)    ;@PSoC_UserCode_END@ (Do not change this line.)
03FB: 76 04    INC   [4]           (0130)    reti
                                   (0131) 
                                   (0132) 
                                   (0133) ;-----------------------------------------------------------------------------
                                   (0134) ;  FUNCTION NAME: _DUALADC_1_CNT2_ISR (Counter8 Interrupt)
                                   (0135) ;
                                   (0136) ;
                                   (0137) ;  DESCRIPTION:
                                   (0138) ;  Increment the upper (software) half on the counter whenever the
                                   (0139) ;  lower (hardware) half of the counter underflows.  This counter
                                   (0140) ;  should start out at the most negative value (0xFF).
                                   (0141) ;
                                   (0142) ;-----------------------------------------------------------------------------
                                   (0143) ;
                                   (0144) _DUALADC_1_CNT2_ISR:
                                   (0145)    inc [DUALADC_1_cCounter2U]
                                   (0146)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0147)    ;---------------------------------------------------
                                   (0148)    ; Insert your custom code below this banner
                                   (0149)    ;---------------------------------------------------
                                   (0150)    ;   NOTE: interrupt service routines must preserve
                                   (0151)    ;   the values of the A and X CPU registers.
                                   (0152) 
                                   (0153)    ;---------------------------------------------------
                                   (0154)    ; Insert your custom code above this banner
                                   (0155)    ;---------------------------------------------------
                                   (0156)    ;@PSoC_UserCode_END@ (Do not change this line.)
03FD: 7E       RETI                (0157)    reti
                                   (0158) 
                                   (0159) 
                                   (0160) ;-----------------------------------------------------------------------------
                                   (0161) ;  FUNCTION NAME: _DUALADC_1_PWM16_ISR  (PWM16 Interrupt)
                                   (0162) ;
                                   (0163) ;  DESCRIPTION:
                                   (0164) ;  This ISR is called when the ADC has completed and integrate cycle.
                                   (0165) ;  The ADC value is calculated and stored in a global location before
                                   (0166) ;  the end of the ISR.
                                   (0167) ;
                                   (0168) ;-----------------------------------------------------------------------------
                                   (0169) ;
                                   (0170) _DUALADC_1_PWM16_ISR:
03FE: 41 43 FE AND   REG[67],254   (0171)    and   reg[DUALADC_1_bCounter1_CR0], ~DUALADC_1_fDBLK_ENABLE  ; Disable Counter
0401: 41 4F FE AND   REG[79],254   (0172)    and   reg[DUALADC_1_bCounter2_CR0], ~DUALADC_1_fDBLK_ENABLE  ; Disable Counter
                                   (0173) IF DUALADC_1_NoAZ
0404: 43 92 20 OR    REG[146],32   (0174)    or    reg[DUALADC_1_bfADC1cr2], DUALADC_1_fAutoZero     ; Put Integrator in AutoZero
0407: 43 9A 20 OR    REG[154],32   (0175)    or    reg[DUALADC_1_bfADC2cr2], DUALADC_1_fAutoZero     ; Put Integrator in AutoZero
                                   (0176) ENDIF
040A: 43 93 10 OR    REG[147],16   (0177)    or   reg[DUALADC_1_bfADC1cr3],DUALADC_1_fFSW0           ; Put Integrator in reset
040D: 43 9B 10 OR    REG[155],16   (0178)    or   reg[DUALADC_1_bfADC2cr3],DUALADC_1_fFSW0           ; Put Integrator in reset
                                   (0179) 
                                   (0180)                                                            ; Enable interrupts for a short period of time just in case.
                                   (0181)                                                            ; Make sure we didn't have a counter interrupt ready to fire
0410: 71 01    OR    F,1           (0182)    M8C_EnableGInt
0412: 40       NOP                 (0183)    nop                                                     ; Wait a couple cycles
0413: 70 FE    AND   F,254         (0184)    M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
0415: 08       PUSH  A             (0185)    push  A                                                 ; Save the Accumulator
                                   (0186) 
                                   (0187) 
                                   (0188)    ; Get ADC1 result
0416: 5D 40    MOV   A,REG[64]     (0189)    mov   A,reg[DUALADC_1_bCount1]                          ; Read counter value  (Bogus read puts value in Period register)
0418: 5D 42    MOV   A,REG[66]     (0190)    mov   A,reg[DUALADC_1_bCompare1]                        ; Read counter value
041A: 78       DEC   A             (0191)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
041B: 73       CPL   A             (0192)    cpl   A                                                 ; Invert the value
041C: D0 03    JNC   0x0420        (0193)    jnc   DUALADC_1_INT_CALCV1                              ; if carry, then inc MSB as well
041E: 76 03    INC   [3]           (0194)    inc   [DUALADC_1_cCounter1U]
                                   (0195) DUALADC_1_INT_CALCV1:
0420: 53 06    MOV   [6],A         (0196)    mov   [(DUALADC_1_iResult1 + LowByte)],A                ; Store LSB value
0422: 51 03    MOV   A,[3]         (0197)    mov   A, [DUALADC_1_cCounter1U]                         ; Store MSB from temp counter
0424: 53 05    MOV   [5],A         (0198)    mov   [(DUALADC_1_iResult1 + HighByte)],A
                                   (0199) 
                                   (0200)    ; Get ADC2 result
0426: 5D 4C    MOV   A,REG[76]     (0201)    mov   A,reg[DUALADC_1_bCount2]                          ; Read counter value  (Bogus read puts value in Period register)
0428: 5D 4E    MOV   A,REG[78]     (0202)    mov   A,reg[DUALADC_1_bCompare2]                        ; Read counter value
042A: 78       DEC   A             (0203)    dec   A                                                 ; Decrement by one to make sure we didn't miss a count
042B: 73       CPL   A             (0204)    cpl   A                                                 ; Invert the value
042C: D0 03    JNC   0x0430        (0205)    jnc   DUALADC_1_INT_CALCV2                              ; if carry, then inc MSB as well
042E: 76 04    INC   [4]           (0206)    inc   [DUALADC_1_cCounter2U]
                                   (0207) DUALADC_1_INT_CALCV2:
0430: 53 08    MOV   [8],A         (0208)    mov   [(DUALADC_1_iResult2 + LowByte)],A                ; Store LSB value
0432: 51 04    MOV   A,[4]         (0209)    mov   A, [DUALADC_1_cCounter2U]                         ; Store MSB from temp counter
0434: 53 07    MOV   [7],A         (0210)    mov   [(DUALADC_1_iResult2 + HighByte)],A
                                   (0211) 
                                   (0212)                                                            ; The new value has been stored,
                                   (0213)                                                            ; so get counters ready for next reading first.
0436: 62 41 FF MOV   REG[65],255   (0214)    mov   reg[DUALADC_1_bPeriod1], ffh                      ; Initialize counter1 to FF - Set to overflow after 256 counts
0439: 62 4D FF MOV   REG[77],255   (0215)    mov   reg[DUALADC_1_bPeriod2], ffh                      ; Initialize counter2 to FF - Set to overflow after 256 counts
043C: 43 43 01 OR    REG[67],1     (0216)    or    reg[DUALADC_1_bCounter1_CR0],DUALADC_1_fDBLK_ENABLE  ; Enable Counter1
043F: 43 4F 01 OR    REG[79],1     (0217)    or    reg[DUALADC_1_bCounter2_CR0],DUALADC_1_fDBLK_ENABLE  ; Enable Counter2
                                   (0218) 
                                   (0219) 
                                   (0220) IF (DUALADC_1_DATA_FORMAT)                                 ; Only check for Negative numbers if SIGNED result
                                   (0221)    mov   A, [DUALADC_1_bfStatus]                           ; Get Status with Resolution
                                   (0222)    and   A, DUALADC_1_bRES_MASK                            ; Mask of resolution
                                   (0223)    index DUALADC_1MaxNegX4Table                            ; Get Maximum negative value from table
                                   (0224)    mov   [DUALADC_1_cCounter1U], A                         ; Place result back into MSB of counter
                                   (0225)    mov   [DUALADC_1_cCounter2U], A                         ; Place result back into MSB of counter
                                   (0226) ELSE
0442: 55 03 00 MOV   [3],0         (0227)    mov   [DUALADC_1_cCounter1U], 00h                       ; Place result back into MSB of counter
0445: 55 04 00 MOV   [4],0         (0228)    mov   [DUALADC_1_cCounter2U], 00h                       ; Place result back into MSB of counter
                                   (0229) ENDIF
                                   (0230) 
                                   (0231)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                   (0232)    ;---------------------------------------------------
                                   (0233)    ; If the input is muxed with multiple inputs
                                   (0234)    ; this is a good place to change inputs.
                                   (0235)    ; Insert your custom code below this banner
                                   (0236)    ;---------------------------------------------------
                                   (0237)    ;   NOTE: interrupt service routines must preserve
                                   (0238)    ;   the values of the A and X CPU registers. At this
                                   (0239)    ;   point A has been preserved on the stack and will
                                   (0240)    ;   be restored before the return from interrupt.
                                   (0241)    ;   However, if you use the X register, you must
                                   (0242)    ;   preserve its value and restore it here.
                                   (0243) 
                                   (0244) 
                                   (0245)    ;---------------------------------------------------
                                   (0246)    ; Insert your custom code above this banner
                                   (0247)    ;---------------------------------------------------
                                   (0248)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0249) 
0448: 41 93 EF AND   REG[147],239  (0250)    and   reg[DUALADC_1_bfADC1cr3],~DUALADC_1_fFSW0         ; Take Integrator out of reset
044B: 41 9B EF AND   REG[155],239  (0251)    and   reg[DUALADC_1_bfADC2cr3],~DUALADC_1_fFSW0         ; Take Integrator out of reset
                                   (0252) IF DUALADC_1_NoAZ
044E: 41 92 DF AND   REG[146],223  (0253)    and   reg[DUALADC_1_bfADC1cr2],~DUALADC_1_fAutoZero     ; Take Integrator out of AutoZero
0451: 41 9A DF AND   REG[154],223  (0254)    and   reg[DUALADC_1_bfADC2cr2],~DUALADC_1_fAutoZero     ; Take Integrator out of AutoZero
                                   (0255) ENDIF
                                   (0256) 
                                   (0257) 
                                   (0258)    ;****************************************************************************
                                   (0259)    ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
                                   (0260)    ;                          ; if stack space isn't at a premium.
                                   (0261)    ; NOTE:  this will make system more responsive but, will increase the
                                   (0262)    ;        overall processing time of the A/D calctime.  If an interrupt is
                                   (0263)    ;        taken, it must return within the specified CalcTime to guarantee
                                   (0264)    ;        successful acquisition of the next byte.
                                   (0265)    ;****************************************************************************
                                   (0266) 
                                   (0267) ; ADC1
                                   (0268) IF (DUALADC_1_DATA_FORMAT)                       ; Only check for Negative numbers if SIGNED result
                                   (0269)                                                  ; Negative Overflow Check
                                   (0270)    tst   [(DUALADC_1_iResult1 + HighByte)],80h
                                   (0271)    jnz   DUALADC_1_NOT_2POVFL1
                                   (0272) 
                                   (0273) ENDIF
                                   (0274)                                                  ; Postive Overflow Check
                                   (0275)                                                  ; Get MSB of Max Positive value x4 + 1
0454: 51 09    MOV   A,[9]         (0276)    mov   A,[DUALADC_1_bfStatus]                  ; Get Status with Resolution
0456: 21 0F    AND   A,15          (0277)    and   A,DUALADC_1_bRES_MASK                   ; Mask of resolution normalized to 0
0458: FF 97    INDEX 0x03F1        (0278)    index DUALADC_1MaxPosX4Table                  ; Get Maximum positive value x4 + 1 from table
045A: 08       PUSH  A             (0279)    push  A
045B: 22 05    AND   A,[5]         (0280)    and   A, [(DUALADC_1_iResult1 + HighByte)]
045D: A0 0B    JZ    0x0469        (0281)    jz    DUALADC_1_NOT_POVFL1
                                   (0282)                                                  ; Positive overflow, fix it - set to Max Positive + 1
045F: 18       POP   A             (0283)    pop   A
0460: 11 01    SUB   A,1           (0284)    sub   A, 01h
                                   (0285)                                                  ; Force most positive * 4 into result
0462: 53 05    MOV   [5],A         (0286)    mov   [(DUALADC_1_iResult1 + HighByte)], A
0464: 55 06 FF MOV   [6],255       (0287)    mov   [(DUALADC_1_iResult1 + LowByte)], ffh
0467: 80 02    JMP   0x046A        (0288)    jmp   DUALADC_1_NOT_2POVFL1
                                   (0289) DUALADC_1_NOT_POVFL1:
0469: 18       POP   A             (0290)    pop   A
                                   (0291) 
                                   (0292) DUALADC_1_NOT_2POVFL1:
046A: 68 05    ASR   [5]           (0293)    asr   [(DUALADC_1_iResult1 + HighByte)]       ; Shift MSB and LSB right twice to divide by four
046C: 6E 06    RRC   [6]           (0294)    rrc   [(DUALADC_1_iResult1 + LowByte)]        ; Remember digital clock 4 times analog clock
046E: 68 05    ASR   [5]           (0295)    asr   [(DUALADC_1_iResult1 + HighByte)]
0470: 6E 06    RRC   [6]           (0296)    rrc   [(DUALADC_1_iResult1 + LowByte)]
                                   (0297) 
                                   (0298) ; ADC2
                                   (0299) IF (DUALADC_1_DATA_FORMAT)                       ; Only check for Negative numbers if SIGNED result
                                   (0300)                                                  ; Negative Overflow Check
                                   (0301)    tst   [(DUALADC_1_iResult2 + HighByte)],80h
                                   (0302)    jnz   DUALADC_1_NOT_2POVFL2
                                   (0303) 
                                   (0304) ENDIF
                                   (0305)                                                  ; Postive Overflow Check
                                   (0306)                                                  ; Get MSB of Max Positive value x4 + 1
0472: 51 09    MOV   A,[9]         (0307)    mov   A,[DUALADC_1_bfStatus]                  ; Get Status with Resolution
0474: 21 0F    AND   A,15          (0308)    and   A,DUALADC_1_bRES_MASK                   ; Mask of resolution normalized to 0
0476: FF 79    INDEX 0x03F1        (0309)    index DUALADC_1MaxPosX4Table                  ; Get Maximum positive value x4 + 1 from table
0478: 08       PUSH  A             (0310)    push  A
0479: 22 07    AND   A,[7]         (0311)    and   A, [(DUALADC_1_iResult2 + HighByte)]
047B: A0 0B    JZ    0x0487        (0312)    jz    DUALADC_1_NOT_POVFL2
                                   (0313)                                                  ; Positive overflow, fix it - set to Max Positive + 1
047D: 18       POP   A             (0314)    pop   A
047E: 11 01    SUB   A,1           (0315)    sub   A, 01h
                                   (0316)                                                  ; Force most positive * 4 into result
0480: 53 07    MOV   [7],A         (0317)    mov   [(DUALADC_1_iResult2 + HighByte)], A
0482: 55 08 FF MOV   [8],255       (0318)    mov   [(DUALADC_1_iResult2 + LowByte)], ffh
0485: 80 02    JMP   0x0488        (0319)    jmp   DUALADC_1_NOT_2POVFL2
                                   (0320) DUALADC_1_NOT_POVFL2:
0487: 18       POP   A             (0321)    pop   A
                                   (0322) 
                                   (0323) DUALADC_1_NOT_2POVFL2:
0488: 68 07    ASR   [7]           (0324)    asr   [(DUALADC_1_iResult2 + HighByte)]       ; Shift MSB and LSB right twice to divide by four
048A: 6E 08    RRC   [8]           (0325)    rrc   [(DUALADC_1_iResult2 + LowByte)]        ; Remember digital clock 4 times analog clock
048C: 68 07    ASR   [7]           (0326)    asr   [(DUALADC_1_iResult2 + HighByte)]
048E: 6E 08    RRC   [8]           (0327)    rrc   [(DUALADC_1_iResult2 + LowByte)]
                                   (0328) 
                                   (0329)    ;**********************************************
                                   (0330)    ; Data is ready at this point.
                                   (0331)    ; If processing Data at Interrupt level - add
                                   (0332)    ;     User Code to handle the data
                                   (0333)    ;**********************************************
                                   (0334)    ;@PSoC_UserCode_BODY_4@ (Do not change this line.)
                                   (0335)    ;---------------------------------------------------
                                   (0336)    ; Insert your custom code below this banner
                                   (0337)    ;---------------------------------------------------
                                   (0338)    ;   NOTE: interrupt service routines must preserve
                                   (0339)    ;   the values of the A and X CPU registers. At this
                                   (0340)    ;   point A has been preserved on the stack and wil
                                   (0341)    ;   be restored later. However, if you use X, be
                                   (0342)    ;   sure to take care of it yourself!
                                   (0343) 
                                   (0344) 
                                   (0345)    ;---------------------------------------------------
                                   (0346)    ; Insert your custom code above this banner
                                   (0347)    ;---------------------------------------------------
                                   (0348)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0349) 
0490: 18       POP   A             (0350)    pop   A                                       ; Restore A, not used any more
                                   (0351) 
0491: 2E 09 10 OR    [9],16        (0352)    or    [DUALADC_1_bfStatus],DUALADC_1_fDATA_READY  ; Set Data ready bit
                                   (0353) 
0494: 47 0A FF TST   [10],255      (0354)    tst   [DUALADC_1_bSampC], ffh                 ; If sample_counter == 0 -->> continuous data collection
0497: A0 23    JZ    0x04BB        (0355)    jz    DUALADC_1_END_PWM16_ISR
                                   (0356) 
0499: 7A 0A    DEC   [10]          (0357)    dec   [DUALADC_1_bSampC]                      ; Dec sample counter and check for zero
049B: B0 1F    JNZ   0x04BB        (0358)    jnz   DUALADC_1_END_PWM16_ISR
                                   (0359) 
049D: 41 47 FE AND   REG[71],254   (0360)    and   reg[DUALADC_1_fPWM_LSB_CR0], ~DUALADC_1_fDBLK_ENABLE     ; Disable the PWM
                                   (0361) 
04A0: 41 43 FE AND   REG[67],254   (0362)    and   reg[DUALADC_1_bCounter1_CR0], ~DUALADC_1_fDBLK_ENABLE           ; Disable the Counter
04A3: 41 4F FE AND   REG[79],254   (0363)    and   reg[DUALADC_1_bCounter2_CR0], ~DUALADC_1_fDBLK_ENABLE           ; Disable the Counter
                                   (0364) 
                                   (0365) IF DUALADC_1_NoAZ
04A6: 43 92 20 OR    REG[146],32   (0366)    or    reg[DUALADC_1_bfADC1cr2], DUALADC_1_fAutoZero         ; Put the Integrator into Autozero mode
04A9: 43 9A 20 OR    REG[154],32   (0367)    or    reg[DUALADC_1_bfADC2cr2], DUALADC_1_fAutoZero         ; Put the Integrator into Autozero mode
                                   (0368) ENDIF
                                   (0369) 
04AC: 43 93 10 OR    REG[147],16   (0370)    or    reg[DUALADC_1_bfADC1cr3], DUALADC_1_fFSW0             ; Put Integrator into reset
04AF: 43 9B 10 OR    REG[155],16   (0371)    or    reg[DUALADC_1_bfADC2cr3], DUALADC_1_fFSW0             ; Put Integrator into reset
                                   (0372) 
04B2: 41 DF FB AND   REG[223],251  (0373)    and   reg[DUALADC_1_bfPWM16_INT_REG], ~DUALADC_1_bfPWM16_Mask      ; Disable interrupts
04B5: 41 DF FE AND   REG[223],254  (0374)    and   reg[DUALADC_1_bfCounter1_INT_REG], ~DUALADC_1_bfCounter1_Mask
04B8: 41 DF F7 AND   REG[223],247  (0375)    and   reg[DUALADC_1_bfCounter2_INT_REG], ~DUALADC_1_bfCounter2_Mask
                                   (0376) 
                                   (0377) DUALADC_1_END_PWM16_ISR:
04BB: 7E       RETI                (0378)    reti

FILE: .\main.asm
                                   (0001) ;-----------------------------------------------------------------------------
                                   (0002) ; Assembly main line
                                   (0003) ;-----------------------------------------------------------------------------
                                   (0004) 
                                   (0005) include "m8c.inc"       ; part specific constants and macros
                                   (0006) include "memory.inc"    ; Constants & macros for SMM/LMM and Compiler
                                   (0007) include "PSoCAPI.inc"   ; PSoC API definitions for all User Modules
                                   (0008) 
                                   (0009) export _main
                                   (0010) 
                                   (0011) _main:
                                   (0012) 
                                   (0013)     ; Insert your main assembly code here.
                                   (0014) 
                                   (0015) .terminate:
                                   (0016)     jmp .terminate

FILE: <library>
_main:
__text_start:
04BC: 8F FF    JMP   _main
