 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _my_table::
 0000 00                .byte 0
 0001 0000              .byte 0,0
 0003 00000000000000000000      .word 0,0,0,0,0
 000D 00000000000000000000      .word 0,0,0,0,0
 0017 00000000000000000000      .word 0,0,0,0,0
 0021 00000000000000000000      .word 0,0,0,0,0
 002B 00000000000000000000      .word 0,0,0,0,0
 0035 00000000000000    .byte 0,0,0,0,0,0,0
 003C                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 003C                   .dbstruct 0 3 vocabTable
 003C                   .dbfield 0 word c
 003C                   .dbfield 1 frequency c
 003C                   .dbfield 2 age c
 003C                   .dbend
 003C                   .dbsym e my_table _my_table A[60:20]S[vocabTable]
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _neighours_table::
 0000 00                .byte 0
 0001 0000              .byte 0,0
 0003 00000000000000000000      .word 0,0,0,0,0
 000D 00000000000000000000      .word 0,0,0,0,0
 0017 00000000000000000000      .word 0,0,0,0,0
 0021 00000000000000000000      .word 0,0,0,0,0
 002B 00000000000000000000      .word 0,0,0,0,0
 0035 00000000000000    .byte 0,0,0,0,0,0,0
 003C                   .dbsym e neighours_table _neighours_table A[60:20]S[vocabTable]
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _sortVocabTables::
 0000 00                .byte 0
 0001                   .dbsym e sortVocabTables _sortVocabTables c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000                   .dbfunc e TimerISR _TimerISR fV
 0000           _TimerISR::
 0000                   .dbline -1
 0000 71C0              or F,-64
 0002 08                push A
 0003 5DD0              mov A,REG[0xd0]
 0005 08                push A
 0006                   .dbline 46
 0006           ; //----------------------------------------------------------------------------
 0006           ; // C main line
 0006           ; //----------------------------------------------------------------------------
 0006           ; 
 0006           ; #include <m8c.h>        // part specific constants and macros
 0006           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0006           ; #include <stdio.h>
 0006           ; #define TEMP_SENSOR_SLAVE_ADDRESS 0x18
 0006           ; #define TEMP_REG                        0x05
 0006           ; #define MIC_ADC_CHANNEL                         0x01
 0006           ; #define LIGHT_SENSOR_ADC_CHANNEL  0x02
 0006           ; #define SIZE                                    20
 0006           ; #define X                                               3400 // 3.4s
 0006           ; #define Z                                               200  // 200ms
 0006           ; #define Y                         200  // 200ms
 0006           ; #define Q                         200  // Have find an optimum value
 0006           ; 
 0006           ; enum light  {DARK, NORMAL , BRIGHT};
 0006           ; enum temp   {COLD, MEDIUM, HOT};
 0006           ; 
 0006           ; typedef struct vocabTable
 0006           ; {
 0006           ;       BYTE word;
 0006           ;       BYTE frequency;
 0006           ;       BYTE age;
 0006           ; }vocabTable_type;
 0006           ; 
 0006           ; vocabTable_type my_table[SIZE]= {0};          // To do: finalize on the size
 0006           ; vocabTable_type neighours_table[SIZE] = {0};// To do: finalize on the size
 0006           ; 
 0006           ; BOOL sortVocabTables = FALSE;
 0006           ; void print_LCD_debug_msg(char* msg,INT row,INT col);
 0006           ; INT readDualAdc(INT channel);
 0006           ; INT read_temperature(void);
 0006           ; float getLux(void) ;
 0006           ; BYTE create_word(float lux, INT temp);
 0006           ; void blocking_delay(BYTE bTimes);
 0006           ; void update_table(BYTE word_encoding, vocabTable_type* table );
 0006           ; void quickSort(vocabTable_type A[], int l, int h);
 0006           ; int part(vocabTable_type arr[], int l, int h);
 0006           ; void swap(vocabTable_type* a, vocabTable_type* b);
 0006           ; 
 0006           ; #pragma interrupt_handler TimerISR
 0006           ; #pragma interrupt_handler ResetSwitchISR
 0006           ; void TimerISR(void )
 0006           ; {
 0006                   .dbline 47
 0006           ;       sortVocabTables = TRUE;
 0006 62D000            mov REG[0xd0],>_sortVocabTables
 0009 550001            mov [_sortVocabTables],1
 000C                   .dbline -2
 000C           L1:
 000C 18                pop A
 000D 60D0              mov REG[208],A
 000F 18                pop A
 0010                   .dbline 0 ; func end
 0010 7E                reti
 0011                   .dbend
 0011                   .dbfunc e ResetSwitchISR _ResetSwitchISR fV
 0011           _ResetSwitchISR::
 0011                   .dbline -1
 0011 08                push A
 0012                   .dbline 51
 0012           ; }
 0012           ; 
 0012           ; void ResetSwitchISR(void )
 0012           ; {
 0012                   .dbline 52
 0012           ;       INT_MSK3 = INT_MSK3 | 0x80;
 0012 43DE80            or REG[0xde],-128
 0015                   .dbline -2
 0015           L2:
 0015 18                pop A
 0016                   .dbline 0 ; func end
 0016 7E                reti
 0017                   .dbend
 0017                   .dbfunc e main _main fV
 0017           ;           word -> X+6
 0017           ;      tempValue -> X+4
 0017           ;       luxValue -> X+0
 0017           _main::
 0017                   .dbline -1
 0017 10                push X
 0018 4F                mov X,SP
 0019 3807              add SP,7
 001B                   .dbline 57
 001B           ;       // Trigger the hardware reset ISR from the software     
 001B           ; }
 001B           ; 
 001B           ; void main(void)
 001B           ; {
 001B                   .dbline 63
 001B           ;       float luxValue; // Ambient Light illumiance value
 001B           ;       INT   tempValue;     // Ambient temperature
 001B           ;       BYTE  word;
 001B           ;       
 001B           ;       // PGA1 init
 001B           ;       PGA_1_Start(PGA_1_HIGHPOWER);
 001B 10                push X
 001C 5003              mov A,3
 001E 7C0000            xcall _PGA_1_Start
 0021                   .dbline 65
 0021           ;       // PGA2 init
 0021           ;       PGA_2_Start(PGA_1_HIGHPOWER);
 0021 5003              mov A,3
 0023 7C0000            xcall _PGA_2_Start
 0026                   .dbline 68
 0026           ; 
 0026           ;       // Initial the Dual ADC
 0026           ;       DUALADC_1_Start(DUALADC_1_HIGHPOWER);           // Turn on Analog section
 0026 5003              mov A,3
 0028 7C0000            xcall _DUALADC_1_Start
 002B                   .dbline 69
 002B           ;       DUALADC_1_SetResolution(10);                    // Set resolution to 10 Bits
 002B 500A              mov A,10
 002D 7C0000            xcall _DUALADC_1_SetResolution
 0030                   .dbline 70
 0030           ;       DUALADC_1_GetSamples(0); 
 0030 5000              mov A,0
 0032 7C0000            xcall _DUALADC_1_GetSamples
 0035                   .dbline 73
 0035           ; 
 0035           ;       // Initializes LCD to use the multi-line 4-bit interface
 0035           ;       LCD_2_Start();
 0035 7C0000            xcall _LCD_2_Start
 0038                   .dbline 76
 0038           ;       
 0038           ;       // Enables the I2C HW block as a Master 
 0038           ;       I2CHW_Temp_EnableMstr();
 0038 7C0000            xcall _I2CHW_Temp_EnableMstr
 003B                   .dbline 82
 003B           ;       
 003B           ;       //Enable reset button interrupt
 003B           ;       //To do How to trigger a software reset via button?
 003B           ;       
 003B           ;       // Initialize time
 003B           ;       Timer16_1_WritePeriod(0xffff);// Do this in the config
 003B 50FF              mov A,-1
 003D 57FF              mov X,-1
 003F 7C0000            xcall _Timer16_1_WritePeriod
 0042                   .dbline 83
 0042           ;       Timer16_1_WriteCompareValue(0x0001); 
 0042 5700              mov X,0
 0044 5001              mov A,1
 0046 7C0000            xcall _Timer16_1_WriteCompareValue
 0049                   .dbline 84
 0049           ;       Timer16_1_EnableInt();//Enable Timer interrupt
 0049 7C0000            xcall _Timer16_1_EnableInt
 004C 20                pop X
 004D                   .dbline 88
 004D           ;       
 004D           ;       
 004D           ;       // Enable global interrupts
 004D           ;       M8C_EnableGInt;
 004D 7101                      or  F, 01h
 004F           
 004F                   .dbline 91
 004F           ;       
 004F           ;       // Start the timer
 004F           ;       Timer16_1_Start(); 
 004F 10                push X
 0050 7C0000            xcall _Timer16_1_Start
 0053 20                pop X
 0054 8065              xjmp L5
 0056           L4:
 0056                   .dbline 93
 0056           ;       while(1)
 0056           ;       {
 0056                   .dbline 98
 0056           ;               
 0056           ;               // Sense /////////////////////////////
 0056           ;               
 0056           ;               //Read light sensor value
 0056           ;               luxValue   = getLux(); // luxValue ranges from 0 to 1000
 0056 96F7              xcall _getLux
 0058 62D000            mov REG[0xd0],>__r0
 005B 5100              mov A,[__r0]
 005D 5400              mov [X+0],A
 005F 5100              mov A,[__r1]
 0061 5401              mov [X+1],A
 0063 5100              mov A,[__r2]
 0065 5402              mov [X+2],A
 0067 5100              mov A,[__r3]
 0069 5403              mov [X+3],A
 006B                   .dbline 100
 006B           ;               //Read temperature value
 006B           ;               tempValue  = read_temperature();\
 006B 95E3              xcall _read_temperature
 006D 62D000            mov REG[0xd0],>__r0
 0070 5100              mov A,[__r1]
 0072 5405              mov [X+5],A
 0074 5100              mov A,[__r0]
 0076 5404              mov [X+4],A
 0078                   .dbline 103
 0078           ;       
 0078           ;               // Word formation //////////////////
 0078           ;               word = create_word(luxValue, tempValue);
 0078 5204              mov A,[X+4]
 007A 08                push A
 007B 5205              mov A,[X+5]
 007D 08                push A
 007E 5200              mov A,[X+0]
 0080 08                push A
 0081 5201              mov A,[X+1]
 0083 08                push A
 0084 5202              mov A,[X+2]
 0086 08                push A
 0087 5203              mov A,[X+3]
 0089 08                push A
 008A 9035              xcall _create_word
 008C 62D000            mov REG[0xd0],>__r0
 008F 5406              mov [X+6],A
 0091                   .dbline 106
 0091           ;               
 0091           ;               // Update my vocab
 0091           ;               update_table(word,my_table);
 0091 5000              mov A,>_my_table
 0093 08                push A
 0094 5000              mov A,<_my_table
 0096 08                push A
 0097 5206              mov A,[X+6]
 0099 08                push A
 009A 91D0              xcall _update_table
 009C 38F7              add SP,-9
 009E                   .dbline 110
 009E           ;               
 009E           ;               // Sort vocab table
 009E           ;               
 009E           ;               if (sortVocabTables == TRUE)
 009E 62D000            mov REG[0xd0],>_sortVocabTables
 00A1 3C0001            cmp [_sortVocabTables],1
 00A4 B015              jnz L7
 00A6                   .dbline 112
 00A6           ;               {
 00A6           ;                       quickSort(my_table, 0 , SIZE-1);
 00A6                   .dbline 112
 00A6 5000              mov A,0
 00A8 08                push A
 00A9 5013              mov A,19
 00AB 08                push A
 00AC 5000              mov A,0
 00AE 08                push A
 00AF 08                push A
 00B0 5000              mov A,>_my_table
 00B2 08                push A
 00B3 5000              mov A,<_my_table
 00B5 08                push A
 00B6 94EC              xcall _quickSort
 00B8 38FA              add SP,-6
 00BA                   .dbline 113
 00BA           ;               }
 00BA           L7:
 00BA                   .dbline 117
 00BA           ;               // Speak ///////////////////////////
 00BA           ;               
 00BA           ;               // Listen? /////////////////////////
 00BA           ;       }
 00BA           L5:
 00BA                   .dbline 92
 00BA 8F9B              xjmp L4
 00BC           X0:
 00BC                   .dbline -2
 00BC           L3:
 00BC 38F9              add SP,-7
 00BE 20                pop X
 00BF                   .dbline 0 ; func end
 00BF 8FFF              jmp .
 00C1                   .dbsym l word 6 c
 00C1                   .dbsym l tempValue 4 I
 00C1                   .dbsym l luxValue 0 D
 00C1                   .dbend
 00C1                   .dbfunc e create_word _create_word fc
 00C1           ;           word -> X+2
 00C1           ;     temp_label -> X+1
 00C1           ;    light_label -> X+0
 00C1           ;           temp -> X-9
 00C1           ;            lux -> X-7
 00C1           _create_word::
 00C1                   .dbline -1
 00C1 10                push X
 00C2 4F                mov X,SP
 00C3 3803              add SP,3
 00C5                   .dbline 121
 00C5           ; }
 00C5           ; 
 00C5           ; BYTE create_word(float lux, INT temp)
 00C5           ; {
 00C5                   .dbline 125
 00C5           ;       enum light light_label;
 00C5           ;       enum temp temp_label;
 00C5           ;       BYTE word;
 00C5           ;       if (lux >= 0 && lux < 333)
 00C5 5000              mov A,0
 00C7 08                push A
 00C8 08                push A
 00C9 08                push A
 00CA 08                push A
 00CB 52F9              mov A,[X-7]
 00CD 08                push A
 00CE 52FA              mov A,[X-6]
 00D0 08                push A
 00D1 52FB              mov A,[X-5]
 00D3 08                push A
 00D4 52FC              mov A,[X-4]
 00D6 08                push A
 00D7 62D000            mov REG[0xd0],>__r0
 00DA 7C0000            xcall __fpcmp
 00DD 38F8              add SP,-8
 00DF 39FF              cmp A,-1
 00E1 A02B              jz L10
 00E3 5043              mov A,67
 00E5 08                push A
 00E6 50A6              mov A,-90
 00E8 08                push A
 00E9 5080              mov A,-128
 00EB 08                push A
 00EC 5000              mov A,0
 00EE 08                push A
 00EF 52F9              mov A,[X-7]
 00F1 08                push A
 00F2 52FA              mov A,[X-6]
 00F4 08                push A
 00F5 52FB              mov A,[X-5]
 00F7 08                push A
 00F8 52FC              mov A,[X-4]
 00FA 08                push A
 00FB 7C0000            xcall __fpcmp
 00FE 38F8              add SP,-8
 0100 3900              cmp A,0
 0102 A00A              jz L10
 0104 3901              cmp A,1
 0106 A006              jz L10
 0108                   .dbline 126
 0108           ;               light_label = DARK;
 0108 560000            mov [X+0],0
 010B 8095              xjmp L11
 010D           L10:
 010D                   .dbline 127
 010D           ;       else if(lux >= 333 && lux < 666)
 010D 5043              mov A,67
 010F 08                push A
 0110 50A6              mov A,-90
 0112 08                push A
 0113 5080              mov A,-128
 0115 08                push A
 0116 5000              mov A,0
 0118 08                push A
 0119 52F9              mov A,[X-7]
 011B 08                push A
 011C 52FA              mov A,[X-6]
 011E 08                push A
 011F 52FB              mov A,[X-5]
 0121 08                push A
 0122 52FC              mov A,[X-4]
 0124 08                push A
 0125 62D000            mov REG[0xd0],>__r0
 0128 7C0000            xcall __fpcmp
 012B 38F8              add SP,-8
 012D 39FF              cmp A,-1
 012F A02B              jz L12
 0131 5044              mov A,68
 0133 08                push A
 0134 5026              mov A,38
 0136 08                push A
 0137 5080              mov A,-128
 0139 08                push A
 013A 5000              mov A,0
 013C 08                push A
 013D 52F9              mov A,[X-7]
 013F 08                push A
 0140 52FA              mov A,[X-6]
 0142 08                push A
 0143 52FB              mov A,[X-5]
 0145 08                push A
 0146 52FC              mov A,[X-4]
 0148 08                push A
 0149 7C0000            xcall __fpcmp
 014C 38F8              add SP,-8
 014E 3900              cmp A,0
 0150 A00A              jz L12
 0152 3901              cmp A,1
 0154 A006              jz L12
 0156                   .dbline 128
 0156           ;               light_label = NORMAL;
 0156 560001            mov [X+0],1
 0159 8047              xjmp L13
 015B           L12:
 015B                   .dbline 129
 015B           ;       else if(lux >=666 && lux <=1000)
 015B 5044              mov A,68
 015D 08                push A
 015E 5026              mov A,38
 0160 08                push A
 0161 5080              mov A,-128
 0163 08                push A
 0164 5000              mov A,0
 0166 08                push A
 0167 52F9              mov A,[X-7]
 0169 08                push A
 016A 52FA              mov A,[X-6]
 016C 08                push A
 016D 52FB              mov A,[X-5]
 016F 08                push A
 0170 52FC              mov A,[X-4]
 0172 08                push A
 0173 62D000            mov REG[0xd0],>__r0
 0176 7C0000            xcall __fpcmp
 0179 38F8              add SP,-8
 017B 39FF              cmp A,-1
 017D A023              jz L14
 017F 5044              mov A,68
 0181 08                push A
 0182 507A              mov A,122
 0184 08                push A
 0185 5000              mov A,0
 0187 08                push A
 0188 08                push A
 0189 52F9              mov A,[X-7]
 018B 08                push A
 018C 52FA              mov A,[X-6]
 018E 08                push A
 018F 52FB              mov A,[X-5]
 0191 08                push A
 0192 52FC              mov A,[X-4]
 0194 08                push A
 0195 7C0000            xcall __fpcmp
 0198 38F8              add SP,-8
 019A 3901              cmp A,1
 019C A004              jz L14
 019E                   .dbline 130
 019E           ;               light_label = BRIGHT;
 019E 560002            mov [X+0],2
 01A1           L14:
 01A1           L13:
 01A1           L11:
 01A1                   .dbline 133
 01A1           ;       
 01A1           ;       // Check this
 01A1           ;       if (temp < 10)
 01A1 52F8              mov A,[X-8]
 01A3 110A              sub A,10
 01A5 52F7              mov A,[X-9]
 01A7 3180              xor A,-128
 01A9 1980              sbb A,(0 ^ 0x80)
 01AB D006              jnc L16
 01AD           X7:
 01AD                   .dbline 134
 01AD           ;               temp_label = COLD;
 01AD 560100            mov [X+1],0
 01B0 802D              xjmp L17
 01B2           L16:
 01B2                   .dbline 135
 01B2           ;       else if(temp >=10 && temp < 23)
 01B2 52F8              mov A,[X-8]
 01B4 110A              sub A,10
 01B6 52F7              mov A,[X-9]
 01B8 3180              xor A,-128
 01BA 1980              sbb A,(0 ^ 0x80)
 01BC C012              jc L18
 01BE           X8:
 01BE 52F8              mov A,[X-8]
 01C0 1117              sub A,23
 01C2 52F7              mov A,[X-9]
 01C4 3180              xor A,-128
 01C6 1980              sbb A,(0 ^ 0x80)
 01C8 D006              jnc L18
 01CA           X9:
 01CA                   .dbline 136
 01CA           ;               temp_label = MEDIUM;
 01CA 560101            mov [X+1],1
 01CD 8010              xjmp L19
 01CF           L18:
 01CF                   .dbline 137
 01CF           ;       else if(temp >= 23)
 01CF 52F8              mov A,[X-8]
 01D1 1117              sub A,23
 01D3 52F7              mov A,[X-9]
 01D5 3180              xor A,-128
 01D7 1980              sbb A,(0 ^ 0x80)
 01D9 C004              jc L20
 01DB           X10:
 01DB                   .dbline 138
 01DB           ;               temp_label = HOT;
 01DB 560102            mov [X+1],2
 01DE           L20:
 01DE           L19:
 01DE           L17:
 01DE                   .dbline 140
 01DE           ;       
 01DE           ;       if (light_label == DARK && temp_label == COLD)
 01DE 3D0000            cmp [X+0],0
 01E1 B00B              jnz L22
 01E3 3D0100            cmp [X+1],0
 01E6 B006              jnz L22
 01E8                   .dbline 141
 01E8           ;               word = 1; //Dark light and Cold condition
 01E8 560201            mov [X+2],1
 01EB 8077              xjmp L23
 01ED           L22:
 01ED                   .dbline 142
 01ED           ;       else if (light_label == DARK && temp_label == MEDIUM)
 01ED 3D0000            cmp [X+0],0
 01F0 B00B              jnz L24
 01F2 3D0101            cmp [X+1],1
 01F5 B006              jnz L24
 01F7                   .dbline 143
 01F7           ;               word = 2; //Dark light and Medium temp condition
 01F7 560202            mov [X+2],2
 01FA 8068              xjmp L25
 01FC           L24:
 01FC                   .dbline 144
 01FC           ;       else if (light_label == DARK && temp_label == HOT)
 01FC 3D0000            cmp [X+0],0
 01FF B00B              jnz L26
 0201 3D0102            cmp [X+1],2
 0204 B006              jnz L26
 0206                   .dbline 145
 0206           ;               word = 3; //Dark light and Hot temp condition
 0206 560203            mov [X+2],3
 0209 8059              xjmp L27
 020B           L26:
 020B                   .dbline 146
 020B           ;       else if (light_label == NORMAL && temp_label == COLD)
 020B 3D0001            cmp [X+0],1
 020E B00B              jnz L28
 0210 3D0100            cmp [X+1],0
 0213 B006              jnz L28
 0215                   .dbline 147
 0215           ;               word = 4; //Normal light and cold temp condition
 0215 560204            mov [X+2],4
 0218 804A              xjmp L29
 021A           L28:
 021A                   .dbline 148
 021A           ;       else if (light_label == NORMAL && temp_label == MEDIUM)
 021A 3D0001            cmp [X+0],1
 021D B00B              jnz L30
 021F 3D0101            cmp [X+1],1
 0222 B006              jnz L30
 0224                   .dbline 149
 0224           ;               word = 5; //Normal light and medium temp condition
 0224 560205            mov [X+2],5
 0227 803B              xjmp L31
 0229           L30:
 0229                   .dbline 150
 0229           ;       else if (light_label == NORMAL && temp_label == HOT)
 0229 3D0001            cmp [X+0],1
 022C B00B              jnz L32
 022E 3D0102            cmp [X+1],2
 0231 B006              jnz L32
 0233                   .dbline 151
 0233           ;               word = 6; //Normal light and hot temp condition
 0233 560206            mov [X+2],6
 0236 802C              xjmp L33
 0238           L32:
 0238                   .dbline 152
 0238           ;       else if (light_label == BRIGHT && temp_label == COLD)
 0238 3D0002            cmp [X+0],2
 023B B00B              jnz L34
 023D 3D0100            cmp [X+1],0
 0240 B006              jnz L34
 0242                   .dbline 153
 0242           ;               word = 7; //Bright light and cold temp condition
 0242 560207            mov [X+2],7
 0245 801D              xjmp L35
 0247           L34:
 0247                   .dbline 154
 0247           ;       else if (light_label == BRIGHT && temp_label == MEDIUM)
 0247 3D0002            cmp [X+0],2
 024A B00B              jnz L36
 024C 3D0101            cmp [X+1],1
 024F B006              jnz L36
 0251                   .dbline 155
 0251           ;               word = 8; //Bright light and medium temp condition
 0251 560208            mov [X+2],8
 0254 800E              xjmp L37
 0256           L36:
 0256                   .dbline 156
 0256           ;       else if (light_label == BRIGHT && temp_label == HOT)
 0256 3D0002            cmp [X+0],2
 0259 B009              jnz L38
 025B 3D0102            cmp [X+1],2
 025E B004              jnz L38
 0260                   .dbline 157
 0260           ;               word = 9; //Bright light and hot temp condition
 0260 560209            mov [X+2],9
 0263           L38:
 0263           L37:
 0263           L35:
 0263           L33:
 0263           L31:
 0263           L29:
 0263           L27:
 0263           L25:
 0263           L23:
 0263                   .dbline 159
 0263           ;       
 0263           ;       return word;// return word encoding
 0263 5202              mov A,[X+2]
 0265 62D000            mov REG[0xd0],>__r0
 0268                   .dbline -2
 0268           L9:
 0268 38FD              add SP,-3
 026A 20                pop X
 026B                   .dbline 0 ; func end
 026B 7F                ret
 026C                   .dbsym l word 2 c
 026C                   .dbsym l temp_label 1 c
 026C                   .dbsym l light_label 0 c
 026C                   .dbsym l temp -9 I
 026C                   .dbsym l lux -7 D
 026C                   .dbend
 026C                   .dbfunc e update_table _update_table fV
 026C           ;          found -> X+2
 026C           ;              i -> X+0
 026C           ;          table -> X-6
 026C           ;  word_encoding -> X-4
 026C           _update_table::
 026C                   .dbline -1
 026C 10                push X
 026D 4F                mov X,SP
 026E 3803              add SP,3
 0270                   .dbline 164
 0270           ; }
 0270           ; 
 0270           ; 
 0270           ; void update_table(BYTE word_encoding, vocabTable_type* table )
 0270           ; {
 0270                   .dbline 166
 0270           ;       int i;
 0270           ;       BOOL found = FALSE;
 0270 560200            mov [X+2],0
 0273                   .dbline 167
 0273           ;       for (i= 0; i< SIZE; i++)
 0273 560100            mov [X+1],0
 0276 560000            mov [X+0],0
 0279           L41:
 0279                   .dbline 168
 0279           ;       {
 0279                   .dbline 169
 0279           ;               table[i].age++;
 0279 62D000            mov REG[0xd0],>__r0
 027C 5200              mov A,[X+0]
 027E 08                push A
 027F 5201              mov A,[X+1]
 0281 08                push A
 0282 5000              mov A,0
 0284 08                push A
 0285 5003              mov A,3
 0287 08                push A
 0288 7C0000            xcall __mul16
 028B 38FC              add SP,-4
 028D 5100              mov A,[__rX]
 028F 5300              mov [__r1],A
 0291 5100              mov A,[__rY]
 0293 5300              mov [__r0],A
 0295 52FB              mov A,[X-5]
 0297 0400              add [__r1],A
 0299 52FA              mov A,[X-6]
 029B 0C00              adc [__r0],A
 029D 060002            add [__r1],2
 02A0 0E0000            adc [__r0],0
 02A3 5100              mov A,[__r0]
 02A5 60D4              mov REG[0xd4],A
 02A7 3E00              mvi A,[__r1]
 02A9 7A00              dec [__r1]
 02AB 5300              mov [__r2],A
 02AD 060001            add [__r2],1
 02B0 5100              mov A,[__r0]
 02B2 60D5              mov REG[0xd5],A
 02B4 5100              mov A,[__r2]
 02B6 3F00              mvi [__r1],A
 02B8                   .dbline 170
 02B8           ;               if (table[i].word == word_encoding)
 02B8 5200              mov A,[X+0]
 02BA 08                push A
 02BB 5201              mov A,[X+1]
 02BD 08                push A
 02BE 5000              mov A,0
 02C0 08                push A
 02C1 5003              mov A,3
 02C3 08                push A
 02C4 7C0000            xcall __mul16
 02C7 38FC              add SP,-4
 02C9 5100              mov A,[__rX]
 02CB 5300              mov [__r1],A
 02CD 5100              mov A,[__rY]
 02CF 5300              mov [__r0],A
 02D1 52FB              mov A,[X-5]
 02D3 0400              add [__r1],A
 02D5 52FA              mov A,[X-6]
 02D7 0C00              adc [__r0],A
 02D9 5100              mov A,[__r0]
 02DB 60D4              mov REG[0xd4],A
 02DD 3E00              mvi A,[__r1]
 02DF 3BFC              cmp A,[X-4]
 02E1 B040              jnz L45
 02E3                   .dbline 172
 02E3           ;               {
 02E3           ;                       found =TRUE;
 02E3                   .dbline 172
 02E3 560201            mov [X+2],1
 02E6                   .dbline 173
 02E6           ;                       table[i].frequency++;
 02E6 5200              mov A,[X+0]
 02E8 08                push A
 02E9 5201              mov A,[X+1]
 02EB 08                push A
 02EC 5000              mov A,0
 02EE 08                push A
 02EF 5003              mov A,3
 02F1 08                push A
 02F2 7C0000            xcall __mul16
 02F5 38FC              add SP,-4
 02F7 5100              mov A,[__rX]
 02F9 5300              mov [__r1],A
 02FB 5100              mov A,[__rY]
 02FD 5300              mov [__r0],A
 02FF 52FB              mov A,[X-5]
 0301 0400              add [__r1],A
 0303 52FA              mov A,[X-6]
 0305 0C00              adc [__r0],A
 0307 060001            add [__r1],1
 030A 0E0000            adc [__r0],0
 030D 5100              mov A,[__r0]
 030F 60D4              mov REG[0xd4],A
 0311 3E00              mvi A,[__r1]
 0313 7A00              dec [__r1]
 0315 5300              mov [__r2],A
 0317 060001            add [__r2],1
 031A 5100              mov A,[__r0]
 031C 60D5              mov REG[0xd5],A
 031E 5100              mov A,[__r2]
 0320 3F00              mvi [__r1],A
 0322                   .dbline 174
 0322           ;               }
 0322           L45:
 0322                   .dbline 175
 0322           ;       }
 0322           L42:
 0322                   .dbline 167
 0322 7701              inc [X+1]
 0324 0F0000            adc [X+0],0
 0327                   .dbline 167
 0327 5201              mov A,[X+1]
 0329 1114              sub A,20
 032B 5200              mov A,[X+0]
 032D 3180              xor A,-128
 032F 1980              sbb A,(0 ^ 0x80)
 0331 CF47              jc L41
 0333           X11:
 0333                   .dbline 176
 0333           ;       if (found == FALSE)
 0333 3D0200            cmp [X+2],0
 0336 B08B              jnz L47
 0338                   .dbline 178
 0338           ;       {       
 0338           ;               table[i].word = word_encoding;
 0338                   .dbline 178
 0338 62D000            mov REG[0xd0],>__r0
 033B 5200              mov A,[X+0]
 033D 08                push A
 033E 5201              mov A,[X+1]
 0340 08                push A
 0341 5000              mov A,0
 0343 08                push A
 0344 5003              mov A,3
 0346 08                push A
 0347 7C0000            xcall __mul16
 034A 38FC              add SP,-4
 034C 5100              mov A,[__rX]
 034E 5300              mov [__r1],A
 0350 5100              mov A,[__rY]
 0352 5300              mov [__r0],A
 0354 52FB              mov A,[X-5]
 0356 0400              add [__r1],A
 0358 52FA              mov A,[X-6]
 035A 0C00              adc [__r0],A
 035C 5100              mov A,[__r0]
 035E 60D5              mov REG[0xd5],A
 0360 52FC              mov A,[X-4]
 0362 3F00              mvi [__r1],A
 0364                   .dbline 179
 0364           ;               table[i].frequency = 1;
 0364 5200              mov A,[X+0]
 0366 08                push A
 0367 5201              mov A,[X+1]
 0369 08                push A
 036A 5000              mov A,0
 036C 08                push A
 036D 5003              mov A,3
 036F 08                push A
 0370 7C0000            xcall __mul16
 0373 38FC              add SP,-4
 0375 5100              mov A,[__rX]
 0377 5300              mov [__r1],A
 0379 5100              mov A,[__rY]
 037B 5300              mov [__r0],A
 037D 52FB              mov A,[X-5]
 037F 0400              add [__r1],A
 0381 52FA              mov A,[X-6]
 0383 0C00              adc [__r0],A
 0385 060001            add [__r1],1
 0388 0E0000            adc [__r0],0
 038B 5100              mov A,[__r0]
 038D 60D5              mov REG[0xd5],A
 038F 5001              mov A,1
 0391 3F00              mvi [__r1],A
 0393                   .dbline 180
 0393           ;               table[i].age = 1;
 0393 5200              mov A,[X+0]
 0395 08                push A
 0396 5201              mov A,[X+1]
 0398 08                push A
 0399 5000              mov A,0
 039B 08                push A
 039C 5003              mov A,3
 039E 08                push A
 039F 7C0000            xcall __mul16
 03A2 38FC              add SP,-4
 03A4 5100              mov A,[__rX]
 03A6 5300              mov [__r1],A
 03A8 5100              mov A,[__rY]
 03AA 5300              mov [__r0],A
 03AC 52FB              mov A,[X-5]
 03AE 0400              add [__r1],A
 03B0 52FA              mov A,[X-6]
 03B2 0C00              adc [__r0],A
 03B4 060002            add [__r1],2
 03B7 0E0000            adc [__r0],0
 03BA 5100              mov A,[__r0]
 03BC 60D5              mov REG[0xd5],A
 03BE 5001              mov A,1
 03C0 3F00              mvi [__r1],A
 03C2                   .dbline 181
 03C2           ;       }
 03C2           L47:
 03C2                   .dbline -2
 03C2           L40:
 03C2 38FD              add SP,-3
 03C4 20                pop X
 03C5                   .dbline 0 ; func end
 03C5 7F                ret
 03C6                   .dbsym l found 2 c
 03C6                   .dbsym l i 0 I
 03C6                   .dbsym l table -6 pS[vocabTable]
 03C6                   .dbsym l word_encoding -4 c
 03C6                   .dbend
 03C6                   .dbfunc e swap _swap fV
 03C6           ;           temp -> X+0
 03C6           ;              b -> X-7
 03C6           ;              a -> X-5
 03C6           _swap::
 03C6                   .dbline -1
 03C6 10                push X
 03C7 4F                mov X,SP
 03C8 3803              add SP,3
 03CA                   .dbline 187
 03CA           ; }
 03CA           ; 
 03CA           ; // Sort Algorithm for tables based on quick sort
 03CA           ; 
 03CA           ; void swap(vocabTable_type* a, vocabTable_type* b)
 03CA           ; {
 03CA                   .dbline 188
 03CA           ;     vocabTable_type temp = *a;
 03CA 62D000            mov REG[0xd0],>__r0
 03CD 52FC              mov A,[X-4]
 03CF 5300              mov [__r1],A
 03D1 52FB              mov A,[X-5]
 03D3 5A00              mov [__r3],X
 03D5 60D4              mov REG[0xd4],A
 03D7 62D503            mov REG[0xd5],3
 03DA 3E00              mvi A,[__r1]
 03DC 3F00              mvi [__r3],A
 03DE 3E00              mvi A,[__r1]
 03E0 3F00              mvi [__r3],A
 03E2 3E00              mvi A,[__r1]
 03E4 3F00              mvi [__r3],A
 03E6                   .dbline 189
 03E6           ;     *a = *b;
 03E6 52FA              mov A,[X-6]
 03E8 5300              mov [__r1],A
 03EA 52F9              mov A,[X-7]
 03EC 5300              mov [__r0],A
 03EE 52FC              mov A,[X-4]
 03F0 5300              mov [__r3],A
 03F2 52FB              mov A,[X-5]
 03F4 5300              mov [__r2],A
 03F6 5100              mov A,[__r0]
 03F8 60D4              mov REG[0xd4],A
 03FA 5100              mov A,[__r2]
 03FC 60D5              mov REG[0xd5],A
 03FE 3E00              mvi A,[__r1]
 0400 3F00              mvi [__r3],A
 0402 3E00              mvi A,[__r1]
 0404 3F00              mvi [__r3],A
 0406 3E00              mvi A,[__r1]
 0408 3F00              mvi [__r3],A
 040A                   .dbline 190
 040A           ;     *b = temp;
 040A 5A00              mov [__r1],X
 040C 52FA              mov A,[X-6]
 040E 5300              mov [__r3],A
 0410 52F9              mov A,[X-7]
 0412 62D403            mov REG[0xd4],3
 0415 60D5              mov REG[0xd5],A
 0417 3E00              mvi A,[__r1]
 0419 3F00              mvi [__r3],A
 041B 3E00              mvi A,[__r1]
 041D 3F00              mvi [__r3],A
 041F 3E00              mvi A,[__r1]
 0421 3F00              mvi [__r3],A
 0423                   .dbline -2
 0423           L49:
 0423 38FD              add SP,-3
 0425 20                pop X
 0426                   .dbline 0 ; func end
 0426 7F                ret
 0427                   .dbsym l temp 0 S[vocabTable]
 0427                   .dbsym l b -7 pS[vocabTable]
 0427                   .dbsym l a -5 pS[vocabTable]
 0427                   .dbend
 0427                   .dbfunc e part _part fI
 0427           ;              x -> X+4
 0427           ;              i -> X+2
 0427           ;              j -> X+0
 0427           ;              h -> X-9
 0427           ;              l -> X-7
 0427           ;            arr -> X-5
 0427           _part::
 0427                   .dbline -1
 0427 10                push X
 0428 4F                mov X,SP
 0429 3806              add SP,6
 042B                   .dbline 194
 042B           ; }
 042B           ; 
 042B           ; int part(vocabTable_type arr[], int l, int h)
 042B           ; {
 042B                   .dbline 195
 042B           ;     int x = arr[h].frequency;
 042B 62D000            mov REG[0xd0],>__r0
 042E 52F7              mov A,[X-9]
 0430 08                push A
 0431 52F8              mov A,[X-8]
 0433 08                push A
 0434 5000              mov A,0
 0436 08                push A
 0437 5003              mov A,3
 0439 08                push A
 043A 7C0000            xcall __mul16
 043D 38FC              add SP,-4
 043F 5100              mov A,[__rX]
 0441 5300              mov [__r1],A
 0443 5100              mov A,[__rY]
 0445 5300              mov [__r0],A
 0447 52FC              mov A,[X-4]
 0449 0400              add [__r1],A
 044B 52FB              mov A,[X-5]
 044D 0C00              adc [__r0],A
 044F 060001            add [__r1],1
 0452 0E0000            adc [__r0],0
 0455 5100              mov A,[__r0]
 0457 60D4              mov REG[0xd4],A
 0459 3E00              mvi A,[__r1]
 045B 5405              mov [X+5],A
 045D 560400            mov [X+4],0
 0460                   .dbline 196
 0460           ;     int i = (l - 1);
 0460 52FA              mov A,[X-6]
 0462 1101              sub A,1
 0464 5403              mov [X+3],A
 0466 52F9              mov A,[X-7]
 0468 1900              sbb A,0
 046A 5402              mov [X+2],A
 046C                   .dbline 198
 046C           ;       int j; 
 046C           ;     for ( j = l; j <= h - 1; j++) 
 046C 52FA              mov A,[X-6]
 046E 5401              mov [X+1],A
 0470 52F9              mov A,[X-7]
 0472 5400              mov [X+0],A
 0474 80A0              xjmp L54
 0476           L51:
 0476                   .dbline 199
 0476           ;       {
 0476                   .dbline 200
 0476           ;         if (arr[j].frequency >= x) 
 0476 62D000            mov REG[0xd0],>__r0
 0479 5200              mov A,[X+0]
 047B 08                push A
 047C 5201              mov A,[X+1]
 047E 08                push A
 047F 5000              mov A,0
 0481 08                push A
 0482 5003              mov A,3
 0484 08                push A
 0485 7C0000            xcall __mul16
 0488 38FC              add SP,-4
 048A 5100              mov A,[__rX]
 048C 5300              mov [__r1],A
 048E 5100              mov A,[__rY]
 0490 5300              mov [__r0],A
 0492 52FC              mov A,[X-4]
 0494 0400              add [__r1],A
 0496 52FB              mov A,[X-5]
 0498 0C00              adc [__r0],A
 049A 060001            add [__r1],1
 049D 0E0000            adc [__r0],0
 04A0 5100              mov A,[__r0]
 04A2 60D4              mov REG[0xd4],A
 04A4 3E00              mvi A,[__r1]
 04A6 1305              sub A,[X+5]
 04A8 5204              mov A,[X+4]
 04AA 3180              xor A,-128
 04AC 5300              mov [__rX],A
 04AE 5000              mov A,0
 04B0 3180              xor A,-128
 04B2 1A00              sbb A,[__rX]
 04B4 C05B              jc L55
 04B6           X12:
 04B6                   .dbline 202
 04B6           ;               {
 04B6           ;             i++;
 04B6                   .dbline 202
 04B6 7703              inc [X+3]
 04B8 0F0200            adc [X+2],0
 04BB                   .dbline 203
 04BB           ;             swap(&arr[i], &arr[j]);
 04BB 62D000            mov REG[0xd0],>__r0
 04BE 5200              mov A,[X+0]
 04C0 08                push A
 04C1 5201              mov A,[X+1]
 04C3 08                push A
 04C4 5000              mov A,0
 04C6 08                push A
 04C7 5003              mov A,3
 04C9 08                push A
 04CA 7C0000            xcall __mul16
 04CD 38FC              add SP,-4
 04CF 5100              mov A,[__rX]
 04D1 5300              mov [__r1],A
 04D3 5100              mov A,[__rY]
 04D5 5300              mov [__r0],A
 04D7 52FC              mov A,[X-4]
 04D9 0400              add [__r1],A
 04DB 52FB              mov A,[X-5]
 04DD 0C00              adc [__r0],A
 04DF 5100              mov A,[__r0]
 04E1 08                push A
 04E2 5100              mov A,[__r1]
 04E4 08                push A
 04E5 5202              mov A,[X+2]
 04E7 08                push A
 04E8 5203              mov A,[X+3]
 04EA 08                push A
 04EB 5000              mov A,0
 04ED 08                push A
 04EE 5003              mov A,3
 04F0 08                push A
 04F1 7C0000            xcall __mul16
 04F4 38FC              add SP,-4
 04F6 5100              mov A,[__rX]
 04F8 5300              mov [__r1],A
 04FA 5100              mov A,[__rY]
 04FC 5300              mov [__r0],A
 04FE 52FC              mov A,[X-4]
 0500 0400              add [__r1],A
 0502 52FB              mov A,[X-5]
 0504 0C00              adc [__r0],A
 0506 5100              mov A,[__r0]
 0508 08                push A
 0509 5100              mov A,[__r1]
 050B 08                push A
 050C 9EB8              xcall _swap
 050E 38FC              add SP,-4
 0510                   .dbline 204
 0510           ;         }
 0510           L55:
 0510                   .dbline 205
 0510           ;     }
 0510           L52:
 0510                   .dbline 198
 0510 7701              inc [X+1]
 0512 0F0000            adc [X+0],0
 0515           L54:
 0515                   .dbline 198
 0515 62D000            mov REG[0xd0],>__r0
 0518 52F8              mov A,[X-8]
 051A 1101              sub A,1
 051C 5300              mov [__r1],A
 051E 52F7              mov A,[X-9]
 0520 1900              sbb A,0
 0522 5300              mov [__r0],A
 0524 5100              mov A,[__r1]
 0526 1301              sub A,[X+1]
 0528 5200              mov A,[X+0]
 052A 3180              xor A,-128
 052C 5300              mov [__rX],A
 052E 5100              mov A,[__r0]
 0530 3180              xor A,-128
 0532 1A00              sbb A,[__rX]
 0534 DF41              jnc L51
 0536           X13:
 0536                   .dbline 206
 0536           ;     swap(&arr[i + 1], &arr[h]);
 0536 62D000            mov REG[0xd0],>__r0
 0539 52F7              mov A,[X-9]
 053B 08                push A
 053C 52F8              mov A,[X-8]
 053E 08                push A
 053F 5000              mov A,0
 0541 08                push A
 0542 5003              mov A,3
 0544 08                push A
 0545 7C0000            xcall __mul16
 0548 38FC              add SP,-4
 054A 5100              mov A,[__rX]
 054C 5300              mov [__r1],A
 054E 5100              mov A,[__rY]
 0550 5300              mov [__r0],A
 0552 52FC              mov A,[X-4]
 0554 0400              add [__r1],A
 0556 52FB              mov A,[X-5]
 0558 0C00              adc [__r0],A
 055A 5100              mov A,[__r0]
 055C 08                push A
 055D 5100              mov A,[__r1]
 055F 08                push A
 0560 5202              mov A,[X+2]
 0562 08                push A
 0563 5203              mov A,[X+3]
 0565 08                push A
 0566 5000              mov A,0
 0568 08                push A
 0569 5003              mov A,3
 056B 08                push A
 056C 7C0000            xcall __mul16
 056F 38FC              add SP,-4
 0571 5100              mov A,[__rX]
 0573 5300              mov [__r1],A
 0575 5100              mov A,[__rY]
 0577 5300              mov [__r0],A
 0579 52FC              mov A,[X-4]
 057B 0400              add [__r1],A
 057D 52FB              mov A,[X-5]
 057F 0C00              adc [__r0],A
 0581 060003            add [__r1],3
 0584 0E0000            adc [__r0],0
 0587 5100              mov A,[__r0]
 0589 08                push A
 058A 5100              mov A,[__r1]
 058C 08                push A
 058D 9E37              xcall _swap
 058F 38FC              add SP,-4
 0591                   .dbline 207
 0591           ;     return (i + 1);
 0591 62D000            mov REG[0xd0],>__r0
 0594 5203              mov A,[X+3]
 0596 0101              add A,1
 0598 5300              mov [__r1],A
 059A 5202              mov A,[X+2]
 059C 0900              adc A,0
 059E 5300              mov [__r0],A
 05A0                   .dbline -2
 05A0           L50:
 05A0 38FA              add SP,-6
 05A2 20                pop X
 05A3                   .dbline 0 ; func end
 05A3 7F                ret
 05A4                   .dbsym l x 4 I
 05A4                   .dbsym l i 2 I
 05A4                   .dbsym l j 0 I
 05A4                   .dbsym l h -9 I
 05A4                   .dbsym l l -7 I
 05A4                   .dbsym l arr -5 pS[vocabTable]
 05A4                   .dbend
 05A4                   .dbfunc e quickSort _quickSort fV
 05A4           ;              p -> X+0
 05A4           ;              h -> X-9
 05A4           ;              l -> X-7
 05A4           ;              A -> X-5
 05A4           _quickSort::
 05A4                   .dbline -1
 05A4 10                push X
 05A5 4F                mov X,SP
 05A6 3802              add SP,2
 05A8                   .dbline 211
 05A8           ; }
 05A8           ; 
 05A8           ; void quickSort(vocabTable_type A[], int l, int h)
 05A8           ; {
 05A8                   .dbline 212
 05A8           ;     if (l < h) {
 05A8 52FA              mov A,[X-6]
 05AA 13F8              sub A,[X-8]
 05AC 52F7              mov A,[X-9]
 05AE 3180              xor A,-128
 05B0 62D000            mov REG[0xd0],>__r0
 05B3 5300              mov [__rX],A
 05B5 52F9              mov A,[X-7]
 05B7 3180              xor A,-128
 05B9 1A00              sbb A,[__rX]
 05BB D05F              jnc L58
 05BD           X14:
 05BD                   .dbline 213
 05BD           ;         int p = part(A, l, h);
 05BD                   .dbline 213
 05BD 52F7              mov A,[X-9]
 05BF 08                push A
 05C0 52F8              mov A,[X-8]
 05C2 08                push A
 05C3 52F9              mov A,[X-7]
 05C5 08                push A
 05C6 52FA              mov A,[X-6]
 05C8 08                push A
 05C9 52FB              mov A,[X-5]
 05CB 08                push A
 05CC 52FC              mov A,[X-4]
 05CE 08                push A
 05CF 9E56              xcall _part
 05D1 38FA              add SP,-6
 05D3 62D000            mov REG[0xd0],>__r0
 05D6 5100              mov A,[__r1]
 05D8 5401              mov [X+1],A
 05DA 5100              mov A,[__r0]
 05DC 5400              mov [X+0],A
 05DE                   .dbline 214
 05DE           ;         quickSort(A, l, p - 1);
 05DE 5201              mov A,[X+1]
 05E0 1101              sub A,1
 05E2 5300              mov [__r1],A
 05E4 5200              mov A,[X+0]
 05E6 1900              sbb A,0
 05E8 08                push A
 05E9 5100              mov A,[__r1]
 05EB 08                push A
 05EC 52F9              mov A,[X-7]
 05EE 08                push A
 05EF 52FA              mov A,[X-6]
 05F1 08                push A
 05F2 52FB              mov A,[X-5]
 05F4 08                push A
 05F5 52FC              mov A,[X-4]
 05F7 08                push A
 05F8 9FAA              xcall _quickSort
 05FA                   .dbline 215
 05FA           ;         quickSort(A, p + 1, h);
 05FA 52F7              mov A,[X-9]
 05FC 08                push A
 05FD 52F8              mov A,[X-8]
 05FF 08                push A
 0600 62D000            mov REG[0xd0],>__r0
 0603 5201              mov A,[X+1]
 0605 0101              add A,1
 0607 5300              mov [__r1],A
 0609 5200              mov A,[X+0]
 060B 0900              adc A,0
 060D 08                push A
 060E 5100              mov A,[__r1]
 0610 08                push A
 0611 52FB              mov A,[X-5]
 0613 08                push A
 0614 52FC              mov A,[X-4]
 0616 08                push A
 0617 9F8B              xcall _quickSort
 0619 38F4              add SP,-12
 061B                   .dbline 216
 061B           ;     }
 061B           L58:
 061B                   .dbline -2
 061B           L57:
 061B 38FE              add SP,-2
 061D 20                pop X
 061E                   .dbline 0 ; func end
 061E 7F                ret
 061F                   .dbsym l p 0 I
 061F                   .dbsym l h -9 I
 061F                   .dbsym l l -7 I
 061F                   .dbsym l A -5 pS[vocabTable]
 061F                   .dbend
 061F                   .dbfunc e print_LCD_debug_msg _print_LCD_debug_msg fV
 061F           ;              i -> X+0
 061F           ;            col -> X-9
 061F           ;            row -> X-7
 061F           ;            msg -> X-5
 061F           _print_LCD_debug_msg::
 061F                   .dbline -1
 061F 10                push X
 0620 4F                mov X,SP
 0621 3802              add SP,2
 0623                   .dbline 233
 0623           ; }
 0623           ; /*
 0623           ; void remove(BYTE freq_threshold,vocabTable_type table )
 0623           ; {
 0623           ;       int i;
 0623           ;       for(i= 0; i< SIZE; i++)
 0623           ;       {       
 0623           ;               if(table[i].frequency < freq_threshold)
 0623           ;               {
 0623           ;                       table[i]= {0};// Remove the old word and details and initial with zero  
 0623           ;               }
 0623           ;       }
 0623           ;       
 0623           ; }
 0623           ; */
 0623           ; void print_LCD_debug_msg(char* msg,INT row,INT col)
 0623           ; {
 0623                   .dbline 235
 0623           ;       int i;
 0623           ;       LCD_2_Position(row,col);
 0623 62D000            mov REG[0xd0],>__r0
 0626 52F8              mov A,[X-8]
 0628 10                push X
 0629 08                push A
 062A 52FA              mov A,[X-6]
 062C 20                pop X
 062D 7C0000            xcall _LCD_2_Position
 0630 20                pop X
 0631                   .dbline 236
 0631           ;       LCD_2_PrString(msg);
 0631 10                push X
 0632 52FB              mov A,[X-5]
 0634 08                push A
 0635 52FC              mov A,[X-4]
 0637 5C                mov X,A
 0638 18                pop A
 0639 7C0000            xcall _LCD_2_PrString
 063C                   .dbline 238
 063C           ;       //for (i = 0;i<157;i++)
 063C           ;       LCD_2_Delay50uTimes(255);
 063C 50FF              mov A,-1
 063E 7C0000            xcall _LCD_2_Delay50uTimes
 0641                   .dbline 239
 0641           ;       LCD_2_Delay50uTimes(255);
 0641 50FF              mov A,-1
 0643 7C0000            xcall _LCD_2_Delay50uTimes
 0646                   .dbline 240
 0646           ;       LCD_2_Delay50uTimes(255);
 0646 50FF              mov A,-1
 0648 7C0000            xcall _LCD_2_Delay50uTimes
 064B 20                pop X
 064C                   .dbline -2
 064C           L60:
 064C 38FE              add SP,-2
 064E 20                pop X
 064F                   .dbline 0 ; func end
 064F 7F                ret
 0650                   .dbsym l i 0 I
 0650                   .dbsym l col -9 I
 0650                   .dbsym l row -7 I
 0650                   .dbsym l msg -5 pc
 0650                   .dbend
 0650                   .dbfunc e read_temperature _read_temperature fI
 0650           ;    Temperature -> X+2
 0650           ;      LowerByte -> X+1
 0650           ;      UpperByte -> X+0
 0650           _read_temperature::
 0650                   .dbline -1
 0650 10                push X
 0651 4F                mov X,SP
 0652 3804              add SP,4
 0654                   .dbline 244
 0654           ; }
 0654           ; 
 0654           ; INT read_temperature(void)
 0654           ; {
 0654                   .dbline 245
 0654           ;       BYTE UpperByte = 0;
 0654 560000            mov [X+0],0
 0657                   .dbline 246
 0657           ;       BYTE LowerByte = 0;
 0657 560100            mov [X+1],0
 065A                   .dbline 247
 065A           ;       INT Temperature =0;
 065A 560300            mov [X+3],0
 065D 560200            mov [X+2],0
 0660                   .dbline 249
 0660           ;       
 0660           ;       I2CHW_Temp_fSendStart(TEMP_SENSOR_SLAVE_ADDRESS, I2CHW_Temp_WRITE);
 0660 10                push X
 0661 5700              mov X,0
 0663 5018              mov A,24
 0665 7C0000            xcall _I2CHW_Temp_fSendStart
 0668 20                pop X
 0669 62D000            mov REG[0xd0],>__r0
 066C                   .dbline 250
 066C           ;       I2CHW_Temp_fWrite(TEMP_REG);
 066C 10                push X
 066D 5005              mov A,5
 066F 7C0000            xcall _I2CHW_Temp_fWrite
 0672 20                pop X
 0673 62D000            mov REG[0xd0],>__r0
 0676                   .dbline 251
 0676           ;       I2CHW_Temp_SendStop();
 0676 10                push X
 0677 7C0000            xcall _I2CHW_Temp_SendStop
 067A                   .dbline 252
 067A           ;       I2CHW_Temp_fSendStart(TEMP_SENSOR_SLAVE_ADDRESS, I2CHW_Temp_READ);
 067A 5701              mov X,1
 067C 5018              mov A,24
 067E 7C0000            xcall _I2CHW_Temp_fSendStart
 0681 20                pop X
 0682 62D000            mov REG[0xd0],>__r0
 0685                   .dbline 253
 0685           ;       UpperByte = I2CHW_Temp_bRead(I2CHW_Temp_ACKslave);
 0685 10                push X
 0686 5001              mov A,1
 0688 7C0000            xcall _I2CHW_Temp_bRead
 068B 20                pop X
 068C 62D000            mov REG[0xd0],>__r0
 068F 5400              mov [X+0],A
 0691                   .dbline 254
 0691           ;       LowerByte = I2CHW_Temp_bRead(I2CHW_Temp_NAKslave);
 0691 10                push X
 0692 5000              mov A,0
 0694 7C0000            xcall _I2CHW_Temp_bRead
 0697 20                pop X
 0698 62D000            mov REG[0xd0],>__r0
 069B 5401              mov [X+1],A
 069D                   .dbline 255
 069D           ;       I2CHW_Temp_SendStop();
 069D 10                push X
 069E 7C0000            xcall _I2CHW_Temp_SendStop
 06A1 20                pop X
 06A2                   .dbline 257
 06A2           ;       
 06A2           ;       UpperByte = UpperByte & 0x1F; //Clear flag bits
 06A2 27001F            and [X+0],31
 06A5                   .dbline 259
 06A5           ;       
 06A5           ;       if ((UpperByte & 0x10) == 0x10){ //TA < 0C
 06A5 62D000            mov REG[0xd0],>__r0
 06A8 5200              mov A,[X+0]
 06AA 2110              and A,16
 06AC 3910              cmp A,16
 06AE B050              jnz L62
 06B0                   .dbline 260
 06B0           ;       UpperByte = UpperByte & 0x0F;//Clear SIGN
 06B0                   .dbline 260
 06B0 27000F            and [X+0],15
 06B3                   .dbline 261
 06B3           ;       Temperature = 256 - (UpperByte * 16 + LowerByte / 16);
 06B3 5201              mov A,[X+1]
 06B5 5300              mov [__r1],A
 06B7 5000              mov A,0
 06B9 08                push A
 06BA 5010              mov A,16
 06BC 08                push A
 06BD 5000              mov A,0
 06BF 08                push A
 06C0 5100              mov A,[__r1]
 06C2 08                push A
 06C3 7C0000            xcall __divmod_16X16_16
 06C6 18                pop A
 06C7 5300              mov [__r1],A
 06C9 18                pop A
 06CA 5300              mov [__r0],A
 06CC 38FE              add SP,-2
 06CE 5200              mov A,[X+0]
 06D0 5300              mov [__r3],A
 06D2 550000            mov [__r2],0
 06D5 6500              asl [__r3]
 06D7 6B00              rlc [__r2]
 06D9 6500              asl [__r3]
 06DB 6B00              rlc [__r2]
 06DD 6500              asl [__r3]
 06DF 6B00              rlc [__r2]
 06E1 6500              asl [__r3]
 06E3 6B00              rlc [__r2]
 06E5 5100              mov A,[__r3]
 06E7 0200              add A,[__r1]
 06E9 5300              mov [__r1],A
 06EB 5100              mov A,[__r2]
 06ED 0A00              adc A,[__r0]
 06EF 5300              mov [__r0],A
 06F1 5000              mov A,0
 06F3 1200              sub A,[__r1]
 06F5 5403              mov [X+3],A
 06F7 5001              mov A,1
 06F9 1A00              sbb A,[__r0]
 06FB 5402              mov [X+2],A
 06FD                   .dbline 262
 06FD           ;       }else //TA  0C*/
 06FD 8042              xjmp L63
 06FF           L62:
 06FF                   .dbline 263
 06FF           ;       Temperature = (UpperByte * 16 + LowerByte / 16);//Temperature = Ambient Temperature (C)
 06FF 62D000            mov REG[0xd0],>__r0
 0702 5201              mov A,[X+1]
 0704 5300              mov [__r1],A
 0706 5000              mov A,0
 0708 08                push A
 0709 5010              mov A,16
 070B 08                push A
 070C 5000              mov A,0
 070E 08                push A
 070F 5100              mov A,[__r1]
 0711 08                push A
 0712 7C0000            xcall __divmod_16X16_16
 0715 18                pop A
 0716 5300              mov [__r1],A
 0718 18                pop A
 0719 5300              mov [__r0],A
 071B 38FE              add SP,-2
 071D 5200              mov A,[X+0]
 071F 5300              mov [__r3],A
 0721 550000            mov [__r2],0
 0724 6500              asl [__r3]
 0726 6B00              rlc [__r2]
 0728 6500              asl [__r3]
 072A 6B00              rlc [__r2]
 072C 6500              asl [__r3]
 072E 6B00              rlc [__r2]
 0730 6500              asl [__r3]
 0732 6B00              rlc [__r2]
 0734 5100              mov A,[__r3]
 0736 0200              add A,[__r1]
 0738 5403              mov [X+3],A
 073A 5100              mov A,[__r2]
 073C 0A00              adc A,[__r0]
 073E 5402              mov [X+2],A
 0740           L63:
 0740                   .dbline 265
 0740           ;       
 0740           ;       return Temperature;
 0740 62D000            mov REG[0xd0],>__r0
 0743 5203              mov A,[X+3]
 0745 5300              mov [__r1],A
 0747 5202              mov A,[X+2]
 0749 5300              mov [__r0],A
 074B                   .dbline -2
 074B           L61:
 074B 38FC              add SP,-4
 074D 20                pop X
 074E                   .dbline 0 ; func end
 074E 7F                ret
 074F                   .dbsym l Temperature 2 I
 074F                   .dbsym l LowerByte 1 c
 074F                   .dbsym l UpperByte 0 c
 074F                   .dbend
 074F                   .dbfunc e getLux _getLux fD
 074F           ;            lux -> X+12
 074F           ;      microamps -> X+8
 074F           ;           amps -> X+4
 074F           ;          volts -> X+0
 074F           _getLux::
 074F                   .dbline -1
 074F 10                push X
 0750 4F                mov X,SP
 0751 3810              add SP,16
 0753                   .dbline 268
 0753           ; }
 0753           ; float getLux(void )
 0753           ; {
 0753                   .dbline 269
 0753           ;       float volts = readDualAdc(LIGHT_SENSOR_ADC_CHANNEL)*5.0 /1024.0;
 0753 5000              mov A,0
 0755 08                push A
 0756 5002              mov A,2
 0758 08                push A
 0759 9116              xcall _readDualAdc
 075B 38FE              add SP,-2
 075D 62D000            mov REG[0xd0],>__r0
 0760 5100              mov A,[__r1]
 0762 5300              mov [__r3],A
 0764 5100              mov A,[__r0]
 0766 5300              mov [__r2],A
 0768 470080            tst [__r2],-128
 076B A009              jz X15
 076D 5500FF            mov [__r1],-1
 0770 5500FF            mov [__r0],-1
 0773 800A              jmp X16
 0775           X15:
 0775 62D000            mov REG[0xd0],>__r0
 0778 550000            mov [__r1],0
 077B 550000            mov [__r0],0
 077E           X16:
 077E 62D000            mov REG[0xd0],>__r0
 0781 5100              mov A,[__r0]
 0783 08                push A
 0784 5100              mov A,[__r1]
 0786 08                push A
 0787 5100              mov A,[__r2]
 0789 08                push A
 078A 5100              mov A,[__r3]
 078C 08                push A
 078D 7C0000            xcall __long2fp
 0790 18                pop A
 0791 5300              mov [__r3],A
 0793 18                pop A
 0794 5300              mov [__r2],A
 0796 18                pop A
 0797 5300              mov [__r1],A
 0799 18                pop A
 079A 08                push A
 079B 5100              mov A,[__r1]
 079D 08                push A
 079E 5100              mov A,[__r2]
 07A0 08                push A
 07A1 5100              mov A,[__r3]
 07A3 08                push A
 07A4 5040              mov A,64
 07A6 08                push A
 07A7 50A0              mov A,-96
 07A9 08                push A
 07AA 5000              mov A,0
 07AC 08                push A
 07AD 08                push A
 07AE 7C0000            xcall __fpmul
 07B1 18                pop A
 07B2 5300              mov [__r3],A
 07B4 18                pop A
 07B5 5300              mov [__r2],A
 07B7 18                pop A
 07B8 5300              mov [__r1],A
 07BA 18                pop A
 07BB 5300              mov [__r0],A
 07BD 38FC              add SP,-4
 07BF 5044              mov A,68
 07C1 08                push A
 07C2 5080              mov A,-128
 07C4 08                push A
 07C5 5000              mov A,0
 07C7 08                push A
 07C8 08                push A
 07C9 5100              mov A,[__r0]
 07CB 08                push A
 07CC 5100              mov A,[__r1]
 07CE 08                push A
 07CF 5100              mov A,[__r2]
 07D1 08                push A
 07D2 5100              mov A,[__r3]
 07D4 08                push A
 07D5 7C0000            xcall __fpdiv
 07D8 18                pop A
 07D9 5403              mov [X+3],A
 07DB 18                pop A
 07DC 5402              mov [X+2],A
 07DE 18                pop A
 07DF 5401              mov [X+1],A
 07E1 18                pop A
 07E2 5400              mov [X+0],A
 07E4 38FC              add SP,-4
 07E6                   .dbline 270
 07E6           ;       float amps  = volts/10000.0; // Across 10,000 Ohms
 07E6 5046              mov A,70
 07E8 08                push A
 07E9 501C              mov A,28
 07EB 08                push A
 07EC 5040              mov A,64
 07EE 08                push A
 07EF 5000              mov A,0
 07F1 08                push A
 07F2 5200              mov A,[X+0]
 07F4 08                push A
 07F5 5201              mov A,[X+1]
 07F7 08                push A
 07F8 5202              mov A,[X+2]
 07FA 08                push A
 07FB 5203              mov A,[X+3]
 07FD 08                push A
 07FE 7C0000            xcall __fpdiv
 0801 18                pop A
 0802 5407              mov [X+7],A
 0804 18                pop A
 0805 5406              mov [X+6],A
 0807 18                pop A
 0808 5405              mov [X+5],A
 080A 18                pop A
 080B 5404              mov [X+4],A
 080D 38FC              add SP,-4
 080F                   .dbline 271
 080F           ;       float microamps = amps * 1000000;
 080F 5204              mov A,[X+4]
 0811 08                push A
 0812 5205              mov A,[X+5]
 0814 08                push A
 0815 5206              mov A,[X+6]
 0817 08                push A
 0818 5207              mov A,[X+7]
 081A 08                push A
 081B 5049              mov A,73
 081D 08                push A
 081E 5074              mov A,116
 0820 08                push A
 0821 5024              mov A,36
 0823 08                push A
 0824 5000              mov A,0
 0826 08                push A
 0827 7C0000            xcall __fpmul
 082A 18                pop A
 082B 540B              mov [X+11],A
 082D 18                pop A
 082E 540A              mov [X+10],A
 0830 18                pop A
 0831 5409              mov [X+9],A
 0833 18                pop A
 0834 5408              mov [X+8],A
 0836 38FC              add SP,-4
 0838                   .dbline 272
 0838           ;       float lux = microamps * 2.0;
 0838 5208              mov A,[X+8]
 083A 08                push A
 083B 5209              mov A,[X+9]
 083D 08                push A
 083E 520A              mov A,[X+10]
 0840 08                push A
 0841 520B              mov A,[X+11]
 0843 08                push A
 0844 5040              mov A,64
 0846 08                push A
 0847 5000              mov A,0
 0849 08                push A
 084A 08                push A
 084B 08                push A
 084C 7C0000            xcall __fpmul
 084F 18                pop A
 0850 540F              mov [X+15],A
 0852 18                pop A
 0853 540E              mov [X+14],A
 0855 18                pop A
 0856 540D              mov [X+13],A
 0858 18                pop A
 0859 540C              mov [X+12],A
 085B 38FC              add SP,-4
 085D                   .dbline 274
 085D           ;       
 085D           ;       return lux;
 085D 520C              mov A,[X+12]
 085F 5300              mov [__r0],A
 0861 520D              mov A,[X+13]
 0863 5300              mov [__r1],A
 0865 520E              mov A,[X+14]
 0867 5300              mov [__r2],A
 0869 520F              mov A,[X+15]
 086B 5300              mov [__r3],A
 086D                   .dbline -2
 086D           L64:
 086D 38F0              add SP,-16
 086F 20                pop X
 0870                   .dbline 0 ; func end
 0870 7F                ret
 0871                   .dbsym l lux 12 D
 0871                   .dbsym l microamps 8 D
 0871                   .dbsym l amps 4 D
 0871                   .dbsym l volts 0 D
 0871                   .dbend
 0871                   .dbfunc e readDualAdc _readDualAdc fI
 0871           ;       iResult2 -> X+4
 0871           ;       iResult1 -> X+2
 0871           ;        iResult -> X+0
 0871           ;        channel -> X-5
 0871           _readDualAdc::
 0871                   .dbline -1
 0871 10                push X
 0872 4F                mov X,SP
 0873 3806              add SP,6
 0875                   .dbline 278
 0875           ; }     
 0875           ; 
 0875           ; INT readDualAdc(INT channel)
 0875           ; {
 0875           L66:
 0875                   .dbline 280
 0875           ;       int iResult1, iResult2, iResult;
 0875           ;       while(DUALADC_1_fIsDataAvailable() == 0);  // Wait for data to be ready
 0875           L67:
 0875                   .dbline 280
 0875 10                push X
 0876 7C0000            xcall _DUALADC_1_fIsDataAvailable
 0879 20                pop X
 087A 62D000            mov REG[0xd0],>__r0
 087D 3900              cmp A,0
 087F AFF5              jz L66
 0881                   .dbline 281
 0881           ;       iResult1 = DUALADC_1_iGetData1();          // Get Data from ADC Input1
 0881 10                push X
 0882 7C0000            xcall _DUALADC_1_iGetData1
 0885 62D000            mov REG[0xd0],>__r0
 0888 5A00              mov [__r0],X
 088A 20                pop X
 088B 5403              mov [X+3],A
 088D 5100              mov A,[__r0]
 088F 5402              mov [X+2],A
 0891                   .dbline 282
 0891           ;       iResult2 = DUALADC_1_iGetData2ClearFlag(); // Get Data from ADC Input2
 0891 10                push X
 0892 7C0000            xcall _DUALADC_1_iGetData2ClearFlag
 0895 62D000            mov REG[0xd0],>__r0
 0898 5A00              mov [__r0],X
 089A 20                pop X
 089B 5405              mov [X+5],A
 089D 5100              mov A,[__r0]
 089F 5404              mov [X+4],A
 08A1                   .dbline 285
 08A1           ;     
 08A1           ;                                                       // and clear data ready flag
 08A1           ;       if (channel == 1)
 08A1 3DFB00            cmp [X-5],0
 08A4 B010              jnz L69
 08A6 3DFC01            cmp [X-4],1
 08A9 B00B              jnz L69
 08AB           X17:
 08AB                   .dbline 287
 08AB           ;       {
 08AB           ;               iResult = iResult1;                                     // Return Mic ADC readings result
 08AB                   .dbline 287
 08AB 5203              mov A,[X+3]
 08AD 5401              mov [X+1],A
 08AF 5202              mov A,[X+2]
 08B1 5400              mov [X+0],A
 08B3                   .dbline 288
 08B3           ;       }
 08B3 8013              xjmp L70
 08B5           L69:
 08B5                   .dbline 289
 08B5           ;       else if ( channel == 2)
 08B5 3DFB00            cmp [X-5],0
 08B8 B00E              jnz L71
 08BA 3DFC02            cmp [X-4],2
 08BD B009              jnz L71
 08BF           X18:
 08BF                   .dbline 291
 08BF           ;       {
 08BF           ;               iResult = iResult2;                                     // Return light sensor ADC readings result
 08BF                   .dbline 291
 08BF 5205              mov A,[X+5]
 08C1 5401              mov [X+1],A
 08C3 5204              mov A,[X+4]
 08C5 5400              mov [X+0],A
 08C7                   .dbline 292
 08C7           ;       }
 08C7           L71:
 08C7           L70:
 08C7                   .dbline 293
 08C7           ;       return iResult;
 08C7 62D000            mov REG[0xd0],>__r0
 08CA 5201              mov A,[X+1]
 08CC 5300              mov [__r1],A
 08CE 5200              mov A,[X+0]
 08D0 5300              mov [__r0],A
 08D2                   .dbline -2
 08D2           L65:
 08D2 38FA              add SP,-6
 08D4 20                pop X
 08D5                   .dbline 0 ; func end
 08D5 7F                ret
 08D6                   .dbsym l iResult2 4 I
 08D6                   .dbsym l iResult1 2 I
 08D6                   .dbsym l iResult 0 I
 08D6                   .dbsym l channel -5 I
 08D6                   .dbend
 08D6                   .dbfunc e blocking_delay _blocking_delay fV
 08D6           ;         bTimes -> X-4
 08D6           _blocking_delay::
 08D6                   .dbline -1
 08D6 10                push X
 08D7 4F                mov X,SP
 08D8                   .dbline 298
 08D8           ; }
 08D8           ; 
 08D8           ; 
 08D8           ; void blocking_delay(BYTE bTimes)
 08D8           ; {
 08D8                   .dbline 301
 08D8           ;       // Can be used only if the delaly required is a mutiple of 50us.
 08D8           ;       // This sufficient for this project.
 08D8           ;       LCD_2_Delay50uTimes(bTimes);// Reuse the delay function provided by LCD user module             
 08D8 10                push X
 08D9 52FC              mov A,[X-4]
 08DB 7C0000            xcall _LCD_2_Delay50uTimes
 08DE 20                pop X
 08DF                   .dbline -2
 08DF           L73:
 08DF 20                pop X
 08E0                   .dbline 0 ; func end
 08E0 7F                ret
 08E1                   .dbsym l bTimes -4 c
 08E1                   .dbend
