 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _lux_range_1::
 0000 014D              .word 333
 0002                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0002                   .dbsym e lux_range_1 _lux_range_1 I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _lux_range_2::
 0000 029A              .word 666
 0002                   .dbsym e lux_range_2 _lux_range_2 I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _temp_range_1::
 0000 000A              .word 10
 0002                   .dbsym e temp_range_1 _temp_range_1 I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _temp_range_2::
 0000 0017              .word 23
 0002                   .dbsym e temp_range_2 _temp_range_2 I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _my_table::
 0000 00                .byte 0
 0001 000000            .byte 0,0,0
 0004 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 0040 00000000000000000000      .word 0,0,0,0,0
 004A 000000000000      .byte 0,0,0,0,0,0
 0050                   .dbstruct 0 4 vocabTable
 0050                   .dbfield 0 word c
 0050                   .dbfield 1 label c
 0050                   .dbfield 2 frequency c
 0050                   .dbfield 3 age c
 0050                   .dbend
 0050                   .dbsym e my_table _my_table A[80:20]S[vocabTable]
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _neighours_table::
 0000 00                .byte 0
 0001 000000            .byte 0,0,0
 0004 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 0040 00000000000000000000      .word 0,0,0,0,0
 004A 000000000000      .byte 0,0,0,0,0,0
 0050                   .dbsym e neighours_table _neighours_table A[80:20]S[vocabTable]
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _wElapsedTime::
 0000 0000              .word 0
 0002                   .dbsym e wElapsedTime _wElapsedTime I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000           _sortVocabTables::
 0000 00                .byte 0
 0001                   .dbsym e sortVocabTables _sortVocabTables c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\georg\OneDrive\DOCUME~1\GitHub\TALKIN~1\PDPROJ~1\PDPROJ~1\main.c
 0000                   .dbfunc e Timer16_1_ISR _Timer16_1_ISR fV
 0000           _Timer16_1_ISR::
 0000                   .dbline -1
 0000 71C0              or F,-64
 0002 08                push A
 0003 5DD0              mov A,REG[0xd0]
 0005 08                push A
 0006                   .dbline 87
 0006           ; //----------------------------------------------------------------------------
 0006           ; // C main line
 0006           ; //----------------------------------------------------------------------------
 0006           ; 
 0006           ; #include <m8c.h>        // part specific constants and macros
 0006           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0006           ; #include <stdio.h>
 0006           ; #define TEMP_SENSOR_SLAVE_ADDRESS 0x18
 0006           ; #define TEMP_REG                        0x05
 0006           ; #define MIC_ADC_CHANNEL                         0x01
 0006           ; #define LIGHT_SENSOR_ADC_CHANNEL  0x02
 0006           ; #define SIZE                                    20
 0006           ; #define X                                               1600 // 1.6s
 0006           ; #define Z                                               200  // 200ms
 0006           ; #define Z_ns                                    (Z*1000000) //ns
 0006           ; #define Z_div                                   (Z_ns/50)
 0006           ; #define Y                         200  // 200ms
 0006           ; #define Y_ns                                    (Z*1000000) //ns
 0006           ; #define Y_div                                   (Z_ns/50)
 0006           ; #define Q                         200  // Have find an optimum value
 0006           ; #define LS_NIBBLE_MASK                          0x0F
 0006           ; #define MS_NIBBLE_MASK                          0xF0
 0006           ; 
 0006           ; #define LOUD_STAMP_THRESHOLD    0x1FE
 0006           ; 
 0006           ; enum light  {DARK, NORMAL , BRIGHT};
 0006           ; enum temp   {COLD, MEDIUM, HOT};
 0006           ; enum comb   {DARK_COLD, 
 0006           ;                       DARK_MEDIUM,
 0006           ;                       DARK_HOT,
 0006           ;                       NORMAL_COLD,
 0006           ;                       NORMAL_MEDIUM,
 0006           ;                       NORMAL_HOT,
 0006           ;                       BRIGHT_COLD,
 0006           ;                       BRIGHT_MEDIUM,
 0006           ;                       BRIGHT_HOT, 
 0006           ;                       DARK_ONLY,
 0006           ;                       NORMAL_ONLY,
 0006           ;                       BRIGHT_ONLY,
 0006           ;                       COLD_ONLY,
 0006           ;                       MEDIUM_ONLY,
 0006           ;                       HOT_ONLY};
 0006           ; 
 0006           ; typedef struct vocabTable
 0006           ; {
 0006           ;       BYTE word;
 0006           ;       enum comb label;
 0006           ;       BYTE frequency;
 0006           ;       BYTE age;
 0006           ; }vocabTable_type;
 0006           ; 
 0006           ; // This is the initial default ranges that both the systems will start with
 0006           ; INT lux_range_1 = 333;
 0006           ; INT lux_range_2 = 666;
 0006           ; INT temp_range_1 = 10;
 0006           ; INT temp_range_2 =23;
 0006           ; /*
 0006           ; typedef struct learning_table
 0006           ; {
 0006           ;       BYTE    
 0006           ; }
 0006           ; */
 0006           ; 
 0006           ; vocabTable_type my_table[SIZE]= {0};          // To do: finalize on the size
 0006           ; vocabTable_type neighours_table[SIZE] = {0};// To do: finalize on the size
 0006           ; INT wElapsedTime = 0;                                                 // timer with us resolution
 0006           ; 
 0006           ; BOOL sortVocabTables = FALSE;
 0006           ; void print_LCD_debug_msg(char* msg,INT row,INT col);
 0006           ; INT readDualAdc(INT channel);
 0006           ; INT read_temperature(void);
 0006           ; float getLux(void) ;
 0006           ; BYTE create_word(float lux, INT temp, char *label,INT l1,INT l2,INT t1,INT t2);
 0006           ; void blocking_delay(BYTE bTimes);
 0006           ; BOOL update_table(BYTE word_encoding, vocabTable_type* table,char * label);
 0006           ; void quickSort(vocabTable_type A[], int l, int h);
 0006           ; int part(vocabTable_type arr[], int l, int h);
 0006           ; void swap(vocabTable_type* a, vocabTable_type* b);
 0006           ; void remove(BYTE freq_threshold,vocabTable_type* table );
 0006           ; void speak(BYTE word_encoding);
 0006           ; BYTE listen(void);
 0006           ; BOOL check_if_labelPresent(char * index);
 0006           ; BOOL check_if_bit_stream_match(char index,BYTE word_listened);
 0006           ; 
 0006           ; #pragma interrupt_handler Timer16_1_ISR
 0006           ; void Timer16_1_ISR(void )
 0006           ; {
 0006                   .dbline 88
 0006           ;               wElapsedTime++;
 0006 62D000            mov REG[0xd0],>_wElapsedTime
 0009 7601              inc [_wElapsedTime+1]
 000B 0E0000            adc [_wElapsedTime],0
 000E                   .dbline -2
 000E           L1:
 000E 18                pop A
 000F 60D0              mov REG[208],A
 0011 18                pop A
 0012                   .dbline 0 ; func end
 0012 7E                reti
 0013                   .dbend
 0013                   .dbfunc e TimerISR _TimerISR fV
 0013           _TimerISR::
 0013                   .dbline -1
 0013                   .dbline 93
 0013           ; }
 0013           ; #pragma interrupt_handler ResetSwitchISR
 0013           ; // This ISR is triffered every 60 seconds
 0013           ; void TimerISR(void )
 0013           ; {
 0013                   .dbline 94
 0013           ;       sortVocabTables = TRUE;
 0013 62D000            mov REG[0xd0],>_sortVocabTables
 0016 550001            mov [_sortVocabTables],1
 0019                   .dbline -2
 0019           L2:
 0019                   .dbline 0 ; func end
 0019 7F                ret
 001A                   .dbend
 001A                   .dbfunc e ResetSwitchISR _ResetSwitchISR fV
 001A           _ResetSwitchISR::
 001A                   .dbline -1
 001A 08                push A
 001B                   .dbline 98
 001B           ; }
 001B           ; 
 001B           ; void ResetSwitchISR(void )
 001B           ; {
 001B                   .dbline -2
 001B           L3:
 001B 18                pop A
 001C                   .dbline 0 ; func end
 001C 7E                reti
 001D                   .dbend
 001D                   .dbfunc e main _main fV
 001D           ;         neword -> X+12
 001D           ;          index -> X+10
 001D           ;          label -> X+8
 001D           ;      tempValue -> X+6
 001D           ;       luxValue -> X+2
 001D           ;  word_listened -> X+1
 001D           ;     speak_word -> X+0
 001D           _main::
 001D                   .dbline -1
 001D 10                push X
 001E 4F                mov X,SP
 001F 380D              add SP,13
 0021                   .dbline 104
 0021           ;       // Trigger a reset 
 0021           ;       // Trigger the hardware reset ISR from the software     
 0021           ; }
 0021           ; 
 0021           ; void main(void)
 0021           ; {
 0021                   .dbline 114
 0021           ;       float luxValue; // Ambient Light illumiance value
 0021           ;       INT   tempValue;     // Ambient temperature
 0021           ;       BYTE  speak_word;
 0021           ;       BYTE  word_listened;
 0021           ;       BOOL neword;
 0021           ;       char * label;
 0021           ;       char * index;
 0021           ;       
 0021           ;       // PGA1 init
 0021           ;       PGA_1_Start(PGA_1_HIGHPOWER);
 0021 10                push X
 0022 5003              mov A,3
 0024 7C0000            xcall _PGA_1_Start
 0027                   .dbline 116
 0027           ;       // PGA2 init
 0027           ;       PGA_2_Start(PGA_1_HIGHPOWER);
 0027 5003              mov A,3
 0029 7C0000            xcall _PGA_2_Start
 002C                   .dbline 119
 002C           ; 
 002C           ;       // Initial the Dual ADC
 002C           ;       DUALADC_1_Start(DUALADC_1_HIGHPOWER);           // Turn on Analog section
 002C 5003              mov A,3
 002E 7C0000            xcall _DUALADC_1_Start
 0031                   .dbline 120
 0031           ;       DUALADC_1_SetResolution(10);                    // Set resolution to 10 Bits
 0031 500A              mov A,10
 0033 7C0000            xcall _DUALADC_1_SetResolution
 0036                   .dbline 121
 0036           ;       DUALADC_1_GetSamples(0); 
 0036 5000              mov A,0
 0038 7C0000            xcall _DUALADC_1_GetSamples
 003B                   .dbline 124
 003B           ; 
 003B           ;       // Initializes LCD to use the multi-line 4-bit interface
 003B           ;       LCD_2_Start();
 003B 7C0000            xcall _LCD_2_Start
 003E                   .dbline 127
 003E           ;       
 003E           ;       // Enables the I2C HW block as a Master 
 003E           ;       I2CHW_Temp_EnableMstr();
 003E 7C0000            xcall _I2CHW_Temp_EnableMstr
 0041                   .dbline 133
 0041           ;       
 0041           ;       //Enable reset button interrupt
 0041           ;       //To do How to trigger a software reset via button?
 0041           ;       
 0041           ;       // Initialize time
 0041           ;       Timer16_1_WritePeriod(0xffff);// Do this in the config
 0041 50FF              mov A,-1
 0043 57FF              mov X,-1
 0045 7C0000            xcall _Timer16_1_WritePeriod
 0048                   .dbline 134
 0048           ;       Timer16_1_WriteCompareValue(0x0001); 
 0048 5700              mov X,0
 004A 5001              mov A,1
 004C 7C0000            xcall _Timer16_1_WriteCompareValue
 004F                   .dbline 135
 004F           ;       Timer16_1_EnableInt();//Enable Timer interrupt
 004F 7C0000            xcall _Timer16_1_EnableInt
 0052 20                pop X
 0053                   .dbline 139
 0053           ;       
 0053           ;       
 0053           ;       // Enable global interrupts
 0053           ;       M8C_EnableGInt;
 0053 7101                      or  F, 01h
 0055           
 0055                   .dbline 142
 0055           ;       
 0055           ;       // Start the timer
 0055           ;       Timer16_1_Start(); 
 0055 10                push X
 0056 7C0000            xcall _Timer16_1_Start
 0059 20                pop X
 005A 810D              xjmp L6
 005C           L5:
 005C                   .dbline 144
 005C           ;       while(1)
 005C           ;       {
 005C                   .dbline 148
 005C           ;               // Sense /////////////////////////////
 005C           ;               
 005C           ;               //Read light sensor value
 005C           ;               luxValue   = getLux(); // luxValue ranges from 0 to 1000
 005C 7C0A8E            xcall _getLux
 005F 62D000            mov REG[0xd0],>__r0
 0062 5100              mov A,[__r0]
 0064 5402              mov [X+2],A
 0066 5100              mov A,[__r1]
 0068 5403              mov [X+3],A
 006A 5100              mov A,[__r2]
 006C 5404              mov [X+4],A
 006E 5100              mov A,[__r3]
 0070 5405              mov [X+5],A
 0072                   .dbline 150
 0072           ;               //Read temperature value
 0072           ;               tempValue  = read_temperature();
 0072 7C098F            xcall _read_temperature
 0075 62D000            mov REG[0xd0],>__r0
 0078 5100              mov A,[__r1]
 007A 5407              mov [X+7],A
 007C 5100              mov A,[__r0]
 007E 5406              mov [X+6],A
 0080                   .dbline 153
 0080           ;       
 0080           ;               // Word formation //////////////////
 0080           ;               speak_word = create_word(luxValue, tempValue,label, lux_range_1,lux_range_2,temp_range_1,temp_range_2);
 0080 62D000            mov REG[0xd0],>_temp_range_2
 0083 5100              mov A,[_temp_range_2]
 0085 08                push A
 0086 5101              mov A,[_temp_range_2+1]
 0088 08                push A
 0089 62D000            mov REG[0xd0],>_temp_range_1
 008C 5100              mov A,[_temp_range_1]
 008E 08                push A
 008F 5101              mov A,[_temp_range_1+1]
 0091 08                push A
 0092 62D000            mov REG[0xd0],>_lux_range_2
 0095 5100              mov A,[_lux_range_2]
 0097 08                push A
 0098 5101              mov A,[_lux_range_2+1]
 009A 08                push A
 009B 62D000            mov REG[0xd0],>_lux_range_1
 009E 5100              mov A,[_lux_range_1]
 00A0 08                push A
 00A1 5101              mov A,[_lux_range_1+1]
 00A3 08                push A
 00A4 5208              mov A,[X+8]
 00A6 08                push A
 00A7 5209              mov A,[X+9]
 00A9 08                push A
 00AA 5206              mov A,[X+6]
 00AC 08                push A
 00AD 5207              mov A,[X+7]
 00AF 08                push A
 00B0 5202              mov A,[X+2]
 00B2 08                push A
 00B3 5203              mov A,[X+3]
 00B5 08                push A
 00B6 5204              mov A,[X+4]
 00B8 08                push A
 00B9 5205              mov A,[X+5]
 00BB 08                push A
 00BC 90B1              xcall _create_word
 00BE 62D000            mov REG[0xd0],>__r0
 00C1 5400              mov [X+0],A
 00C3                   .dbline 157
 00C3           ;               
 00C3           ;               
 00C3           ;               // Update my vocab
 00C3           ;               update_table(speak_word,my_table,label);
 00C3 5208              mov A,[X+8]
 00C5 08                push A
 00C6 5209              mov A,[X+9]
 00C8 08                push A
 00C9 5000              mov A,>_my_table
 00CB 08                push A
 00CC 5000              mov A,<_my_table
 00CE 08                push A
 00CF 5200              mov A,[X+0]
 00D1 08                push A
 00D2 947A              xcall _update_table
 00D4 38EB              add SP,-21
 00D6                   .dbline 162
 00D6           ;               
 00D6           ; 
 00D6           ;               // Sort vocab table
 00D6           ;               
 00D6           ;               if (sortVocabTables == TRUE)
 00D6 62D000            mov REG[0xd0],>_sortVocabTables
 00D9 3C0001            cmp [_sortVocabTables],1
 00DC B020              jnz L8
 00DE                   .dbline 164
 00DE           ;               {
 00DE           ;                       quickSort(my_table, 0 , SIZE-1);
 00DE                   .dbline 164
 00DE 5000              mov A,0
 00E0 08                push A
 00E1 5013              mov A,19
 00E3 08                push A
 00E4 5000              mov A,0
 00E6 08                push A
 00E7 08                push A
 00E8 5000              mov A,>_my_table
 00EA 08                push A
 00EB 5000              mov A,<_my_table
 00ED 08                push A
 00EE 976B              xcall _quickSort
 00F0                   .dbline 166
 00F0           ;                       // Remove the table entries which does not meet the required frequency threshold
 00F0           ;                       remove(Q,my_table);
 00F0 5000              mov A,>_my_table
 00F2 08                push A
 00F3 5000              mov A,<_my_table
 00F5 08                push A
 00F6 50C8              mov A,-56
 00F8 08                push A
 00F9 97DB              xcall _remove
 00FB 38F7              add SP,-9
 00FD                   .dbline 167
 00FD           ;               }
 00FD           L8:
 00FD                   .dbline 169
 00FD           ;               // Speak ///////////////////////////
 00FD           ;               if(neword)
 00FD 3D0C00            cmp [X+12],0
 0100 A009              jz L10
 0102                   .dbline 171
 0102           ;               {
 0102           ;                       speak(speak_word);
 0102                   .dbline 171
 0102 5200              mov A,[X+0]
 0104 08                push A
 0105 7C0C20            xcall _speak
 0108 38FF              add SP,-1
 010A                   .dbline 172
 010A           ;               }
 010A           L10:
 010A                   .dbline 174
 010A           ;               // Listen the bit stream from the other agent
 010A           ;               word_listened = listen();
 010A 7C0D53            xcall _listen
 010D 62D000            mov REG[0xd0],>__r0
 0110 5401              mov [X+1],A
 0112                   .dbline 186
 0112           ;               
 0112           ;               // Check if the listened word needs to be entered in the neighbour's vocab table
 0112           ;                       // Check if the received bit stream represents a light condition or temp condition or both.
 0112           ;                       // For example, if listened bit steam is 0000 1010, since the Most Significant 4 bit representing Light is zero, and Least Significant 4 bits is non zero, this means that 
 0112           ;                       // this word bit stream is represents only a temperature condition.
 0112           ;                       // If the a same word label is already present but with a different bit stream it means the sender agent have extended the word meaning
 0112           ;                       // to include a new value for temperature or light conditions. In this case, re-adjust or re learn the ranges for tempearture and light.
 0112           ;               // 
 0112           ;               // Create a word label for when the a word is received and check if there is a bit stream data available in the neighbours vocab table with the same label.
 0112           ;               // if the same label is present but the bit stream mismatches with the received bit stream , it means the other agent have extended the meaning of the word.
 0112           ;               
 0112           ;               if(check_if_labelPresent(index))
 0112 520A              mov A,[X+10]
 0114 08                push A
 0115 520B              mov A,[X+11]
 0117 08                push A
 0118 7C0E58            xcall _check_if_labelPresent
 011B 38FE              add SP,-2
 011D 62D000            mov REG[0xd0],>__r0
 0120 3900              cmp A,0
 0122 A031              jz L12
 0124                   .dbline 189
 0124           ;               {
 0124           ;                       //Check bitstream associated to the receieved word matches with the bitstream of the word which is already present in the neighbours table
 0124           ;                       if(check_if_bit_stream_match(*index,word_listened))
 0124                   .dbline 189
 0124 5201              mov A,[X+1]
 0126 08                push A
 0127 520B              mov A,[X+11]
 0129 5300              mov [__r1],A
 012B 520A              mov A,[X+10]
 012D 60D4              mov REG[0xd4],A
 012F 3E00              mvi A,[__r1]
 0131 08                push A
 0132 7C0F27            xcall _check_if_bit_stream_match
 0135 38FE              add SP,-2
 0137 62D000            mov REG[0xd0],>__r0
 013A 3900              cmp A,0
 013C A003              jz L14
 013E                   .dbline 192
 013E           ;                       {
 013E           ;                               //If bit stream matches re_learning of ranges not required. Other agent hasn't extended its meaning.
 013E           ;                       }
 013E                   .dbline 192
 013E 8029              xjmp L13
 0140           L14:
 0140                   .dbline 194
 0140           ;                       else 
 0140           ;                       {
 0140                   .dbline 197
 0140           ;                               //Bit stream doesn't match. Adjust the ranges of temp/light and generate the bitstream/word_encoding. Continue this till the bistream generated 
 0140           ;                               //matches with the received bit stream
 0140           ;                               re_learn_ranges(word_listened);
 0140 62D000            mov REG[0xd0],>__r0
 0143 5201              mov A,[X+1]
 0145 5300              mov [__r1],A
 0147 5000              mov A,0
 0149 08                push A
 014A 5100              mov A,[__r1]
 014C 08                push A
 014D 7C0F56            xcall _re_learn_ranges
 0150 38FE              add SP,-2
 0152                   .dbline 198
 0152           ;                       }
 0152                   .dbline 199
 0152           ;               }
 0152 8015              xjmp L13
 0154           L12:
 0154                   .dbline 201
 0154           ;               else
 0154           ;               {
 0154                   .dbline 203
 0154           ;                       //It is a new word. update the table with new word received.
 0154           ;                       update_table(word_listened,neighours_table,NULL);
 0154 5000              mov A,0
 0156 08                push A
 0157 08                push A
 0158 5000              mov A,>_neighours_table
 015A 08                push A
 015B 5000              mov A,<_neighours_table
 015D 08                push A
 015E 5201              mov A,[X+1]
 0160 08                push A
 0161 93EB              xcall _update_table
 0163 38FB              add SP,-5
 0165 62D000            mov REG[0xd0],>__r0
 0168                   .dbline 204
 0168           ;               }
 0168           L13:
 0168                   .dbline 216
 0168           ;               
 0168           ;               /*
 0168           ;               //Used for bayesian word prediction when mode == Different environment.
 0168           ;               update_freqency_table();
 0168           ;               
 0168           ;               //-----------------Decesion Making---------------------------
 0168           ;               if( mode == SAME_ENVIRONMENT)
 0168           ;               //Use sensor values of the agent to predict the meaning of the word received
 0168           ;                       
 0168           ;               if( mode == DIFFERENT_ENVIRONMENT)
 0168           ;               //Use bayesian table to predict the meaning of the word associated to the received bit stream   */
 0168           ;       }
 0168           L6:
 0168                   .dbline 143
 0168 8EF3              xjmp L5
 016A           X0:
 016A                   .dbline -2
 016A           L4:
 016A 38F3              add SP,-13
 016C 20                pop X
 016D                   .dbline 0 ; func end
 016D 8FFF              jmp .
 016F                   .dbsym l neword 12 c
 016F                   .dbsym l index 10 pc
 016F                   .dbsym l label 8 pc
 016F                   .dbsym l tempValue 6 I
 016F                   .dbsym l luxValue 2 D
 016F                   .dbsym l word_listened 1 c
 016F                   .dbsym l speak_word 0 c
 016F                   .dbend
 016F                   .dbfunc e create_word _create_word fc
 016F           ;     bit_stream -> X+2
 016F           ;     temp_label -> X+1
 016F           ;    light_label -> X+0
 016F           ;             t2 -> X-19
 016F           ;             t1 -> X-17
 016F           ;             l2 -> X-15
 016F           ;             l1 -> X-13
 016F           ;          label -> X-11
 016F           ;           temp -> X-9
 016F           ;            lux -> X-7
 016F           _create_word::
 016F                   .dbline -1
 016F 10                push X
 0170 4F                mov X,SP
 0171 3803              add SP,3
 0173                   .dbline 220
 0173           ; }
 0173           ; 
 0173           ; BYTE create_word(float lux, INT temp, char *label,INT l1,INT l2,INT t1,INT t2)
 0173           ; {
 0173                   .dbline 225
 0173           ;       enum light light_label;
 0173           ;       enum temp temp_label;
 0173           ;       BYTE bit_stream;
 0173           ;       
 0173           ;       if (lux >= 0 && lux < l1)
 0173 5000              mov A,0
 0175 08                push A
 0176 08                push A
 0177 08                push A
 0178 08                push A
 0179 52F9              mov A,[X-7]
 017B 08                push A
 017C 52FA              mov A,[X-6]
 017E 08                push A
 017F 52FB              mov A,[X-5]
 0181 08                push A
 0182 52FC              mov A,[X-4]
 0184 08                push A
 0185 62D000            mov REG[0xd0],>__r0
 0188 7C0000            xcall __fpcmp
 018B 38F8              add SP,-8
 018D 39FF              cmp A,-1
 018F A063              jz L17
 0191 52F4              mov A,[X-12]
 0193 5300              mov [__r3],A
 0195 52F3              mov A,[X-13]
 0197 5300              mov [__r2],A
 0199 470080            tst [__r2],-128
 019C A009              jz X2
 019E 5500FF            mov [__r1],-1
 01A1 5500FF            mov [__r0],-1
 01A4 800A              jmp X3
 01A6           X2:
 01A6 62D000            mov REG[0xd0],>__r0
 01A9 550000            mov [__r1],0
 01AC 550000            mov [__r0],0
 01AF           X3:
 01AF 62D000            mov REG[0xd0],>__r0
 01B2 5100              mov A,[__r0]
 01B4 08                push A
 01B5 5100              mov A,[__r1]
 01B7 08                push A
 01B8 5100              mov A,[__r2]
 01BA 08                push A
 01BB 5100              mov A,[__r3]
 01BD 08                push A
 01BE 7C0000            xcall __long2fp
 01C1 18                pop A
 01C2 5300              mov [__r3],A
 01C4 18                pop A
 01C5 5300              mov [__r2],A
 01C7 18                pop A
 01C8 5300              mov [__r1],A
 01CA 18                pop A
 01CB 08                push A
 01CC 5100              mov A,[__r1]
 01CE 08                push A
 01CF 5100              mov A,[__r2]
 01D1 08                push A
 01D2 5100              mov A,[__r3]
 01D4 08                push A
 01D5 52F9              mov A,[X-7]
 01D7 08                push A
 01D8 52FA              mov A,[X-6]
 01DA 08                push A
 01DB 52FB              mov A,[X-5]
 01DD 08                push A
 01DE 52FC              mov A,[X-4]
 01E0 08                push A
 01E1 7C0000            xcall __fpcmp
 01E4 38F8              add SP,-8
 01E6 3900              cmp A,0
 01E8 A00A              jz L17
 01EA 3901              cmp A,1
 01EC A006              jz L17
 01EE                   .dbline 226
 01EE           ;               light_label = DARK;
 01EE 560000            mov [X+0],0
 01F1 813D              xjmp L18
 01F3           L17:
 01F3                   .dbline 227
 01F3           ;       else if(lux >= l1 && lux < l2)
 01F3 62D000            mov REG[0xd0],>__r0
 01F6 52F4              mov A,[X-12]
 01F8 5300              mov [__r3],A
 01FA 52F3              mov A,[X-13]
 01FC 5300              mov [__r2],A
 01FE 470080            tst [__r2],-128
 0201 A009              jz X5
 0203 5500FF            mov [__r1],-1
 0206 5500FF            mov [__r0],-1
 0209 800A              jmp X6
 020B           X5:
 020B 62D000            mov REG[0xd0],>__r0
 020E 550000            mov [__r1],0
 0211 550000            mov [__r0],0
 0214           X6:
 0214 62D000            mov REG[0xd0],>__r0
 0217 5100              mov A,[__r0]
 0219 08                push A
 021A 5100              mov A,[__r1]
 021C 08                push A
 021D 5100              mov A,[__r2]
 021F 08                push A
 0220 5100              mov A,[__r3]
 0222 08                push A
 0223 7C0000            xcall __long2fp
 0226 18                pop A
 0227 5300              mov [__r3],A
 0229 18                pop A
 022A 5300              mov [__r2],A
 022C 18                pop A
 022D 5300              mov [__r1],A
 022F 18                pop A
 0230 08                push A
 0231 5100              mov A,[__r1]
 0233 08                push A
 0234 5100              mov A,[__r2]
 0236 08                push A
 0237 5100              mov A,[__r3]
 0239 08                push A
 023A 52F9              mov A,[X-7]
 023C 08                push A
 023D 52FA              mov A,[X-6]
 023F 08                push A
 0240 52FB              mov A,[X-5]
 0242 08                push A
 0243 52FC              mov A,[X-4]
 0245 08                push A
 0246 7C0000            xcall __fpcmp
 0249 38F8              add SP,-8
 024B 39FF              cmp A,-1
 024D A063              jz L19
 024F 52F2              mov A,[X-14]
 0251 5300              mov [__r3],A
 0253 52F1              mov A,[X-15]
 0255 5300              mov [__r2],A
 0257 470080            tst [__r2],-128
 025A A009              jz X8
 025C 5500FF            mov [__r1],-1
 025F 5500FF            mov [__r0],-1
 0262 800A              jmp X9
 0264           X8:
 0264 62D000            mov REG[0xd0],>__r0
 0267 550000            mov [__r1],0
 026A 550000            mov [__r0],0
 026D           X9:
 026D 62D000            mov REG[0xd0],>__r0
 0270 5100              mov A,[__r0]
 0272 08                push A
 0273 5100              mov A,[__r1]
 0275 08                push A
 0276 5100              mov A,[__r2]
 0278 08                push A
 0279 5100              mov A,[__r3]
 027B 08                push A
 027C 7C0000            xcall __long2fp
 027F 18                pop A
 0280 5300              mov [__r3],A
 0282 18                pop A
 0283 5300              mov [__r2],A
 0285 18                pop A
 0286 5300              mov [__r1],A
 0288 18                pop A
 0289 08                push A
 028A 5100              mov A,[__r1]
 028C 08                push A
 028D 5100              mov A,[__r2]
 028F 08                push A
 0290 5100              mov A,[__r3]
 0292 08                push A
 0293 52F9              mov A,[X-7]
 0295 08                push A
 0296 52FA              mov A,[X-6]
 0298 08                push A
 0299 52FB              mov A,[X-5]
 029B 08                push A
 029C 52FC              mov A,[X-4]
 029E 08                push A
 029F 7C0000            xcall __fpcmp
 02A2 38F8              add SP,-8
 02A4 3900              cmp A,0
 02A6 A00A              jz L19
 02A8 3901              cmp A,1
 02AA A006              jz L19
 02AC                   .dbline 228
 02AC           ;               light_label = NORMAL;
 02AC 560001            mov [X+0],1
 02AF 807F              xjmp L20
 02B1           L19:
 02B1                   .dbline 229
 02B1           ;       else if(lux >=l2 && lux <=1000)
 02B1 62D000            mov REG[0xd0],>__r0
 02B4 52F2              mov A,[X-14]
 02B6 5300              mov [__r3],A
 02B8 52F1              mov A,[X-15]
 02BA 5300              mov [__r2],A
 02BC 470080            tst [__r2],-128
 02BF A009              jz X11
 02C1 5500FF            mov [__r1],-1
 02C4 5500FF            mov [__r0],-1
 02C7 800A              jmp X12
 02C9           X11:
 02C9 62D000            mov REG[0xd0],>__r0
 02CC 550000            mov [__r1],0
 02CF 550000            mov [__r0],0
 02D2           X12:
 02D2 62D000            mov REG[0xd0],>__r0
 02D5 5100              mov A,[__r0]
 02D7 08                push A
 02D8 5100              mov A,[__r1]
 02DA 08                push A
 02DB 5100              mov A,[__r2]
 02DD 08                push A
 02DE 5100              mov A,[__r3]
 02E0 08                push A
 02E1 7C0000            xcall __long2fp
 02E4 18                pop A
 02E5 5300              mov [__r3],A
 02E7 18                pop A
 02E8 5300              mov [__r2],A
 02EA 18                pop A
 02EB 5300              mov [__r1],A
 02ED 18                pop A
 02EE 08                push A
 02EF 5100              mov A,[__r1]
 02F1 08                push A
 02F2 5100              mov A,[__r2]
 02F4 08                push A
 02F5 5100              mov A,[__r3]
 02F7 08                push A
 02F8 52F9              mov A,[X-7]
 02FA 08                push A
 02FB 52FA              mov A,[X-6]
 02FD 08                push A
 02FE 52FB              mov A,[X-5]
 0300 08                push A
 0301 52FC              mov A,[X-4]
 0303 08                push A
 0304 7C0000            xcall __fpcmp
 0307 38F8              add SP,-8
 0309 39FF              cmp A,-1
 030B A023              jz L21
 030D 5044              mov A,68
 030F 08                push A
 0310 507A              mov A,122
 0312 08                push A
 0313 5000              mov A,0
 0315 08                push A
 0316 08                push A
 0317 52F9              mov A,[X-7]
 0319 08                push A
 031A 52FA              mov A,[X-6]
 031C 08                push A
 031D 52FB              mov A,[X-5]
 031F 08                push A
 0320 52FC              mov A,[X-4]
 0322 08                push A
 0323 7C0000            xcall __fpcmp
 0326 38F8              add SP,-8
 0328 3901              cmp A,1
 032A A004              jz L21
 032C                   .dbline 230
 032C           ;               light_label = BRIGHT;
 032C 560002            mov [X+0],2
 032F           L21:
 032F           L20:
 032F           L18:
 032F                   .dbline 233
 032F           ;       
 032F           ;       // Check this
 032F           ;       if (temp < t1)
 032F 52F8              mov A,[X-8]
 0331 13F0              sub A,[X-16]
 0333 52EF              mov A,[X-17]
 0335 3180              xor A,-128
 0337 62D000            mov REG[0xd0],>__r0
 033A 5300              mov [__rX],A
 033C 52F7              mov A,[X-9]
 033E 3180              xor A,-128
 0340 1A00              sbb A,[__rX]
 0342 D006              jnc L23
 0344           X15:
 0344                   .dbline 234
 0344           ;               temp_label = COLD;
 0344 560100            mov [X+1],0
 0347 8048              xjmp L24
 0349           L23:
 0349                   .dbline 235
 0349           ;       else if(temp >=t1 && temp < t2)
 0349 52F8              mov A,[X-8]
 034B 13F0              sub A,[X-16]
 034D 52EF              mov A,[X-17]
 034F 3180              xor A,-128
 0351 62D000            mov REG[0xd0],>__r0
 0354 5300              mov [__rX],A
 0356 52F7              mov A,[X-9]
 0358 3180              xor A,-128
 035A 1A00              sbb A,[__rX]
 035C C01B              jc L25
 035E           X16:
 035E 52F8              mov A,[X-8]
 0360 13EE              sub A,[X-18]
 0362 52ED              mov A,[X-19]
 0364 3180              xor A,-128
 0366 62D000            mov REG[0xd0],>__r0
 0369 5300              mov [__rX],A
 036B 52F7              mov A,[X-9]
 036D 3180              xor A,-128
 036F 1A00              sbb A,[__rX]
 0371 D006              jnc L25
 0373           X17:
 0373                   .dbline 236
 0373           ;               temp_label = MEDIUM;
 0373 560101            mov [X+1],1
 0376 8019              xjmp L26
 0378           L25:
 0378                   .dbline 237
 0378           ;       else if(temp >= t2)
 0378 52F8              mov A,[X-8]
 037A 13EE              sub A,[X-18]
 037C 52ED              mov A,[X-19]
 037E 3180              xor A,-128
 0380 62D000            mov REG[0xd0],>__r0
 0383 5300              mov [__rX],A
 0385 52F7              mov A,[X-9]
 0387 3180              xor A,-128
 0389 1A00              sbb A,[__rX]
 038B C004              jc L27
 038D           X18:
 038D                   .dbline 238
 038D           ;               temp_label = HOT;
 038D 560102            mov [X+1],2
 0390           L27:
 0390           L26:
 0390           L24:
 0390                   .dbline 240
 0390           ;       
 0390           ;       if (light_label == DARK && temp_label == COLD)
 0390 3D0000            cmp [X+0],0
 0393 B02B              jnz L29
 0395 3D0100            cmp [X+1],0
 0398 B026              jnz L29
 039A                   .dbline 242
 039A           ;       {       
 039A           ;               bit_stream = 0xa9;//Bit stream : 1010 1001 | Dark light and Cold condition
 039A                   .dbline 242
 039A 5602A9            mov [X+2],-87
 039D                   .dbline 243
 039D           ;               *label = DARK_COLD;
 039D 62D000            mov REG[0xd0],>__r0
 03A0 52F6              mov A,[X-10]
 03A2 5300              mov [__r1],A
 03A4 52F5              mov A,[X-11]
 03A6 60D5              mov REG[0xd5],A
 03A8 5000              mov A,0
 03AA 3F00              mvi [__r1],A
 03AC                   .dbline 244
 03AC           ;               LCD_2_Position(0,0);
 03AC 10                push X
 03AD 5700              mov X,0
 03AF 7C0000            xcall _LCD_2_Position
 03B2                   .dbline 245
 03B2           ;               LCD_2_PrCString("Word Generated is: DARK COLD");
 03B2 50F7              mov A,>L31
 03B4 08                push A
 03B5 50F7              mov A,<L31
 03B7 5C                mov X,A
 03B8 18                pop A
 03B9 7C0000            xcall _LCD_2_PrCString
 03BC 20                pop X
 03BD                   .dbline 246
 03BD           ;       }
 03BD 8187              xjmp L30
 03BF           L29:
 03BF                   .dbline 247
 03BF           ;       else if (light_label == DARK && temp_label == MEDIUM)
 03BF 3D0000            cmp [X+0],0
 03C2 B02D              jnz L32
 03C4 3D0101            cmp [X+1],1
 03C7 B028              jnz L32
 03C9                   .dbline 249
 03C9           ;       {
 03C9           ;               bit_stream = 0xaa; //Bit stream : 1010 1010 |  Dark light and Medium temp condition
 03C9                   .dbline 249
 03C9 5602AA            mov [X+2],-86
 03CC                   .dbline 250
 03CC           ;               *label = DARK_MEDIUM;
 03CC 62D000            mov REG[0xd0],>__r0
 03CF 52F6              mov A,[X-10]
 03D1 5300              mov [__r1],A
 03D3 52F5              mov A,[X-11]
 03D5 60D5              mov REG[0xd5],A
 03D7 5001              mov A,1
 03D9 3F00              mvi [__r1],A
 03DB                   .dbline 251
 03DB           ;               LCD_2_Position(0,0);
 03DB 10                push X
 03DC 5000              mov A,0
 03DE 5700              mov X,0
 03E0 7C0000            xcall _LCD_2_Position
 03E3                   .dbline 252
 03E3           ;               LCD_2_PrCString("Word Generated is: DARK MEDIUM");
 03E3 50D8              mov A,>L34
 03E5 08                push A
 03E6 50D8              mov A,<L34
 03E8 5C                mov X,A
 03E9 18                pop A
 03EA 7C0000            xcall _LCD_2_PrCString
 03ED 20                pop X
 03EE                   .dbline 253
 03EE           ;       }
 03EE 8156              xjmp L33
 03F0           L32:
 03F0                   .dbline 254
 03F0           ;       else if (light_label == DARK && temp_label == HOT)
 03F0 3D0000            cmp [X+0],0
 03F3 B02D              jnz L35
 03F5 3D0102            cmp [X+1],2
 03F8 B028              jnz L35
 03FA                   .dbline 256
 03FA           ;       {
 03FA           ;               bit_stream = 0xa8;//Bit stream : 1010 1000 | Dark light and Hot temp condition
 03FA                   .dbline 256
 03FA 5602A8            mov [X+2],-88
 03FD                   .dbline 257
 03FD           ;               *label = DARK_HOT;
 03FD 62D000            mov REG[0xd0],>__r0
 0400 52F6              mov A,[X-10]
 0402 5300              mov [__r1],A
 0404 52F5              mov A,[X-11]
 0406 60D5              mov REG[0xd5],A
 0408 5002              mov A,2
 040A 3F00              mvi [__r1],A
 040C                   .dbline 258
 040C           ;               LCD_2_Position(0,0);
 040C 10                push X
 040D 5000              mov A,0
 040F 5700              mov X,0
 0411 7C0000            xcall _LCD_2_Position
 0414                   .dbline 259
 0414           ;               LCD_2_PrCString("Word Generated is: DARK HOT");
 0414 50BC              mov A,>L37
 0416 08                push A
 0417 50BC              mov A,<L37
 0419 5C                mov X,A
 041A 18                pop A
 041B 7C0000            xcall _LCD_2_PrCString
 041E 20                pop X
 041F                   .dbline 260
 041F           ;       }
 041F 8125              xjmp L36
 0421           L35:
 0421                   .dbline 261
 0421           ;       else if (light_label == NORMAL && temp_label == COLD)
 0421 3D0001            cmp [X+0],1
 0424 B02D              jnz L38
 0426 3D0100            cmp [X+1],0
 0429 B028              jnz L38
 042B                   .dbline 263
 042B           ;       {
 042B           ;               bit_stream = 0x89; //Bit stream : 1000 1001 | Normal light and cold temp condition
 042B                   .dbline 263
 042B 560289            mov [X+2],-119
 042E                   .dbline 264
 042E           ;               *label = NORMAL_COLD;
 042E 62D000            mov REG[0xd0],>__r0
 0431 52F6              mov A,[X-10]
 0433 5300              mov [__r1],A
 0435 52F5              mov A,[X-11]
 0437 60D5              mov REG[0xd5],A
 0439 5003              mov A,3
 043B 3F00              mvi [__r1],A
 043D                   .dbline 265
 043D           ;               LCD_2_Position(0,0);
 043D 10                push X
 043E 5000              mov A,0
 0440 5700              mov X,0
 0442 7C0000            xcall _LCD_2_Position
 0445                   .dbline 266
 0445           ;               LCD_2_PrCString("Word Generated is: NORMAL COLD");
 0445 509D              mov A,>L40
 0447 08                push A
 0448 509D              mov A,<L40
 044A 5C                mov X,A
 044B 18                pop A
 044C 7C0000            xcall _LCD_2_PrCString
 044F 20                pop X
 0450                   .dbline 267
 0450           ;       }
 0450 80F4              xjmp L39
 0452           L38:
 0452                   .dbline 268
 0452           ;       else if (light_label == NORMAL && temp_label == MEDIUM)
 0452 3D0001            cmp [X+0],1
 0455 B02D              jnz L41
 0457 3D0101            cmp [X+1],1
 045A B028              jnz L41
 045C                   .dbline 270
 045C           ;       {
 045C           ;               bit_stream = 0x8a; //Bit stream : 1000 1010 | Normal light and medium temp condition
 045C                   .dbline 270
 045C 56028A            mov [X+2],-118
 045F                   .dbline 271
 045F           ;               *label = NORMAL_MEDIUM;
 045F 62D000            mov REG[0xd0],>__r0
 0462 52F6              mov A,[X-10]
 0464 5300              mov [__r1],A
 0466 52F5              mov A,[X-11]
 0468 60D5              mov REG[0xd5],A
 046A 5004              mov A,4
 046C 3F00              mvi [__r1],A
 046E                   .dbline 272
 046E           ;               LCD_2_Position(0,0);
 046E 10                push X
 046F 5000              mov A,0
 0471 5700              mov X,0
 0473 7C0000            xcall _LCD_2_Position
 0476                   .dbline 273
 0476           ;               LCD_2_PrCString("Word Generated is: NORMAL MEDIUM");
 0476 507C              mov A,>L43
 0478 08                push A
 0479 507C              mov A,<L43
 047B 5C                mov X,A
 047C 18                pop A
 047D 7C0000            xcall _LCD_2_PrCString
 0480 20                pop X
 0481                   .dbline 274
 0481           ;       }
 0481 80C3              xjmp L42
 0483           L41:
 0483                   .dbline 275
 0483           ;       else if (light_label == NORMAL && temp_label == HOT)
 0483 3D0001            cmp [X+0],1
 0486 B02D              jnz L44
 0488 3D0102            cmp [X+1],2
 048B B028              jnz L44
 048D                   .dbline 277
 048D           ;       {
 048D           ;               bit_stream = 0x88; //Bit stream : 1000 1000 | Normal light and hot temp condition
 048D                   .dbline 277
 048D 560288            mov [X+2],-120
 0490                   .dbline 278
 0490           ;               *label = NORMAL_HOT;
 0490 62D000            mov REG[0xd0],>__r0
 0493 52F6              mov A,[X-10]
 0495 5300              mov [__r1],A
 0497 52F5              mov A,[X-11]
 0499 60D5              mov REG[0xd5],A
 049B 5005              mov A,5
 049D 3F00              mvi [__r1],A
 049F                   .dbline 279
 049F           ;               LCD_2_Position(0,0);
 049F 10                push X
 04A0 5000              mov A,0
 04A2 5700              mov X,0
 04A4 7C0000            xcall _LCD_2_Position
 04A7                   .dbline 280
 04A7           ;               LCD_2_PrCString("Word Generated is: NORMAL HOT");
 04A7 505E              mov A,>L46
 04A9 08                push A
 04AA 505E              mov A,<L46
 04AC 5C                mov X,A
 04AD 18                pop A
 04AE 7C0000            xcall _LCD_2_PrCString
 04B1 20                pop X
 04B2                   .dbline 281
 04B2           ;       }
 04B2 8092              xjmp L45
 04B4           L44:
 04B4                   .dbline 282
 04B4           ;       else if (light_label == BRIGHT && temp_label == COLD)
 04B4 3D0002            cmp [X+0],2
 04B7 B02D              jnz L47
 04B9 3D0100            cmp [X+1],0
 04BC B028              jnz L47
 04BE                   .dbline 284
 04BE           ;       {
 04BE           ;               bit_stream = 0x49; //Bit stream : 01001001 | Bright light and cold temp condition
 04BE                   .dbline 284
 04BE 560249            mov [X+2],73
 04C1                   .dbline 285
 04C1           ;               *label = BRIGHT_COLD;
 04C1 62D000            mov REG[0xd0],>__r0
 04C4 52F6              mov A,[X-10]
 04C6 5300              mov [__r1],A
 04C8 52F5              mov A,[X-11]
 04CA 60D5              mov REG[0xd5],A
 04CC 5006              mov A,6
 04CE 3F00              mvi [__r1],A
 04D0                   .dbline 286
 04D0           ;               LCD_2_Position(0,0);
 04D0 10                push X
 04D1 5000              mov A,0
 04D3 5700              mov X,0
 04D5 7C0000            xcall _LCD_2_Position
 04D8                   .dbline 287
 04D8           ;               LCD_2_PrCString("Word Generated is: BRIGHT COLD");
 04D8 503F              mov A,>L49
 04DA 08                push A
 04DB 503F              mov A,<L49
 04DD 5C                mov X,A
 04DE 18                pop A
 04DF 7C0000            xcall _LCD_2_PrCString
 04E2 20                pop X
 04E3                   .dbline 288
 04E3           ;       }
 04E3 8061              xjmp L48
 04E5           L47:
 04E5                   .dbline 289
 04E5           ;       else if (light_label == BRIGHT && temp_label == MEDIUM)
 04E5 3D0002            cmp [X+0],2
 04E8 B02D              jnz L50
 04EA 3D0101            cmp [X+1],1
 04ED B028              jnz L50
 04EF                   .dbline 291
 04EF           ;       {
 04EF           ;               bit_stream = 0x4a; //Bit stream : 01001010 | Bright light and medium temp condition
 04EF                   .dbline 291
 04EF 56024A            mov [X+2],74
 04F2                   .dbline 292
 04F2           ;               *label = BRIGHT_MEDIUM;
 04F2 62D000            mov REG[0xd0],>__r0
 04F5 52F6              mov A,[X-10]
 04F7 5300              mov [__r1],A
 04F9 52F5              mov A,[X-11]
 04FB 60D5              mov REG[0xd5],A
 04FD 5007              mov A,7
 04FF 3F00              mvi [__r1],A
 0501                   .dbline 293
 0501           ;               LCD_2_Position(0,0);
 0501 10                push X
 0502 5000              mov A,0
 0504 5700              mov X,0
 0506 7C0000            xcall _LCD_2_Position
 0509                   .dbline 294
 0509           ;               LCD_2_PrCString("Word Generated is: BRIGHT MEDIUM");
 0509 501E              mov A,>L52
 050B 08                push A
 050C 501E              mov A,<L52
 050E 5C                mov X,A
 050F 18                pop A
 0510 7C0000            xcall _LCD_2_PrCString
 0513 20                pop X
 0514                   .dbline 295
 0514           ;       }
 0514 8030              xjmp L51
 0516           L50:
 0516                   .dbline 296
 0516           ;       else if (light_label == BRIGHT && temp_label == HOT)
 0516 3D0002            cmp [X+0],2
 0519 B02B              jnz L53
 051B 3D0102            cmp [X+1],2
 051E B026              jnz L53
 0520                   .dbline 298
 0520           ;       {
 0520           ;               bit_stream = 0x48; //Bit stream : 01001000 | Bright light and hot temp condition
 0520                   .dbline 298
 0520 560248            mov [X+2],72
 0523                   .dbline 299
 0523           ;               *label = BRIGHT_HOT;
 0523 62D000            mov REG[0xd0],>__r0
 0526 52F6              mov A,[X-10]
 0528 5300              mov [__r1],A
 052A 52F5              mov A,[X-11]
 052C 60D5              mov REG[0xd5],A
 052E 5008              mov A,8
 0530 3F00              mvi [__r1],A
 0532                   .dbline 300
 0532           ;               LCD_2_Position(0,0);
 0532 10                push X
 0533 5000              mov A,0
 0535 5700              mov X,0
 0537 7C0000            xcall _LCD_2_Position
 053A                   .dbline 301
 053A           ;               LCD_2_PrCString("Word Generated is: BRIGHT HOT");
 053A 5000              mov A,>L55
 053C 08                push A
 053D 5000              mov A,<L55
 053F 5C                mov X,A
 0540 18                pop A
 0541 7C0000            xcall _LCD_2_PrCString
 0544 20                pop X
 0545                   .dbline 302
 0545           ;       }
 0545           L53:
 0545           L51:
 0545           L48:
 0545           L45:
 0545           L42:
 0545           L39:
 0545           L36:
 0545           L33:
 0545           L30:
 0545                   .dbline 303
 0545           ;       return bit_stream;// return word encoding
 0545 5202              mov A,[X+2]
 0547 62D000            mov REG[0xd0],>__r0
 054A                   .dbline -2
 054A           L16:
 054A 38FD              add SP,-3
 054C 20                pop X
 054D                   .dbline 0 ; func end
 054D 7F                ret
 054E                   .dbsym l bit_stream 2 c
 054E                   .dbsym l temp_label 1 c
 054E                   .dbsym l light_label 0 c
 054E                   .dbsym l t2 -19 I
 054E                   .dbsym l t1 -17 I
 054E                   .dbsym l l2 -15 I
 054E                   .dbsym l l1 -13 I
 054E                   .dbsym l label -11 pc
 054E                   .dbsym l temp -9 I
 054E                   .dbsym l lux -7 D
 054E                   .dbend
 054E                   .dbfunc e update_table _update_table fc
 054E           ;          found -> X+2
 054E           ;              i -> X+0
 054E           ;          label -> X-8
 054E           ;          table -> X-6
 054E           ;  word_encoding -> X-4
 054E           _update_table::
 054E                   .dbline -1
 054E 10                push X
 054F 4F                mov X,SP
 0550 3803              add SP,3
 0552                   .dbline 308
 0552           ; }
 0552           ; 
 0552           ; 
 0552           ; BOOL update_table(BYTE word_encoding, vocabTable_type* table, char * label)
 0552           ; {
 0552                   .dbline 310
 0552           ;       int i;
 0552           ;       BOOL found = FALSE;
 0552 560200            mov [X+2],0
 0555                   .dbline 311
 0555           ;       for (i= 0; i< SIZE; i++)
 0555 560100            mov [X+1],0
 0558 560000            mov [X+0],0
 055B           L57:
 055B                   .dbline 312
 055B           ;       {
 055B                   .dbline 313
 055B           ;               table[i].age++;
 055B 62D000            mov REG[0xd0],>__r0
 055E 5201              mov A,[X+1]
 0560 5300              mov [__r1],A
 0562 5200              mov A,[X+0]
 0564 5300              mov [__r0],A
 0566 6500              asl [__r1]
 0568 6B00              rlc [__r0]
 056A 6500              asl [__r1]
 056C 6B00              rlc [__r0]
 056E 52FB              mov A,[X-5]
 0570 0400              add [__r1],A
 0572 52FA              mov A,[X-6]
 0574 0C00              adc [__r0],A
 0576 060003            add [__r1],3
 0579 0E0000            adc [__r0],0
 057C 5100              mov A,[__r0]
 057E 60D4              mov REG[0xd4],A
 0580 3E00              mvi A,[__r1]
 0582 7A00              dec [__r1]
 0584 5300              mov [__r2],A
 0586 060001            add [__r2],1
 0589 5100              mov A,[__r0]
 058B 60D5              mov REG[0xd5],A
 058D 5100              mov A,[__r2]
 058F 3F00              mvi [__r1],A
 0591                   .dbline 314
 0591           ;               if (table[i].word == word_encoding)
 0591 5201              mov A,[X+1]
 0593 5300              mov [__r1],A
 0595 5200              mov A,[X+0]
 0597 5300              mov [__r0],A
 0599 6500              asl [__r1]
 059B 6B00              rlc [__r0]
 059D 6500              asl [__r1]
 059F 6B00              rlc [__r0]
 05A1 52FB              mov A,[X-5]
 05A3 0400              add [__r1],A
 05A5 52FA              mov A,[X-6]
 05A7 0C00              adc [__r0],A
 05A9 5100              mov A,[__r0]
 05AB 60D4              mov REG[0xd4],A
 05AD 3E00              mvi A,[__r1]
 05AF 3BFC              cmp A,[X-4]
 05B1 B037              jnz L61
 05B3                   .dbline 316
 05B3           ;               {
 05B3           ;                       found =TRUE;
 05B3                   .dbline 316
 05B3 560201            mov [X+2],1
 05B6                   .dbline 317
 05B6           ;                       table[i].frequency++;
 05B6 5201              mov A,[X+1]
 05B8 5300              mov [__r1],A
 05BA 5200              mov A,[X+0]
 05BC 5300              mov [__r0],A
 05BE 6500              asl [__r1]
 05C0 6B00              rlc [__r0]
 05C2 6500              asl [__r1]
 05C4 6B00              rlc [__r0]
 05C6 52FB              mov A,[X-5]
 05C8 0400              add [__r1],A
 05CA 52FA              mov A,[X-6]
 05CC 0C00              adc [__r0],A
 05CE 060002            add [__r1],2
 05D1 0E0000            adc [__r0],0
 05D4 5100              mov A,[__r0]
 05D6 60D4              mov REG[0xd4],A
 05D8 3E00              mvi A,[__r1]
 05DA 7A00              dec [__r1]
 05DC 5300              mov [__r2],A
 05DE 060001            add [__r2],1
 05E1 5100              mov A,[__r0]
 05E3 60D5              mov REG[0xd5],A
 05E5 5100              mov A,[__r2]
 05E7 3F00              mvi [__r1],A
 05E9                   .dbline 318
 05E9           ;               }
 05E9           L61:
 05E9                   .dbline 319
 05E9           ;       }
 05E9           L58:
 05E9                   .dbline 311
 05E9 7701              inc [X+1]
 05EB 0F0000            adc [X+0],0
 05EE                   .dbline 311
 05EE 5201              mov A,[X+1]
 05F0 1114              sub A,20
 05F2 5200              mov A,[X+0]
 05F4 3180              xor A,-128
 05F6 1980              sbb A,(0 ^ 0x80)
 05F8 CF62              jc L57
 05FA           X19:
 05FA                   .dbline 320
 05FA           ;       if (found == FALSE)
 05FA 3D0200            cmp [X+2],0
 05FD B0A2              jnz L63
 05FF                   .dbline 322
 05FF           ;       {       
 05FF           ;               table[i].word = word_encoding;
 05FF                   .dbline 322
 05FF 62D000            mov REG[0xd0],>__r0
 0602 5201              mov A,[X+1]
 0604 5300              mov [__r1],A
 0606 5200              mov A,[X+0]
 0608 5300              mov [__r0],A
 060A 6500              asl [__r1]
 060C 6B00              rlc [__r0]
 060E 6500              asl [__r1]
 0610 6B00              rlc [__r0]
 0612 52FB              mov A,[X-5]
 0614 0400              add [__r1],A
 0616 52FA              mov A,[X-6]
 0618 0C00              adc [__r0],A
 061A 5100              mov A,[__r0]
 061C 60D5              mov REG[0xd5],A
 061E 52FC              mov A,[X-4]
 0620 3F00              mvi [__r1],A
 0622                   .dbline 323
 0622           ;               table[i].frequency = 1;
 0622 5201              mov A,[X+1]
 0624 5300              mov [__r1],A
 0626 5200              mov A,[X+0]
 0628 5300              mov [__r0],A
 062A 6500              asl [__r1]
 062C 6B00              rlc [__r0]
 062E 6500              asl [__r1]
 0630 6B00              rlc [__r0]
 0632 52FB              mov A,[X-5]
 0634 0400              add [__r1],A
 0636 52FA              mov A,[X-6]
 0638 0C00              adc [__r0],A
 063A 060002            add [__r1],2
 063D 0E0000            adc [__r0],0
 0640 5100              mov A,[__r0]
 0642 60D5              mov REG[0xd5],A
 0644 5001              mov A,1
 0646 3F00              mvi [__r1],A
 0648                   .dbline 324
 0648           ;               table[i].age = 1;
 0648 5201              mov A,[X+1]
 064A 5300              mov [__r1],A
 064C 5200              mov A,[X+0]
 064E 5300              mov [__r0],A
 0650 6500              asl [__r1]
 0652 6B00              rlc [__r0]
 0654 6500              asl [__r1]
 0656 6B00              rlc [__r0]
 0658 52FB              mov A,[X-5]
 065A 0400              add [__r1],A
 065C 52FA              mov A,[X-6]
 065E 0C00              adc [__r0],A
 0660 060003            add [__r1],3
 0663 0E0000            adc [__r0],0
 0666 5100              mov A,[__r0]
 0668 60D5              mov REG[0xd5],A
 066A 5001              mov A,1
 066C 3F00              mvi [__r1],A
 066E                   .dbline 325
 066E           ;               table[i].label = *label;
 066E 52F9              mov A,[X-7]
 0670 5300              mov [__r1],A
 0672 52F8              mov A,[X-8]
 0674 60D4              mov REG[0xd4],A
 0676 3E00              mvi A,[__r1]
 0678 5300              mov [__r0],A
 067A 5201              mov A,[X+1]
 067C 5300              mov [__r3],A
 067E 5200              mov A,[X+0]
 0680 5300              mov [__r2],A
 0682 6500              asl [__r3]
 0684 6B00              rlc [__r2]
 0686 6500              asl [__r3]
 0688 6B00              rlc [__r2]
 068A 52FB              mov A,[X-5]
 068C 0400              add [__r3],A
 068E 52FA              mov A,[X-6]
 0690 0C00              adc [__r2],A
 0692 060001            add [__r3],1
 0695 0E0000            adc [__r2],0
 0698 5100              mov A,[__r2]
 069A 60D5              mov REG[0xd5],A
 069C 5100              mov A,[__r0]
 069E 3F00              mvi [__r3],A
 06A0                   .dbline 326
 06A0           ;       }
 06A0           L63:
 06A0                   .dbline 327
 06A0           ; return found;
 06A0 5202              mov A,[X+2]
 06A2 62D000            mov REG[0xd0],>__r0
 06A5                   .dbline -2
 06A5           L56:
 06A5 38FD              add SP,-3
 06A7 20                pop X
 06A8                   .dbline 0 ; func end
 06A8 7F                ret
 06A9                   .dbsym l found 2 c
 06A9                   .dbsym l i 0 I
 06A9                   .dbsym l label -8 pc
 06A9                   .dbsym l table -6 pS[vocabTable]
 06A9                   .dbsym l word_encoding -4 c
 06A9                   .dbend
 06A9                   .dbfunc e swap _swap fV
 06A9           ;           temp -> X+0
 06A9           ;              b -> X-7
 06A9           ;              a -> X-5
 06A9           _swap::
 06A9                   .dbline -1
 06A9 10                push X
 06AA 4F                mov X,SP
 06AB 3804              add SP,4
 06AD                   .dbline 333
 06AD           ; }
 06AD           ; 
 06AD           ; // Sort Algorithm for tables based on quick sort
 06AD           ; 
 06AD           ; void swap(vocabTable_type* a, vocabTable_type* b)
 06AD           ; {
 06AD                   .dbline 334
 06AD           ;     vocabTable_type temp = *a;
 06AD 62D000            mov REG[0xd0],>__r0
 06B0 52FC              mov A,[X-4]
 06B2 5300              mov [__r1],A
 06B4 52FB              mov A,[X-5]
 06B6 5A00              mov [__r3],X
 06B8 60D4              mov REG[0xd4],A
 06BA 62D503            mov REG[0xd5],3
 06BD 3E00              mvi A,[__r1]
 06BF 3F00              mvi [__r3],A
 06C1 3E00              mvi A,[__r1]
 06C3 3F00              mvi [__r3],A
 06C5 3E00              mvi A,[__r1]
 06C7 3F00              mvi [__r3],A
 06C9 3E00              mvi A,[__r1]
 06CB 3F00              mvi [__r3],A
 06CD                   .dbline 335
 06CD           ;     *a = *b;
 06CD 52FA              mov A,[X-6]
 06CF 5300              mov [__r1],A
 06D1 52F9              mov A,[X-7]
 06D3 5300              mov [__r0],A
 06D5 52FC              mov A,[X-4]
 06D7 5300              mov [__r3],A
 06D9 52FB              mov A,[X-5]
 06DB 5300              mov [__r2],A
 06DD 5100              mov A,[__r0]
 06DF 60D4              mov REG[0xd4],A
 06E1 5100              mov A,[__r2]
 06E3 60D5              mov REG[0xd5],A
 06E5 3E00              mvi A,[__r1]
 06E7 3F00              mvi [__r3],A
 06E9 3E00              mvi A,[__r1]
 06EB 3F00              mvi [__r3],A
 06ED 3E00              mvi A,[__r1]
 06EF 3F00              mvi [__r3],A
 06F1 3E00              mvi A,[__r1]
 06F3 3F00              mvi [__r3],A
 06F5                   .dbline 336
 06F5           ;     *b = temp;
 06F5 5A00              mov [__r1],X
 06F7 52FA              mov A,[X-6]
 06F9 5300              mov [__r3],A
 06FB 52F9              mov A,[X-7]
 06FD 62D403            mov REG[0xd4],3
 0700 60D5              mov REG[0xd5],A
 0702 3E00              mvi A,[__r1]
 0704 3F00              mvi [__r3],A
 0706 3E00              mvi A,[__r1]
 0708 3F00              mvi [__r3],A
 070A 3E00              mvi A,[__r1]
 070C 3F00              mvi [__r3],A
 070E 3E00              mvi A,[__r1]
 0710 3F00              mvi [__r3],A
 0712                   .dbline -2
 0712           L65:
 0712 38FC              add SP,-4
 0714 20                pop X
 0715                   .dbline 0 ; func end
 0715 7F                ret
 0716                   .dbsym l temp 0 S[vocabTable]
 0716                   .dbsym l b -7 pS[vocabTable]
 0716                   .dbsym l a -5 pS[vocabTable]
 0716                   .dbend
 0716                   .dbfunc e part _part fI
 0716           ;              x -> X+4
 0716           ;              i -> X+2
 0716           ;              j -> X+0
 0716           ;              h -> X-9
 0716           ;              l -> X-7
 0716           ;            arr -> X-5
 0716           _part::
 0716                   .dbline -1
 0716 10                push X
 0717 4F                mov X,SP
 0718 3806              add SP,6
 071A                   .dbline 340
 071A           ; }
 071A           ; 
 071A           ; int part(vocabTable_type arr[], int l, int h)
 071A           ; {
 071A                   .dbline 341
 071A           ;     int x = arr[h].frequency;
 071A 62D000            mov REG[0xd0],>__r0
 071D 52F8              mov A,[X-8]
 071F 5300              mov [__r1],A
 0721 52F7              mov A,[X-9]
 0723 5300              mov [__r0],A
 0725 6500              asl [__r1]
 0727 6B00              rlc [__r0]
 0729 6500              asl [__r1]
 072B 6B00              rlc [__r0]
 072D 52FC              mov A,[X-4]
 072F 0400              add [__r1],A
 0731 52FB              mov A,[X-5]
 0733 0C00              adc [__r0],A
 0735 060002            add [__r1],2
 0738 0E0000            adc [__r0],0
 073B 5100              mov A,[__r0]
 073D 60D4              mov REG[0xd4],A
 073F 3E00              mvi A,[__r1]
 0741 5405              mov [X+5],A
 0743 560400            mov [X+4],0
 0746                   .dbline 342
 0746           ;     int i = (l - 1);
 0746 52FA              mov A,[X-6]
 0748 1101              sub A,1
 074A 5403              mov [X+3],A
 074C 52F9              mov A,[X-7]
 074E 1900              sbb A,0
 0750 5402              mov [X+2],A
 0752                   .dbline 344
 0752           ;       int j; 
 0752           ;     for ( j = l; j <= h - 1; j++) 
 0752 52FA              mov A,[X-6]
 0754 5401              mov [X+1],A
 0756 52F9              mov A,[X-7]
 0758 5400              mov [X+0],A
 075A 8085              xjmp L70
 075C           L67:
 075C                   .dbline 345
 075C           ;       {
 075C                   .dbline 346
 075C           ;         if (arr[j].frequency >= x) 
 075C 62D000            mov REG[0xd0],>__r0
 075F 5201              mov A,[X+1]
 0761 5300              mov [__r1],A
 0763 5200              mov A,[X+0]
 0765 5300              mov [__r0],A
 0767 6500              asl [__r1]
 0769 6B00              rlc [__r0]
 076B 6500              asl [__r1]
 076D 6B00              rlc [__r0]
 076F 52FC              mov A,[X-4]
 0771 0400              add [__r1],A
 0773 52FB              mov A,[X-5]
 0775 0C00              adc [__r0],A
 0777 060002            add [__r1],2
 077A 0E0000            adc [__r0],0
 077D 5100              mov A,[__r0]
 077F 60D4              mov REG[0xd4],A
 0781 3E00              mvi A,[__r1]
 0783 1305              sub A,[X+5]
 0785 5204              mov A,[X+4]
 0787 3180              xor A,-128
 0789 5300              mov [__rX],A
 078B 5000              mov A,0
 078D 3180              xor A,-128
 078F 1A00              sbb A,[__rX]
 0791 C049              jc L71
 0793           X20:
 0793                   .dbline 348
 0793           ;               {
 0793           ;             i++;
 0793                   .dbline 348
 0793 7703              inc [X+3]
 0795 0F0200            adc [X+2],0
 0798                   .dbline 349
 0798           ;             swap(&arr[i], &arr[j]);
 0798 62D000            mov REG[0xd0],>__r0
 079B 5201              mov A,[X+1]
 079D 5300              mov [__r1],A
 079F 5200              mov A,[X+0]
 07A1 5300              mov [__r0],A
 07A3 6500              asl [__r1]
 07A5 6B00              rlc [__r0]
 07A7 6500              asl [__r1]
 07A9 6B00              rlc [__r0]
 07AB 52FC              mov A,[X-4]
 07AD 0400              add [__r1],A
 07AF 52FB              mov A,[X-5]
 07B1 0C00              adc [__r0],A
 07B3 5100              mov A,[__r0]
 07B5 08                push A
 07B6 5100              mov A,[__r1]
 07B8 08                push A
 07B9 5203              mov A,[X+3]
 07BB 5300              mov [__r1],A
 07BD 5202              mov A,[X+2]
 07BF 5300              mov [__r0],A
 07C1 6500              asl [__r1]
 07C3 6B00              rlc [__r0]
 07C5 6500              asl [__r1]
 07C7 6B00              rlc [__r0]
 07C9 52FC              mov A,[X-4]
 07CB 0400              add [__r1],A
 07CD 52FB              mov A,[X-5]
 07CF 0C00              adc [__r0],A
 07D1 5100              mov A,[__r0]
 07D3 08                push A
 07D4 5100              mov A,[__r1]
 07D6 08                push A
 07D7 9ED0              xcall _swap
 07D9 38FC              add SP,-4
 07DB                   .dbline 350
 07DB           ;         }
 07DB           L71:
 07DB                   .dbline 351
 07DB           ;     }
 07DB           L68:
 07DB                   .dbline 344
 07DB 7701              inc [X+1]
 07DD 0F0000            adc [X+0],0
 07E0           L70:
 07E0                   .dbline 344
 07E0 62D000            mov REG[0xd0],>__r0
 07E3 52F8              mov A,[X-8]
 07E5 1101              sub A,1
 07E7 5300              mov [__r1],A
 07E9 52F7              mov A,[X-9]
 07EB 1900              sbb A,0
 07ED 5300              mov [__r0],A
 07EF 5100              mov A,[__r1]
 07F1 1301              sub A,[X+1]
 07F3 5200              mov A,[X+0]
 07F5 3180              xor A,-128
 07F7 5300              mov [__rX],A
 07F9 5100              mov A,[__r0]
 07FB 3180              xor A,-128
 07FD 1A00              sbb A,[__rX]
 07FF DF5C              jnc L67
 0801           X21:
 0801                   .dbline 352
 0801           ;     swap(&arr[i + 1], &arr[h]);
 0801 62D000            mov REG[0xd0],>__r0
 0804 52F8              mov A,[X-8]
 0806 5300              mov [__r1],A
 0808 52F7              mov A,[X-9]
 080A 5300              mov [__r0],A
 080C 6500              asl [__r1]
 080E 6B00              rlc [__r0]
 0810 6500              asl [__r1]
 0812 6B00              rlc [__r0]
 0814 52FC              mov A,[X-4]
 0816 0400              add [__r1],A
 0818 52FB              mov A,[X-5]
 081A 0C00              adc [__r0],A
 081C 5100              mov A,[__r0]
 081E 08                push A
 081F 5100              mov A,[__r1]
 0821 08                push A
 0822 5203              mov A,[X+3]
 0824 0101              add A,1
 0826 5300              mov [__r1],A
 0828 5202              mov A,[X+2]
 082A 0900              adc A,0
 082C 5300              mov [__r0],A
 082E 6500              asl [__r1]
 0830 6B00              rlc [__r0]
 0832 6500              asl [__r1]
 0834 6B00              rlc [__r0]
 0836 52FC              mov A,[X-4]
 0838 0400              add [__r1],A
 083A 52FB              mov A,[X-5]
 083C 0C00              adc [__r0],A
 083E 5100              mov A,[__r0]
 0840 08                push A
 0841 5100              mov A,[__r1]
 0843 08                push A
 0844 9E63              xcall _swap
 0846 38FC              add SP,-4
 0848                   .dbline 353
 0848           ;     return (i + 1);
 0848 62D000            mov REG[0xd0],>__r0
 084B 5203              mov A,[X+3]
 084D 0101              add A,1
 084F 5300              mov [__r1],A
 0851 5202              mov A,[X+2]
 0853 0900              adc A,0
 0855 5300              mov [__r0],A
 0857                   .dbline -2
 0857           L66:
 0857 38FA              add SP,-6
 0859 20                pop X
 085A                   .dbline 0 ; func end
 085A 7F                ret
 085B                   .dbsym l x 4 I
 085B                   .dbsym l i 2 I
 085B                   .dbsym l j 0 I
 085B                   .dbsym l h -9 I
 085B                   .dbsym l l -7 I
 085B                   .dbsym l arr -5 pS[vocabTable]
 085B                   .dbend
 085B                   .dbfunc e quickSort _quickSort fV
 085B           ;              p -> X+0
 085B           ;              h -> X-9
 085B           ;              l -> X-7
 085B           ;              A -> X-5
 085B           _quickSort::
 085B                   .dbline -1
 085B 10                push X
 085C 4F                mov X,SP
 085D 3802              add SP,2
 085F                   .dbline 357
 085F           ; }
 085F           ; 
 085F           ; void quickSort(vocabTable_type A[], int l, int h)
 085F           ; {
 085F                   .dbline 358
 085F           ;     if (l < h) {
 085F 52FA              mov A,[X-6]
 0861 13F8              sub A,[X-8]
 0863 52F7              mov A,[X-9]
 0865 3180              xor A,-128
 0867 62D000            mov REG[0xd0],>__r0
 086A 5300              mov [__rX],A
 086C 52F9              mov A,[X-7]
 086E 3180              xor A,-128
 0870 1A00              sbb A,[__rX]
 0872 D05F              jnc L74
 0874           X22:
 0874                   .dbline 359
 0874           ;         int p = part(A, l, h);
 0874                   .dbline 359
 0874 52F7              mov A,[X-9]
 0876 08                push A
 0877 52F8              mov A,[X-8]
 0879 08                push A
 087A 52F9              mov A,[X-7]
 087C 08                push A
 087D 52FA              mov A,[X-6]
 087F 08                push A
 0880 52FB              mov A,[X-5]
 0882 08                push A
 0883 52FC              mov A,[X-4]
 0885 08                push A
 0886 9E8E              xcall _part
 0888 38FA              add SP,-6
 088A 62D000            mov REG[0xd0],>__r0
 088D 5100              mov A,[__r1]
 088F 5401              mov [X+1],A
 0891 5100              mov A,[__r0]
 0893 5400              mov [X+0],A
 0895                   .dbline 360
 0895           ;         quickSort(A, l, p - 1);
 0895 5201              mov A,[X+1]
 0897 1101              sub A,1
 0899 5300              mov [__r1],A
 089B 5200              mov A,[X+0]
 089D 1900              sbb A,0
 089F 08                push A
 08A0 5100              mov A,[__r1]
 08A2 08                push A
 08A3 52F9              mov A,[X-7]
 08A5 08                push A
 08A6 52FA              mov A,[X-6]
 08A8 08                push A
 08A9 52FB              mov A,[X-5]
 08AB 08                push A
 08AC 52FC              mov A,[X-4]
 08AE 08                push A
 08AF 9FAA              xcall _quickSort
 08B1                   .dbline 361
 08B1           ;         quickSort(A, p + 1, h);
 08B1 52F7              mov A,[X-9]
 08B3 08                push A
 08B4 52F8              mov A,[X-8]
 08B6 08                push A
 08B7 62D000            mov REG[0xd0],>__r0
 08BA 5201              mov A,[X+1]
 08BC 0101              add A,1
 08BE 5300              mov [__r1],A
 08C0 5200              mov A,[X+0]
 08C2 0900              adc A,0
 08C4 08                push A
 08C5 5100              mov A,[__r1]
 08C7 08                push A
 08C8 52FB              mov A,[X-5]
 08CA 08                push A
 08CB 52FC              mov A,[X-4]
 08CD 08                push A
 08CE 9F8B              xcall _quickSort
 08D0 38F4              add SP,-12
 08D2                   .dbline 362
 08D2           ;     }
 08D2           L74:
 08D2                   .dbline -2
 08D2           L73:
 08D2 38FE              add SP,-2
 08D4 20                pop X
 08D5                   .dbline 0 ; func end
 08D5 7F                ret
 08D6                   .dbsym l p 0 I
 08D6                   .dbsym l h -9 I
 08D6                   .dbsym l l -7 I
 08D6                   .dbsym l A -5 pS[vocabTable]
 08D6                   .dbend
 08D6                   .dbfunc e remove _remove fV
 08D6           ;              i -> X+0
 08D6           ;          table -> X-6
 08D6           ; freq_threshold -> X-4
 08D6           _remove::
 08D6                   .dbline -1
 08D6 10                push X
 08D7 4F                mov X,SP
 08D8 3802              add SP,2
 08DA                   .dbline 366
 08DA           ; }
 08DA           ; 
 08DA           ; void remove(BYTE freq_threshold,vocabTable_type* table )
 08DA           ; {
 08DA                   .dbline 368
 08DA           ;       int i;
 08DA           ;       for(i= 0; i< SIZE; i++)
 08DA 560100            mov [X+1],0
 08DD 560000            mov [X+0],0
 08E0           L77:
 08E0                   .dbline 369
 08E0           ;       {       
 08E0                   .dbline 370
 08E0           ;               if(table[i].frequency < freq_threshold)
 08E0 62D000            mov REG[0xd0],>__r0
 08E3 5201              mov A,[X+1]
 08E5 5300              mov [__r1],A
 08E7 5200              mov A,[X+0]
 08E9 5300              mov [__r0],A
 08EB 6500              asl [__r1]
 08ED 6B00              rlc [__r0]
 08EF 6500              asl [__r1]
 08F1 6B00              rlc [__r0]
 08F3 52FB              mov A,[X-5]
 08F5 0400              add [__r1],A
 08F7 52FA              mov A,[X-6]
 08F9 0C00              adc [__r0],A
 08FB 060002            add [__r1],2
 08FE 0E0000            adc [__r0],0
 0901 5100              mov A,[__r0]
 0903 60D4              mov REG[0xd4],A
 0905 3E00              mvi A,[__r1]
 0907 3BFC              cmp A,[X-4]
 0909 D070              jnc L81
 090B           X23:
 090B                   .dbline 373
 090B           ;               {
 090B           ;                       // Remove the old word and details and initial with zero
 090B           ;                       table[i].word= 0;
 090B                   .dbline 373
 090B 62D000            mov REG[0xd0],>__r0
 090E 5201              mov A,[X+1]
 0910 5300              mov [__r1],A
 0912 5200              mov A,[X+0]
 0914 5300              mov [__r0],A
 0916 6500              asl [__r1]
 0918 6B00              rlc [__r0]
 091A 6500              asl [__r1]
 091C 6B00              rlc [__r0]
 091E 52FB              mov A,[X-5]
 0920 0400              add [__r1],A
 0922 52FA              mov A,[X-6]
 0924 0C00              adc [__r0],A
 0926 5100              mov A,[__r0]
 0928 60D5              mov REG[0xd5],A
 092A 5000              mov A,0
 092C 3F00              mvi [__r1],A
 092E                   .dbline 374
 092E           ;                       table[i].frequency = 0;
 092E 5201              mov A,[X+1]
 0930 5300              mov [__r1],A
 0932 5200              mov A,[X+0]
 0934 5300              mov [__r0],A
 0936 6500              asl [__r1]
 0938 6B00              rlc [__r0]
 093A 6500              asl [__r1]
 093C 6B00              rlc [__r0]
 093E 52FB              mov A,[X-5]
 0940 0400              add [__r1],A
 0942 52FA              mov A,[X-6]
 0944 0C00              adc [__r0],A
 0946 060002            add [__r1],2
 0949 0E0000            adc [__r0],0
 094C 5100              mov A,[__r0]
 094E 60D5              mov REG[0xd5],A
 0950 5000              mov A,0
 0952 3F00              mvi [__r1],A
 0954                   .dbline 375
 0954           ;                       table[i].age= 0;
 0954 5201              mov A,[X+1]
 0956 5300              mov [__r1],A
 0958 5200              mov A,[X+0]
 095A 5300              mov [__r0],A
 095C 6500              asl [__r1]
 095E 6B00              rlc [__r0]
 0960 6500              asl [__r1]
 0962 6B00              rlc [__r0]
 0964 52FB              mov A,[X-5]
 0966 0400              add [__r1],A
 0968 52FA              mov A,[X-6]
 096A 0C00              adc [__r0],A
 096C 060003            add [__r1],3
 096F 0E0000            adc [__r0],0
 0972 5100              mov A,[__r0]
 0974 60D5              mov REG[0xd5],A
 0976 5000              mov A,0
 0978 3F00              mvi [__r1],A
 097A                   .dbline 376
 097A           ;               }
 097A           L81:
 097A                   .dbline 377
 097A           ;       }
 097A           L78:
 097A                   .dbline 368
 097A 7701              inc [X+1]
 097C 0F0000            adc [X+0],0
 097F                   .dbline 368
 097F 5201              mov A,[X+1]
 0981 1114              sub A,20
 0983 5200              mov A,[X+0]
 0985 3180              xor A,-128
 0987 1980              sbb A,(0 ^ 0x80)
 0989 CF56              jc L77
 098B           X24:
 098B                   .dbline -2
 098B           L76:
 098B 38FE              add SP,-2
 098D 20                pop X
 098E                   .dbline 0 ; func end
 098E 7F                ret
 098F                   .dbsym l i 0 I
 098F                   .dbsym l table -6 pS[vocabTable]
 098F                   .dbsym l freq_threshold -4 c
 098F                   .dbend
 098F                   .dbfunc e read_temperature _read_temperature fI
 098F           ;    Temperature -> X+2
 098F           ;      LowerByte -> X+1
 098F           ;      UpperByte -> X+0
 098F           _read_temperature::
 098F                   .dbline -1
 098F 10                push X
 0990 4F                mov X,SP
 0991 3804              add SP,4
 0993                   .dbline 381
 0993           ;       
 0993           ; }
 0993           ; INT read_temperature(void)
 0993           ; {
 0993                   .dbline 382
 0993           ;       BYTE UpperByte = 0;
 0993 560000            mov [X+0],0
 0996                   .dbline 383
 0996           ;       BYTE LowerByte = 0;
 0996 560100            mov [X+1],0
 0999                   .dbline 384
 0999           ;       INT Temperature =0;
 0999 560300            mov [X+3],0
 099C 560200            mov [X+2],0
 099F                   .dbline 386
 099F           ;       
 099F           ;       I2CHW_Temp_fSendStart(TEMP_SENSOR_SLAVE_ADDRESS, I2CHW_Temp_WRITE);
 099F 10                push X
 09A0 5700              mov X,0
 09A2 5018              mov A,24
 09A4 7C0000            xcall _I2CHW_Temp_fSendStart
 09A7 20                pop X
 09A8 62D000            mov REG[0xd0],>__r0
 09AB                   .dbline 387
 09AB           ;       I2CHW_Temp_fWrite(TEMP_REG);
 09AB 10                push X
 09AC 5005              mov A,5
 09AE 7C0000            xcall _I2CHW_Temp_fWrite
 09B1 20                pop X
 09B2 62D000            mov REG[0xd0],>__r0
 09B5                   .dbline 388
 09B5           ;       I2CHW_Temp_SendStop();
 09B5 10                push X
 09B6 7C0000            xcall _I2CHW_Temp_SendStop
 09B9                   .dbline 389
 09B9           ;       I2CHW_Temp_fSendStart(TEMP_SENSOR_SLAVE_ADDRESS, I2CHW_Temp_READ);
 09B9 5701              mov X,1
 09BB 5018              mov A,24
 09BD 7C0000            xcall _I2CHW_Temp_fSendStart
 09C0 20                pop X
 09C1 62D000            mov REG[0xd0],>__r0
 09C4                   .dbline 390
 09C4           ;       UpperByte = I2CHW_Temp_bRead(I2CHW_Temp_ACKslave);
 09C4 10                push X
 09C5 5001              mov A,1
 09C7 7C0000            xcall _I2CHW_Temp_bRead
 09CA 20                pop X
 09CB 62D000            mov REG[0xd0],>__r0
 09CE 5400              mov [X+0],A
 09D0                   .dbline 391
 09D0           ;       LowerByte = I2CHW_Temp_bRead(I2CHW_Temp_NAKslave);
 09D0 10                push X
 09D1 5000              mov A,0
 09D3 7C0000            xcall _I2CHW_Temp_bRead
 09D6 20                pop X
 09D7 62D000            mov REG[0xd0],>__r0
 09DA 5401              mov [X+1],A
 09DC                   .dbline 392
 09DC           ;       I2CHW_Temp_SendStop();
 09DC 10                push X
 09DD 7C0000            xcall _I2CHW_Temp_SendStop
 09E0 20                pop X
 09E1                   .dbline 394
 09E1           ;       
 09E1           ;       UpperByte = UpperByte & 0x1F; //Clear flag bits
 09E1 27001F            and [X+0],31
 09E4                   .dbline 396
 09E4           ;       
 09E4           ;       if ((UpperByte & 0x10) == 0x10){ //TA < 0°C
 09E4 62D000            mov REG[0xd0],>__r0
 09E7 5200              mov A,[X+0]
 09E9 2110              and A,16
 09EB 3910              cmp A,16
 09ED B050              jnz L84
 09EF                   .dbline 397
 09EF           ;       UpperByte = UpperByte & 0x0F;//Clear SIGN
 09EF                   .dbline 397
 09EF 27000F            and [X+0],15
 09F2                   .dbline 398
 09F2           ;       Temperature = 256 - (UpperByte * 16 + LowerByte / 16);
 09F2 5201              mov A,[X+1]
 09F4 5300              mov [__r1],A
 09F6 5000              mov A,0
 09F8 08                push A
 09F9 5010              mov A,16
 09FB 08                push A
 09FC 5000              mov A,0
 09FE 08                push A
 09FF 5100              mov A,[__r1]
 0A01 08                push A
 0A02 7C0000            xcall __divmod_16X16_16
 0A05 18                pop A
 0A06 5300              mov [__r1],A
 0A08 18                pop A
 0A09 5300              mov [__r0],A
 0A0B 38FE              add SP,-2
 0A0D 5200              mov A,[X+0]
 0A0F 5300              mov [__r3],A
 0A11 550000            mov [__r2],0
 0A14 6500              asl [__r3]
 0A16 6B00              rlc [__r2]
 0A18 6500              asl [__r3]
 0A1A 6B00              rlc [__r2]
 0A1C 6500              asl [__r3]
 0A1E 6B00              rlc [__r2]
 0A20 6500              asl [__r3]
 0A22 6B00              rlc [__r2]
 0A24 5100              mov A,[__r3]
 0A26 0200              add A,[__r1]
 0A28 5300              mov [__r1],A
 0A2A 5100              mov A,[__r2]
 0A2C 0A00              adc A,[__r0]
 0A2E 5300              mov [__r0],A
 0A30 5000              mov A,0
 0A32 1200              sub A,[__r1]
 0A34 5403              mov [X+3],A
 0A36 5001              mov A,1
 0A38 1A00              sbb A,[__r0]
 0A3A 5402              mov [X+2],A
 0A3C                   .dbline 399
 0A3C           ;       }else //TA ≥ 0°C*/
 0A3C 8042              xjmp L85
 0A3E           L84:
 0A3E                   .dbline 400
 0A3E           ;       Temperature = (UpperByte * 16 + LowerByte / 16);//Temperature = Ambient Temperature (°C)
 0A3E 62D000            mov REG[0xd0],>__r0
 0A41 5201              mov A,[X+1]
 0A43 5300              mov [__r1],A
 0A45 5000              mov A,0
 0A47 08                push A
 0A48 5010              mov A,16
 0A4A 08                push A
 0A4B 5000              mov A,0
 0A4D 08                push A
 0A4E 5100              mov A,[__r1]
 0A50 08                push A
 0A51 7C0000            xcall __divmod_16X16_16
 0A54 18                pop A
 0A55 5300              mov [__r1],A
 0A57 18                pop A
 0A58 5300              mov [__r0],A
 0A5A 38FE              add SP,-2
 0A5C 5200              mov A,[X+0]
 0A5E 5300              mov [__r3],A
 0A60 550000            mov [__r2],0
 0A63 6500              asl [__r3]
 0A65 6B00              rlc [__r2]
 0A67 6500              asl [__r3]
 0A69 6B00              rlc [__r2]
 0A6B 6500              asl [__r3]
 0A6D 6B00              rlc [__r2]
 0A6F 6500              asl [__r3]
 0A71 6B00              rlc [__r2]
 0A73 5100              mov A,[__r3]
 0A75 0200              add A,[__r1]
 0A77 5403              mov [X+3],A
 0A79 5100              mov A,[__r2]
 0A7B 0A00              adc A,[__r0]
 0A7D 5402              mov [X+2],A
 0A7F           L85:
 0A7F                   .dbline 402
 0A7F           ;       
 0A7F           ;       return Temperature;
 0A7F 62D000            mov REG[0xd0],>__r0
 0A82 5203              mov A,[X+3]
 0A84 5300              mov [__r1],A
 0A86 5202              mov A,[X+2]
 0A88 5300              mov [__r0],A
 0A8A                   .dbline -2
 0A8A           L83:
 0A8A 38FC              add SP,-4
 0A8C 20                pop X
 0A8D                   .dbline 0 ; func end
 0A8D 7F                ret
 0A8E                   .dbsym l Temperature 2 I
 0A8E                   .dbsym l LowerByte 1 c
 0A8E                   .dbsym l UpperByte 0 c
 0A8E                   .dbend
 0A8E                   .dbfunc e getLux _getLux fD
 0A8E           ;            lux -> X+12
 0A8E           ;      microamps -> X+8
 0A8E           ;           amps -> X+4
 0A8E           ;          volts -> X+0
 0A8E           _getLux::
 0A8E                   .dbline -1
 0A8E 10                push X
 0A8F 4F                mov X,SP
 0A90 3810              add SP,16
 0A92                   .dbline 405
 0A92           ; }
 0A92           ; float getLux(void )
 0A92           ; {
 0A92                   .dbline 406
 0A92           ;       float volts = readDualAdc(LIGHT_SENSOR_ADC_CHANNEL)*5.0 /1024.0;
 0A92 5000              mov A,0
 0A94 08                push A
 0A95 5002              mov A,2
 0A97 08                push A
 0A98 9116              xcall _readDualAdc
 0A9A 38FE              add SP,-2
 0A9C 62D000            mov REG[0xd0],>__r0
 0A9F 5100              mov A,[__r1]
 0AA1 5300              mov [__r3],A
 0AA3 5100              mov A,[__r0]
 0AA5 5300              mov [__r2],A
 0AA7 470080            tst [__r2],-128
 0AAA A009              jz X25
 0AAC 5500FF            mov [__r1],-1
 0AAF 5500FF            mov [__r0],-1
 0AB2 800A              jmp X26
 0AB4           X25:
 0AB4 62D000            mov REG[0xd0],>__r0
 0AB7 550000            mov [__r1],0
 0ABA 550000            mov [__r0],0
 0ABD           X26:
 0ABD 62D000            mov REG[0xd0],>__r0
 0AC0 5100              mov A,[__r0]
 0AC2 08                push A
 0AC3 5100              mov A,[__r1]
 0AC5 08                push A
 0AC6 5100              mov A,[__r2]
 0AC8 08                push A
 0AC9 5100              mov A,[__r3]
 0ACB 08                push A
 0ACC 7C0000            xcall __long2fp
 0ACF 18                pop A
 0AD0 5300              mov [__r3],A
 0AD2 18                pop A
 0AD3 5300              mov [__r2],A
 0AD5 18                pop A
 0AD6 5300              mov [__r1],A
 0AD8 18                pop A
 0AD9 08                push A
 0ADA 5100              mov A,[__r1]
 0ADC 08                push A
 0ADD 5100              mov A,[__r2]
 0ADF 08                push A
 0AE0 5100              mov A,[__r3]
 0AE2 08                push A
 0AE3 5040              mov A,64
 0AE5 08                push A
 0AE6 50A0              mov A,-96
 0AE8 08                push A
 0AE9 5000              mov A,0
 0AEB 08                push A
 0AEC 08                push A
 0AED 7C0000            xcall __fpmul
 0AF0 18                pop A
 0AF1 5300              mov [__r3],A
 0AF3 18                pop A
 0AF4 5300              mov [__r2],A
 0AF6 18                pop A
 0AF7 5300              mov [__r1],A
 0AF9 18                pop A
 0AFA 5300              mov [__r0],A
 0AFC 38FC              add SP,-4
 0AFE 5044              mov A,68
 0B00 08                push A
 0B01 5080              mov A,-128
 0B03 08                push A
 0B04 5000              mov A,0
 0B06 08                push A
 0B07 08                push A
 0B08 5100              mov A,[__r0]
 0B0A 08                push A
 0B0B 5100              mov A,[__r1]
 0B0D 08                push A
 0B0E 5100              mov A,[__r2]
 0B10 08                push A
 0B11 5100              mov A,[__r3]
 0B13 08                push A
 0B14 7C0000            xcall __fpdiv
 0B17 18                pop A
 0B18 5403              mov [X+3],A
 0B1A 18                pop A
 0B1B 5402              mov [X+2],A
 0B1D 18                pop A
 0B1E 5401              mov [X+1],A
 0B20 18                pop A
 0B21 5400              mov [X+0],A
 0B23 38FC              add SP,-4
 0B25                   .dbline 407
 0B25           ;       float amps  = volts/10000.0; // Across 10,000 Ohms
 0B25 5046              mov A,70
 0B27 08                push A
 0B28 501C              mov A,28
 0B2A 08                push A
 0B2B 5040              mov A,64
 0B2D 08                push A
 0B2E 5000              mov A,0
 0B30 08                push A
 0B31 5200              mov A,[X+0]
 0B33 08                push A
 0B34 5201              mov A,[X+1]
 0B36 08                push A
 0B37 5202              mov A,[X+2]
 0B39 08                push A
 0B3A 5203              mov A,[X+3]
 0B3C 08                push A
 0B3D 7C0000            xcall __fpdiv
 0B40 18                pop A
 0B41 5407              mov [X+7],A
 0B43 18                pop A
 0B44 5406              mov [X+6],A
 0B46 18                pop A
 0B47 5405              mov [X+5],A
 0B49 18                pop A
 0B4A 5404              mov [X+4],A
 0B4C 38FC              add SP,-4
 0B4E                   .dbline 408
 0B4E           ;       float microamps = amps * 1000000;
 0B4E 5204              mov A,[X+4]
 0B50 08                push A
 0B51 5205              mov A,[X+5]
 0B53 08                push A
 0B54 5206              mov A,[X+6]
 0B56 08                push A
 0B57 5207              mov A,[X+7]
 0B59 08                push A
 0B5A 5049              mov A,73
 0B5C 08                push A
 0B5D 5074              mov A,116
 0B5F 08                push A
 0B60 5024              mov A,36
 0B62 08                push A
 0B63 5000              mov A,0
 0B65 08                push A
 0B66 7C0000            xcall __fpmul
 0B69 18                pop A
 0B6A 540B              mov [X+11],A
 0B6C 18                pop A
 0B6D 540A              mov [X+10],A
 0B6F 18                pop A
 0B70 5409              mov [X+9],A
 0B72 18                pop A
 0B73 5408              mov [X+8],A
 0B75 38FC              add SP,-4
 0B77                   .dbline 409
 0B77           ;       float lux = microamps * 2.0;
 0B77 5208              mov A,[X+8]
 0B79 08                push A
 0B7A 5209              mov A,[X+9]
 0B7C 08                push A
 0B7D 520A              mov A,[X+10]
 0B7F 08                push A
 0B80 520B              mov A,[X+11]
 0B82 08                push A
 0B83 5040              mov A,64
 0B85 08                push A
 0B86 5000              mov A,0
 0B88 08                push A
 0B89 08                push A
 0B8A 08                push A
 0B8B 7C0000            xcall __fpmul
 0B8E 18                pop A
 0B8F 540F              mov [X+15],A
 0B91 18                pop A
 0B92 540E              mov [X+14],A
 0B94 18                pop A
 0B95 540D              mov [X+13],A
 0B97 18                pop A
 0B98 540C              mov [X+12],A
 0B9A 38FC              add SP,-4
 0B9C                   .dbline 411
 0B9C           ;       
 0B9C           ;       return lux;
 0B9C 520C              mov A,[X+12]
 0B9E 5300              mov [__r0],A
 0BA0 520D              mov A,[X+13]
 0BA2 5300              mov [__r1],A
 0BA4 520E              mov A,[X+14]
 0BA6 5300              mov [__r2],A
 0BA8 520F              mov A,[X+15]
 0BAA 5300              mov [__r3],A
 0BAC                   .dbline -2
 0BAC           L86:
 0BAC 38F0              add SP,-16
 0BAE 20                pop X
 0BAF                   .dbline 0 ; func end
 0BAF 7F                ret
 0BB0                   .dbsym l lux 12 D
 0BB0                   .dbsym l microamps 8 D
 0BB0                   .dbsym l amps 4 D
 0BB0                   .dbsym l volts 0 D
 0BB0                   .dbend
 0BB0                   .dbfunc e readDualAdc _readDualAdc fI
 0BB0           ;       iResult2 -> X+4
 0BB0           ;       iResult1 -> X+2
 0BB0           ;        iResult -> X+0
 0BB0           ;        channel -> X-5
 0BB0           _readDualAdc::
 0BB0                   .dbline -1
 0BB0 10                push X
 0BB1 4F                mov X,SP
 0BB2 3806              add SP,6
 0BB4                   .dbline 415
 0BB4           ; }     
 0BB4           ; 
 0BB4           ; INT readDualAdc(INT channel)
 0BB4           ; {
 0BB4           L88:
 0BB4                   .dbline 417
 0BB4           ;       int iResult1, iResult2, iResult;
 0BB4           ;       while(DUALADC_1_fIsDataAvailable() == 0);  // Wait for data to be ready
 0BB4           L89:
 0BB4                   .dbline 417
 0BB4 10                push X
 0BB5 7C0000            xcall _DUALADC_1_fIsDataAvailable
 0BB8 20                pop X
 0BB9 62D000            mov REG[0xd0],>__r0
 0BBC 3900              cmp A,0
 0BBE AFF5              jz L88
 0BC0                   .dbline 418
 0BC0           ;       iResult1 = DUALADC_1_iGetData1();          // Get Data from ADC Input1
 0BC0 10                push X
 0BC1 7C0000            xcall _DUALADC_1_iGetData1
 0BC4 62D000            mov REG[0xd0],>__r0
 0BC7 5A00              mov [__r0],X
 0BC9 20                pop X
 0BCA 5403              mov [X+3],A
 0BCC 5100              mov A,[__r0]
 0BCE 5402              mov [X+2],A
 0BD0                   .dbline 419
 0BD0           ;       iResult2 = DUALADC_1_iGetData2ClearFlag(); // Get Data from ADC Input2
 0BD0 10                push X
 0BD1 7C0000            xcall _DUALADC_1_iGetData2ClearFlag
 0BD4 62D000            mov REG[0xd0],>__r0
 0BD7 5A00              mov [__r0],X
 0BD9 20                pop X
 0BDA 5405              mov [X+5],A
 0BDC 5100              mov A,[__r0]
 0BDE 5404              mov [X+4],A
 0BE0                   .dbline 422
 0BE0           ;     
 0BE0           ;                                                       // and clear data ready flag
 0BE0           ;       if (channel == 1)
 0BE0 3DFB00            cmp [X-5],0
 0BE3 B010              jnz L91
 0BE5 3DFC01            cmp [X-4],1
 0BE8 B00B              jnz L91
 0BEA           X27:
 0BEA                   .dbline 424
 0BEA           ;       {
 0BEA           ;               iResult = iResult1;                                     // Return Mic ADC readings result
 0BEA                   .dbline 424
 0BEA 5203              mov A,[X+3]
 0BEC 5401              mov [X+1],A
 0BEE 5202              mov A,[X+2]
 0BF0 5400              mov [X+0],A
 0BF2                   .dbline 425
 0BF2           ;       }
 0BF2 8013              xjmp L92
 0BF4           L91:
 0BF4                   .dbline 426
 0BF4           ;       else if ( channel == 2)
 0BF4 3DFB00            cmp [X-5],0
 0BF7 B00E              jnz L93
 0BF9 3DFC02            cmp [X-4],2
 0BFC B009              jnz L93
 0BFE           X28:
 0BFE                   .dbline 428
 0BFE           ;       {
 0BFE           ;               iResult = iResult2;                                     // Return light sensor ADC readings result
 0BFE                   .dbline 428
 0BFE 5205              mov A,[X+5]
 0C00 5401              mov [X+1],A
 0C02 5204              mov A,[X+4]
 0C04 5400              mov [X+0],A
 0C06                   .dbline 429
 0C06           ;       }
 0C06           L93:
 0C06           L92:
 0C06                   .dbline 430
 0C06           ;       return iResult;
 0C06 62D000            mov REG[0xd0],>__r0
 0C09 5201              mov A,[X+1]
 0C0B 5300              mov [__r1],A
 0C0D 5200              mov A,[X+0]
 0C0F 5300              mov [__r0],A
 0C11                   .dbline -2
 0C11           L87:
 0C11 38FA              add SP,-6
 0C13 20                pop X
 0C14                   .dbline 0 ; func end
 0C14 7F                ret
 0C15                   .dbsym l iResult2 4 I
 0C15                   .dbsym l iResult1 2 I
 0C15                   .dbsym l iResult 0 I
 0C15                   .dbsym l channel -5 I
 0C15                   .dbend
 0C15                   .dbfunc e blocking_delay _blocking_delay fV
 0C15           ;         bTimes -> X-4
 0C15           _blocking_delay::
 0C15                   .dbline -1
 0C15 10                push X
 0C16 4F                mov X,SP
 0C17                   .dbline 435
 0C17           ; }
 0C17           ; 
 0C17           ; 
 0C17           ; void blocking_delay(BYTE bTimes)
 0C17           ; {
 0C17                   .dbline 438
 0C17           ;       // Can be used only if the delaly required is a mutiple of 50us.
 0C17           ;       // This sufficient for this project.
 0C17           ;       LCD_2_Delay50uTimes(bTimes);// Reuse the delay function provided by LCD user module             
 0C17 10                push X
 0C18 52FC              mov A,[X-4]
 0C1A 7C0000            xcall _LCD_2_Delay50uTimes
 0C1D 20                pop X
 0C1E                   .dbline -2
 0C1E           L95:
 0C1E 20                pop X
 0C1F                   .dbline 0 ; func end
 0C1F 7F                ret
 0C20                   .dbsym l bTimes -4 c
 0C20                   .dbend
 0C20                   .dbfunc e speak _speak fV
 0C20           ;              y -> X+0
 0C20           ;  word_encoding -> X-4
 0C20           _speak::
 0C20                   .dbline -1
 0C20 10                push X
 0C21 4F                mov X,SP
 0C22 3803              add SP,3
 0C24                   .dbline 442
 0C24           ; }
 0C24           ; 
 0C24           ; void speak(BYTE word_encoding)
 0C24           ; {
 0C24                   .dbline 444
 0C24           ;       BYTE y;
 0C24           ;       switch (word_encoding)
 0C24 52FC              mov A,[X-4]
 0C26 5402              mov [X+2],A
 0C28 560100            mov [X+1],0
 0C2B 3D0100            cmp [X+1],0
 0C2E B006              jnz X29
 0C30 3D0288            cmp [X+2],-120
 0C33 A11B              jz L98
 0C35           X29:
 0C35 3D0100            cmp [X+1],0
 0C38 B006              jnz X30
 0C3A 3D0289            cmp [X+2],-119
 0C3D A111              jz L98
 0C3F           X30:
 0C3F 5202              mov A,[X+2]
 0C41 118A              sub A,-118
 0C43 62D000            mov REG[0xd0],>__r0
 0C46 5300              mov [__rY],A
 0C48 5201              mov A,[X+1]
 0C4A 3180              xor A,-128
 0C4C 1980              sbb A,(0 ^ 0x80)
 0C4E 2A00              or A,[__rY]
 0C50 A0FE              jz L98
 0C52 D021              jnc L110
 0C54           X31:
 0C54           L109:
 0C54 3D0100            cmp [X+1],0
 0C57 B006              jnz X32
 0C59 3D0248            cmp [X+2],72
 0C5C A0F2              jz L98
 0C5E           X32:
 0C5E 3D0100            cmp [X+1],0
 0C61 B006              jnz X33
 0C63 3D0249            cmp [X+2],73
 0C66 A0E8              jz L98
 0C68           X33:
 0C68 3D0100            cmp [X+1],0
 0C6B B006              jnz X34
 0C6D 3D024A            cmp [X+2],74
 0C70 A0DE              jz L98
 0C72           X34:
 0C72 80DC              xjmp L97
 0C74           L110:
 0C74 3D0100            cmp [X+1],0
 0C77 B006              jnz X35
 0C79 3D02A8            cmp [X+2],-88
 0C7C A0D2              jz L98
 0C7E           X35:
 0C7E 3D0100            cmp [X+1],0
 0C81 B006              jnz X36
 0C83 3D02A9            cmp [X+2],-87
 0C86 A00D              jz L100
 0C88           X36:
 0C88 3D0100            cmp [X+1],0
 0C8B B006              jnz X37
 0C8D 3D02AA            cmp [X+2],-86
 0C90 A05E              jz L101
 0C92           X37:
 0C92 80BC              xjmp L97
 0C94           L100:
 0C94                   .dbline 449
 0C94           ;       {
 0C94           ;               // Type(2 bits) | spacer(1 bit) | payload (17 bits) (so in total 20bits of bit stream per work speak operation.
 0C94           ;               // One word consists of 8 stamps
 0C94           ;               case 0xa9: //1010 1001 4 loud stamp, 4 silent stamp | Dark light and Cold condition 
 0C94           ;                       PWM8_1_Start();
 0C94 10                push X
 0C95 7C0000            xcall _PWM8_1_Start
 0C98 20                pop X
 0C99                   .dbline 450
 0C99           ;                       blocking_delay(Z_div);//1
 0C99 5000              mov A,0
 0C9B 08                push A
 0C9C 9F77              xcall _blocking_delay
 0C9E 38FF              add SP,-1
 0CA0                   .dbline 451
 0CA0           ;                       PWM8_1_Stop();
 0CA0 10                push X
 0CA1 7C0000            xcall _PWM8_1_Stop
 0CA4 20                pop X
 0CA5                   .dbline 452
 0CA5           ;                       blocking_delay(Y_div);//0
 0CA5 5000              mov A,0
 0CA7 08                push A
 0CA8 9F6B              xcall _blocking_delay
 0CAA 38FF              add SP,-1
 0CAC                   .dbline 453
 0CAC           ;                       PWM8_1_Start();
 0CAC 10                push X
 0CAD 7C0000            xcall _PWM8_1_Start
 0CB0 20                pop X
 0CB1                   .dbline 454
 0CB1           ;                       blocking_delay(Z_div);//1
 0CB1 5000              mov A,0
 0CB3 08                push A
 0CB4 9F5F              xcall _blocking_delay
 0CB6 38FF              add SP,-1
 0CB8                   .dbline 455
 0CB8           ;                       PWM8_1_Stop();
 0CB8 10                push X
 0CB9 7C0000            xcall _PWM8_1_Stop
 0CBC 20                pop X
 0CBD                   .dbline 456
 0CBD           ;                       blocking_delay(Y_div);//0
 0CBD 5000              mov A,0
 0CBF 08                push A
 0CC0 9F53              xcall _blocking_delay
 0CC2 38FF              add SP,-1
 0CC4                   .dbline 457
 0CC4           ;                       PWM8_1_Start();
 0CC4 10                push X
 0CC5 7C0000            xcall _PWM8_1_Start
 0CC8 20                pop X
 0CC9                   .dbline 458
 0CC9           ;                       blocking_delay(Z_div);//1
 0CC9 5000              mov A,0
 0CCB 08                push A
 0CCC 9F47              xcall _blocking_delay
 0CCE 38FF              add SP,-1
 0CD0                   .dbline 459
 0CD0           ;                       PWM8_1_Stop();
 0CD0 10                push X
 0CD1 7C0000            xcall _PWM8_1_Stop
 0CD4 20                pop X
 0CD5                   .dbline 460
 0CD5           ;                       blocking_delay(2*Y_div);//00
 0CD5 5000              mov A,0
 0CD7 08                push A
 0CD8 9F3B              xcall _blocking_delay
 0CDA 38FF              add SP,-1
 0CDC                   .dbline 461
 0CDC           ;                       PWM8_1_Start();
 0CDC 10                push X
 0CDD 7C0000            xcall _PWM8_1_Start
 0CE0 20                pop X
 0CE1                   .dbline 462
 0CE1           ;                       blocking_delay(Z_div);//1
 0CE1 5000              mov A,0
 0CE3 08                push A
 0CE4 9F2F              xcall _blocking_delay
 0CE6 38FF              add SP,-1
 0CE8                   .dbline 463
 0CE8           ;                       PWM8_1_Stop();
 0CE8 10                push X
 0CE9 7C0000            xcall _PWM8_1_Stop
 0CEC 20                pop X
 0CED                   .dbline 467
 0CED           ;                       
 0CED           ;                       /*y = Y_div* 16;             
 0CED           ;                       blocking_delay(y);*/
 0CED           ;                       break;;
 0CED 8061              xjmp L98
 0CEF           L101:
 0CEF                   .dbline 469
 0CEF           ;               case 0xaa:// 1010 1010 4 loud stamp, 4 rest silent stamps |  Dark light and Medium temp condition
 0CEF           ;                       PWM8_1_Start();
 0CEF 10                push X
 0CF0 7C0000            xcall _PWM8_1_Start
 0CF3 20                pop X
 0CF4                   .dbline 470
 0CF4           ;                       blocking_delay(Z_div);//1
 0CF4 5000              mov A,0
 0CF6 08                push A
 0CF7 9F1C              xcall _blocking_delay
 0CF9 38FF              add SP,-1
 0CFB                   .dbline 471
 0CFB           ;                       PWM8_1_Stop(); 
 0CFB 10                push X
 0CFC 7C0000            xcall _PWM8_1_Stop
 0CFF 20                pop X
 0D00                   .dbline 472
 0D00           ;                       blocking_delay(Y_div);//0
 0D00 5000              mov A,0
 0D02 08                push A
 0D03 9F10              xcall _blocking_delay
 0D05 38FF              add SP,-1
 0D07                   .dbline 473
 0D07           ;                       PWM8_1_Start();
 0D07 10                push X
 0D08 7C0000            xcall _PWM8_1_Start
 0D0B 20                pop X
 0D0C                   .dbline 474
 0D0C           ;                       blocking_delay(Z_div);//1
 0D0C 5000              mov A,0
 0D0E 08                push A
 0D0F 9F04              xcall _blocking_delay
 0D11 38FF              add SP,-1
 0D13                   .dbline 475
 0D13           ;                       PWM8_1_Stop();
 0D13 10                push X
 0D14 7C0000            xcall _PWM8_1_Stop
 0D17 20                pop X
 0D18                   .dbline 476
 0D18           ;                       blocking_delay(Y_div);//0
 0D18 5000              mov A,0
 0D1A 08                push A
 0D1B 9EF8              xcall _blocking_delay
 0D1D 38FF              add SP,-1
 0D1F                   .dbline 477
 0D1F           ;                       PWM8_1_Start();
 0D1F 10                push X
 0D20 7C0000            xcall _PWM8_1_Start
 0D23 20                pop X
 0D24                   .dbline 478
 0D24           ;                       blocking_delay(Z_div);//1
 0D24 5000              mov A,0
 0D26 08                push A
 0D27 9EEC              xcall _blocking_delay
 0D29 38FF              add SP,-1
 0D2B                   .dbline 479
 0D2B           ;                       PWM8_1_Stop();
 0D2B 10                push X
 0D2C 7C0000            xcall _PWM8_1_Stop
 0D2F 20                pop X
 0D30                   .dbline 480
 0D30           ;                       blocking_delay(Y_div);//0
 0D30 5000              mov A,0
 0D32 08                push A
 0D33 9EE0              xcall _blocking_delay
 0D35 38FF              add SP,-1
 0D37                   .dbline 481
 0D37           ;                       PWM8_1_Start();
 0D37 10                push X
 0D38 7C0000            xcall _PWM8_1_Start
 0D3B 20                pop X
 0D3C                   .dbline 482
 0D3C           ;                       blocking_delay(Z_div);//1
 0D3C 5000              mov A,0
 0D3E 08                push A
 0D3F 9ED4              xcall _blocking_delay
 0D41 38FF              add SP,-1
 0D43                   .dbline 483
 0D43           ;                       PWM8_1_Stop();
 0D43 10                push X
 0D44 7C0000            xcall _PWM8_1_Stop
 0D47 20                pop X
 0D48                   .dbline 484
 0D48           ;                       blocking_delay(Y_div);//0
 0D48 5000              mov A,0
 0D4A 08                push A
 0D4B 9EC8              xcall _blocking_delay
 0D4D 38FF              add SP,-1
 0D4F                   .dbline 487
 0D4F           ;                       /*y = Y_div *14;
 0D4F           ;                       blocking_delay(y);*/
 0D4F           ;                       break;
 0D4F                   .dbline 490
 0D4F           ;               case 0xa8:// 1010 1000 3 loud stamp,5 rest silent stamps | Dark light and Hot temp condition
 0D4F           ;                       //To do
 0D4F           ;                       break;
 0D4F                   .dbline 493
 0D4F           ;               case 0x89:// 1000 1001  3 loud stamp,5 rest silent stamps |  Normal light and cold temp condition
 0D4F           ;                       //To do
 0D4F           ;                       break;
 0D4F                   .dbline 496
 0D4F           ;               case 0x8a:// 1000 1010  3 loud stamp and 5 rest silent stamps | Normal light and medium temp condition
 0D4F           ;                       //To do
 0D4F           ;                       break;
 0D4F                   .dbline 499
 0D4F           ;               case 0x88:// 1000 1000 2 loud stamp, 6 rest silent stamps | Normal light and hot temp condition
 0D4F           ;                       //To do
 0D4F           ;                       break;
 0D4F                   .dbline 502
 0D4F           ;               case 0x49:// 01001001 3 loud stamp,5 rest silent stamps | Bright light and cold temp condition
 0D4F           ;                       //To do
 0D4F           ;                       break;
 0D4F                   .dbline 504
 0D4F           ;               case 0x4a:// 01001010 3 loud stamp,5 rest silent stamps | Bright light and medium temp condition
 0D4F           ;                       break;
 0D4F                   .dbline 507
 0D4F           ;               case 0x48:// 0100 1000 2 loud stamp, 6 rest silent stamps | | Bright light and hot temp condition
 0D4F           ;                       //To do
 0D4F           ;                       break;
 0D4F           L97:
 0D4F           L98:
 0D4F                   .dbline -2
 0D4F           L96:
 0D4F 38FD              add SP,-3
 0D51 20                pop X
 0D52                   .dbline 0 ; func end
 0D52 7F                ret
 0D53                   .dbsym l y 0 c
 0D53                   .dbsym l word_encoding -4 c
 0D53                   .dbend
 0D53                   .dbfunc e listen _listen fc
 0D53           ;     start_time -> X+17
 0D53           ; X_time_elaspsed -> X+15
 0D53           ;     bit_stream -> X+14
 0D53           ;       iResult2 -> X+12
 0D53           ; bit_start_time -> X+10
 0D53           ; avg_mic_output -> X+8
 0D53           ;       iResult1 -> X+6
 0D53           ;          count -> X+4
 0D53           ;          total -> X+2
 0D53           ; ZY_time_elaspsed -> X+0
 0D53           _listen::
 0D53                   .dbline -1
 0D53 10                push X
 0D54 4F                mov X,SP
 0D55 3813              add SP,19
 0D57                   .dbline 512
 0D57           ;       }
 0D57           ; }
 0D57           ; 
 0D57           ; BYTE listen(void)
 0D57           ; {
 0D57                   .dbline 514
 0D57           ;       int iResult1,iResult2,avg_mic_output,count,total;
 0D57           ;       INT start_time =wElapsedTime;
 0D57 62D000            mov REG[0xd0],>_wElapsedTime
 0D5A 5101              mov A,[_wElapsedTime+1]
 0D5C 5412              mov [X+18],A
 0D5E 5100              mov A,[_wElapsedTime]
 0D60 5411              mov [X+17],A
 0D62                   .dbline 516
 0D62           ;       INT bit_start_time;
 0D62           ;       INT X_time_elaspsed = 0;
 0D62 561000            mov [X+16],0
 0D65 560F00            mov [X+15],0
 0D68                   .dbline 517
 0D68           ;       INT ZY_time_elaspsed = 0;
 0D68 560100            mov [X+1],0
 0D6B 560000            mov [X+0],0
 0D6E                   .dbline 518
 0D6E           ;       BYTE bit_stream = 0;
 0D6E 560E00            mov [X+14],0
 0D71 80D1              xjmp L113
 0D73           L112:
 0D73                   .dbline 521
 0D73           ;       // Listen for a word duration to heat the bit stream sent by the other agent
 0D73           ;       while (X_time_elaspsed < X)
 0D73           ;       {
 0D73                   .dbline 523
 0D73           ;               // Listen for lound or silen stamp for the Y = Z = 200ms duration
 0D73           ;               avg_mic_output = 0;
 0D73 560900            mov [X+9],0
 0D76 560800            mov [X+8],0
 0D79                   .dbline 524
 0D79           ;               count = 0;
 0D79 560500            mov [X+5],0
 0D7C 560400            mov [X+4],0
 0D7F                   .dbline 525
 0D7F           ;               total = 0;
 0D7F 560300            mov [X+3],0
 0D82 560200            mov [X+2],0
 0D85 806E              xjmp L116
 0D87           L115:
 0D87                   .dbline 527
 0D87           ;               while ((ZY_time_elaspsed < Z || ZY_time_elaspsed < Y))
 0D87           ;               {
 0D87                   .dbline 528
 0D87           ;                       ZY_time_elaspsed = wElapsedTime - bit_start_time;
 0D87 62D000            mov REG[0xd0],>_wElapsedTime
 0D8A 5101              mov A,[_wElapsedTime+1]
 0D8C 130B              sub A,[X+11]
 0D8E 5401              mov [X+1],A
 0D90 5100              mov A,[_wElapsedTime]
 0D92 1B0A              sbb A,[X+10]
 0D94 5400              mov [X+0],A
 0D96           L118:
 0D96                   .dbline 530
 0D96           ;                       
 0D96           ;                       while(DUALADC_1_fIsDataAvailable() == 0);  // Wait for data to be ready
 0D96           L119:
 0D96                   .dbline 530
 0D96 10                push X
 0D97 7C0000            xcall _DUALADC_1_fIsDataAvailable
 0D9A 20                pop X
 0D9B 62D000            mov REG[0xd0],>__r0
 0D9E 3900              cmp A,0
 0DA0 AFF5              jz L118
 0DA2                   .dbline 532
 0DA2           ;         
 0DA2           ;                       iResult1 = DUALADC_1_iGetData1();          // Get Data from ADC Input1
 0DA2 10                push X
 0DA3 7C0000            xcall _DUALADC_1_iGetData1
 0DA6 62D000            mov REG[0xd0],>__r0
 0DA9 5A00              mov [__r0],X
 0DAB 20                pop X
 0DAC 5407              mov [X+7],A
 0DAE 5100              mov A,[__r0]
 0DB0 5406              mov [X+6],A
 0DB2                   .dbline 533
 0DB2           ;                       iResult2 = DUALADC_1_iGetData2();
 0DB2 10                push X
 0DB3 7C0000            xcall _DUALADC_1_iGetData2
 0DB6 62D000            mov REG[0xd0],>__r0
 0DB9 5A00              mov [__r0],X
 0DBB 20                pop X
 0DBC 540D              mov [X+13],A
 0DBE 5100              mov A,[__r0]
 0DC0 540C              mov [X+12],A
 0DC2                   .dbline 535
 0DC2           ;       
 0DC2           ;                       DUALADC_1_iGetData1ClearFlag();
 0DC2 10                push X
 0DC3 7C0000            xcall _DUALADC_1_iGetData1ClearFlag
 0DC6 62D000            mov REG[0xd0],>__r0
 0DC9                   .dbline 536
 0DC9           ;                       DUALADC_1_iGetData2ClearFlag();
 0DC9 7C0000            xcall _DUALADC_1_iGetData2ClearFlag
 0DCC 62D000            mov REG[0xd0],>__r0
 0DCF 20                pop X
 0DD0                   .dbline 537
 0DD0           ;                       count++;
 0DD0 7705              inc [X+5]
 0DD2 0F0400            adc [X+4],0
 0DD5                   .dbline 538
 0DD5           ;                       total = total + iResult1;
 0DD5 5207              mov A,[X+7]
 0DD7 0503              add [X+3],A
 0DD9 5206              mov A,[X+6]
 0DDB 0D02              adc [X+2],A
 0DDD                   .dbline 539
 0DDD           ;                       avg_mic_output = total/count;
 0DDD 5204              mov A,[X+4]
 0DDF 08                push A
 0DE0 5205              mov A,[X+5]
 0DE2 08                push A
 0DE3 5202              mov A,[X+2]
 0DE5 08                push A
 0DE6 5203              mov A,[X+3]
 0DE8 08                push A
 0DE9 7C0000            xcall __divmod_16X16_16
 0DEC 18                pop A
 0DED 5409              mov [X+9],A
 0DEF 18                pop A
 0DF0 5408              mov [X+8],A
 0DF2 38FE              add SP,-2
 0DF4                   .dbline 540
 0DF4           ;               }
 0DF4           L116:
 0DF4                   .dbline 526
 0DF4 5201              mov A,[X+1]
 0DF6 11C8              sub A,-56
 0DF8 5200              mov A,[X+0]
 0DFA 3180              xor A,-128
 0DFC 1980              sbb A,(0 ^ 0x80)
 0DFE CF88              jc L115
 0E00           X38:
 0E00 5201              mov A,[X+1]
 0E02 11C8              sub A,-56
 0E04 5200              mov A,[X+0]
 0E06 3180              xor A,-128
 0E08 1980              sbb A,(0 ^ 0x80)
 0E0A CF7C              jc L115
 0E0C           X39:
 0E0C                   .dbline 542
 0E0C           ;               // Detected loud stamp
 0E0C           ;               if (avg_mic_output> LOUD_STAMP_THRESHOLD)
 0E0C 50FE              mov A,-2
 0E0E 1309              sub A,[X+9]
 0E10 5208              mov A,[X+8]
 0E12 3180              xor A,-128
 0E14 62D000            mov REG[0xd0],>__r0
 0E17 5300              mov [__rX],A
 0E19 5081              mov A,(1 ^ 0x80)
 0E1B 1A00              sbb A,[__rX]
 0E1D D006              jnc L121
 0E1F           X40:
 0E1F                   .dbline 544
 0E1F           ;               {
 0E1F           ;                       bit_stream = bit_stream | 0x1;                  
 0E1F                   .dbline 544
 0E1F 2F0E01            or [X+14],1
 0E22                   .dbline 545
 0E22           ;               }
 0E22 8001              xjmp L122
 0E24           L121:
 0E24                   .dbline 548
 0E24           ;               // Detected silent stamp
 0E24           ;               else
 0E24           ;               {
 0E24                   .dbline 549
 0E24           ;                       bit_stream = bit_stream | 0x0;
 0E24                   .dbline 550
 0E24           ;               }
 0E24           L122:
 0E24                   .dbline 552
 0E24           ;               //shift the bit stream for the next bit value
 0E24           ;               bit_stream = bit_stream <<1; 
 0E24 660E              asl [X+14]
 0E26                   .dbline 554
 0E26           ;               
 0E26           ;               X_time_elaspsed = wElapsedTime - start_time;
 0E26 62D000            mov REG[0xd0],>_wElapsedTime
 0E29 5101              mov A,[_wElapsedTime+1]
 0E2B 1312              sub A,[X+18]
 0E2D 5410              mov [X+16],A
 0E2F 5100              mov A,[_wElapsedTime]
 0E31 1B11              sbb A,[X+17]
 0E33 540F              mov [X+15],A
 0E35                   .dbline 556
 0E35           ;               
 0E35           ;               bit_start_time = wElapsedTime; 
 0E35 5101              mov A,[_wElapsedTime+1]
 0E37 540B              mov [X+11],A
 0E39 5100              mov A,[_wElapsedTime]
 0E3B 540A              mov [X+10],A
 0E3D                   .dbline 557
 0E3D           ;               ZY_time_elaspsed = 0;
 0E3D 560100            mov [X+1],0
 0E40 560000            mov [X+0],0
 0E43                   .dbline 558
 0E43           ;       }
 0E43           L113:
 0E43                   .dbline 520
 0E43 5210              mov A,[X+16]
 0E45 1140              sub A,64
 0E47 520F              mov A,[X+15]
 0E49 3180              xor A,-128
 0E4B 1986              sbb A,(6 ^ 0x80)
 0E4D CF25              jc L112
 0E4F           X41:
 0E4F                   .dbline 560
 0E4F           ;       
 0E4F           ;       return bit_stream;
 0E4F 520E              mov A,[X+14]
 0E51 62D000            mov REG[0xd0],>__r0
 0E54                   .dbline -2
 0E54           L111:
 0E54 38ED              add SP,-19
 0E56 20                pop X
 0E57                   .dbline 0 ; func end
 0E57 7F                ret
 0E58                   .dbsym l start_time 17 I
 0E58                   .dbsym l X_time_elaspsed 15 I
 0E58                   .dbsym l bit_stream 14 c
 0E58                   .dbsym l iResult2 12 I
 0E58                   .dbsym l bit_start_time 10 I
 0E58                   .dbsym l avg_mic_output 8 I
 0E58                   .dbsym l iResult1 6 I
 0E58                   .dbsym l count 4 I
 0E58                   .dbsym l total 2 I
 0E58                   .dbsym l ZY_time_elaspsed 0 I
 0E58                   .dbend
 0E58                   .dbfunc e check_if_labelPresent _check_if_labelPresent fc
 0E58           ;      tempValue -> X+9
 0E58           ;       luxValue -> X+5
 0E58           ;        present -> X+4
 0E58           ;          label -> X+2
 0E58           ;              i -> X+0
 0E58           ;          index -> X-5
 0E58           _check_if_labelPresent::
 0E58                   .dbline -1
 0E58 10                push X
 0E59 4F                mov X,SP
 0E5A 380B              add SP,11
 0E5C                   .dbline 565
 0E5C           ; }
 0E5C           ; 
 0E5C           ; // Check if word label is present in neighbours for the current temp&/light condition
 0E5C           ; BOOL check_if_labelPresent(char* index)
 0E5C           ; {
 0E5C                   .dbline 569
 0E5C           ;       float luxValue; // Ambient Light illumiance value
 0E5C           ;       INT   tempValue;     // Ambient temperature
 0E5C           ;       char * label;
 0E5C           ;       BOOL present =FALSE;
 0E5C 560400            mov [X+4],0
 0E5F                   .dbline 574
 0E5F           ;       int i;
 0E5F           ;       // Sense /////////////////////////////
 0E5F           ;               
 0E5F           ;       //Read light sensor value
 0E5F           ;       luxValue   = getLux(); // luxValue ranges from 0 to 1000
 0E5F 9C2D              xcall _getLux
 0E61 62D000            mov REG[0xd0],>__r0
 0E64 5100              mov A,[__r0]
 0E66 5405              mov [X+5],A
 0E68 5100              mov A,[__r1]
 0E6A 5406              mov [X+6],A
 0E6C 5100              mov A,[__r2]
 0E6E 5407              mov [X+7],A
 0E70 5100              mov A,[__r3]
 0E72 5408              mov [X+8],A
 0E74                   .dbline 576
 0E74           ;       //Read temperature value
 0E74           ;       tempValue  = read_temperature();
 0E74 9B19              xcall _read_temperature
 0E76 62D000            mov REG[0xd0],>__r0
 0E79 5100              mov A,[__r1]
 0E7B 540A              mov [X+10],A
 0E7D 5100              mov A,[__r0]
 0E7F 5409              mov [X+9],A
 0E81                   .dbline 579
 0E81           ;       
 0E81           ;       //Create a word label based on the sensor values        
 0E81           ;       create_word(luxValue, tempValue,label,lux_range_1,lux_range_2,temp_range_1,temp_range_2);
 0E81 62D000            mov REG[0xd0],>_temp_range_2
 0E84 5100              mov A,[_temp_range_2]
 0E86 08                push A
 0E87 5101              mov A,[_temp_range_2+1]
 0E89 08                push A
 0E8A 62D000            mov REG[0xd0],>_temp_range_1
 0E8D 5100              mov A,[_temp_range_1]
 0E8F 08                push A
 0E90 5101              mov A,[_temp_range_1+1]
 0E92 08                push A
 0E93 62D000            mov REG[0xd0],>_lux_range_2
 0E96 5100              mov A,[_lux_range_2]
 0E98 08                push A
 0E99 5101              mov A,[_lux_range_2+1]
 0E9B 08                push A
 0E9C 62D000            mov REG[0xd0],>_lux_range_1
 0E9F 5100              mov A,[_lux_range_1]
 0EA1 08                push A
 0EA2 5101              mov A,[_lux_range_1+1]
 0EA4 08                push A
 0EA5 5202              mov A,[X+2]
 0EA7 08                push A
 0EA8 5203              mov A,[X+3]
 0EAA 08                push A
 0EAB 5209              mov A,[X+9]
 0EAD 08                push A
 0EAE 520A              mov A,[X+10]
 0EB0 08                push A
 0EB1 5205              mov A,[X+5]
 0EB3 08                push A
 0EB4 5206              mov A,[X+6]
 0EB6 08                push A
 0EB7 5207              mov A,[X+7]
 0EB9 08                push A
 0EBA 5208              mov A,[X+8]
 0EBC 08                push A
 0EBD 7C016F            xcall _create_word
 0EC0 38F0              add SP,-16
 0EC2 62D000            mov REG[0xd0],>__r0
 0EC5                   .dbline 582
 0EC5           ;       
 0EC5           ;       // Check if this label is present in neighbour's table
 0EC5           ;       for (i= 0; i< SIZE; i++)
 0EC5 560100            mov [X+1],0
 0EC8 560000            mov [X+0],0
 0ECB           L124:
 0ECB                   .dbline 583
 0ECB           ;       {
 0ECB                   .dbline 584
 0ECB           ;               if (neighours_table[i].label == *label)
 0ECB 62D000            mov REG[0xd0],>__r0
 0ECE 5203              mov A,[X+3]
 0ED0 5300              mov [__r1],A
 0ED2 5202              mov A,[X+2]
 0ED4 60D4              mov REG[0xd4],A
 0ED6 3E00              mvi A,[__r1]
 0ED8 5300              mov [__r0],A
 0EDA 5201              mov A,[X+1]
 0EDC 5300              mov [__r3],A
 0EDE 5200              mov A,[X+0]
 0EE0 5300              mov [__r2],A
 0EE2 6500              asl [__r3]
 0EE4 6B00              rlc [__r2]
 0EE6 6500              asl [__r3]
 0EE8 6B00              rlc [__r2]
 0EEA 060001            add [__r3],<_neighours_table+1
 0EED 0E0001            adc [__r2],>_neighours_table+1
 0EF0 5100              mov A,[__r2]
 0EF2 60D4              mov REG[0xd4],A
 0EF4 3E00              mvi A,[__r3]
 0EF6 3A00              cmp A,[__r0]
 0EF8 B014              jnz L128
 0EFA                   .dbline 586
 0EFA           ;               {
 0EFA           ;                       present =TRUE;
 0EFA                   .dbline 586
 0EFA 560401            mov [X+4],1
 0EFD                   .dbline 587
 0EFD           ;                       *index = i;
 0EFD 5201              mov A,[X+1]
 0EFF 5300              mov [__r0],A
 0F01 52FC              mov A,[X-4]
 0F03 5300              mov [__r3],A
 0F05 52FB              mov A,[X-5]
 0F07 60D5              mov REG[0xd5],A
 0F09 5100              mov A,[__r0]
 0F0B 3F00              mvi [__r3],A
 0F0D                   .dbline 588
 0F0D           ;               }
 0F0D           L128:
 0F0D                   .dbline 589
 0F0D           ;       }
 0F0D           L125:
 0F0D                   .dbline 582
 0F0D 7701              inc [X+1]
 0F0F 0F0000            adc [X+0],0
 0F12                   .dbline 582
 0F12 5201              mov A,[X+1]
 0F14 1114              sub A,20
 0F16 5200              mov A,[X+0]
 0F18 3180              xor A,-128
 0F1A 1980              sbb A,(0 ^ 0x80)
 0F1C CFAE              jc L124
 0F1E           X42:
 0F1E                   .dbline 590
 0F1E           ;       return present;
 0F1E 5204              mov A,[X+4]
 0F20 62D000            mov REG[0xd0],>__r0
 0F23                   .dbline -2
 0F23           L123:
 0F23 38F5              add SP,-11
 0F25 20                pop X
 0F26                   .dbline 0 ; func end
 0F26 7F                ret
 0F27                   .dbsym l tempValue 9 I
 0F27                   .dbsym l luxValue 5 D
 0F27                   .dbsym l present 4 c
 0F27                   .dbsym l label 2 pc
 0F27                   .dbsym l i 0 I
 0F27                   .dbsym l index -5 pc
 0F27                   .dbend
 0F27                   .dbfunc e check_if_bit_stream_match _check_if_bit_stream_match fc
 0F27           ;  word_listened -> X-5
 0F27           ;          index -> X-4
 0F27           _check_if_bit_stream_match::
 0F27                   .dbline -1
 0F27 10                push X
 0F28 4F                mov X,SP
 0F29                   .dbline 593
 0F29           ; }
 0F29           ; BOOL check_if_bit_stream_match(char index,BYTE word_listened)
 0F29           ; {
 0F29                   .dbline 594
 0F29           ;       if(neighours_table[index].word == word_listened)
 0F29 62D000            mov REG[0xd0],>__r0
 0F2C 52FC              mov A,[X-4]
 0F2E 5300              mov [__r1],A
 0F30 550000            mov [__r0],0
 0F33 6500              asl [__r1]
 0F35 6B00              rlc [__r0]
 0F37 6500              asl [__r1]
 0F39 6B00              rlc [__r0]
 0F3B 060000            add [__r1],<_neighours_table
 0F3E 0E0000            adc [__r0],>_neighours_table
 0F41 5100              mov A,[__r0]
 0F43 60D4              mov REG[0xd4],A
 0F45 3E00              mvi A,[__r1]
 0F47 3BFB              cmp A,[X-5]
 0F49 B005              jnz L132
 0F4B                   .dbline 595
 0F4B           ;               return TRUE;
 0F4B 5001              mov A,1
 0F4D 8006              xjmp L131
 0F4F           L132:
 0F4F                   .dbline 597
 0F4F           ;       else 
 0F4F           ;               return FALSE;
 0F4F 62D000            mov REG[0xd0],>__r0
 0F52 5000              mov A,0
 0F54                   .dbline -2
 0F54           L131:
 0F54 20                pop X
 0F55                   .dbline 0 ; func end
 0F55 7F                ret
 0F56                   .dbsym l word_listened -5 c
 0F56                   .dbsym l index -4 c
 0F56                   .dbend
 0F56                   .dbfunc e re_learn_ranges _re_learn_ranges fV
 0F56           ;          label -> X+6
 0F56           ;      tempValue -> X+4
 0F56           ;       luxValue -> X+0
 0F56           ;  word_listened -> X-5
 0F56           _re_learn_ranges::
 0F56                   .dbline -1
 0F56 10                push X
 0F57 4F                mov X,SP
 0F58 3808              add SP,8
 0F5A                   .dbline 601
 0F5A           ; }
 0F5A           ; 
 0F5A           ; void re_learn_ranges(word_listened)
 0F5A           ; {
 0F5A                   .dbline 606
 0F5A           ;       float luxValue; // Ambient Light illumiance value
 0F5A           ;       INT   tempValue;
 0F5A           ;       char *label;
 0F5A           ;       //Read light sensor value
 0F5A           ;       luxValue   = getLux(); // luxValue ranges from 0 to 1000
 0F5A 9B32              xcall _getLux
 0F5C 62D000            mov REG[0xd0],>__r0
 0F5F 5100              mov A,[__r0]
 0F61 5400              mov [X+0],A
 0F63 5100              mov A,[__r1]
 0F65 5401              mov [X+1],A
 0F67 5100              mov A,[__r2]
 0F69 5402              mov [X+2],A
 0F6B 5100              mov A,[__r3]
 0F6D 5403              mov [X+3],A
 0F6F                   .dbline 608
 0F6F           ;       //Read temperature value
 0F6F           ;       tempValue  = read_temperature();
 0F6F 9A1E              xcall _read_temperature
 0F71 62D000            mov REG[0xd0],>__r0
 0F74 5100              mov A,[__r1]
 0F76 5405              mov [X+5],A
 0F78 5100              mov A,[__r0]
 0F7A 5404              mov [X+4],A
 0F7C                   .dbline 611
 0F7C           ;       
 0F7C           ;       //check if the received word indicates temperature only condition or light only condition or both temperature&light condition
 0F7C           ;       if ((word_listened & MS_NIBBLE_MASK != 0) && (word_listened & LS_NIBBLE_MASK != 0))
 0F7C 52FC              mov A,[X-4]
 0F7E 2101              and A,1
 0F80 5300              mov [__r1],A
 0F82 52FB              mov A,[X-5]
 0F84 2100              and A,0
 0F86 5300              mov [__r0],A
 0F88 3900              cmp A,0
 0F8A B006              jnz X43
 0F8C 3C0000            cmp [__r1],0
 0F8F A1CE              jz L135
 0F91           X43:
 0F91 62D000            mov REG[0xd0],>__r0
 0F94 3C0000            cmp [__r0],0
 0F97 B006              jnz X44
 0F99 3C0000            cmp [__r1],0
 0F9C A1C1              jz L135
 0F9E           X44:
 0F9E                   .dbline 615
 0F9E           ;       {       
 0F9E           ;               // generate the bit stream for each different combinations of range values, the find the new range that will
 0F9E           ;               // generate the bit stream that matches with the received bit stream
 0F9E           ;               if (create_word(luxValue, tempValue,label,luxValue,lux_range_2,temp_range_1,temp_range_2) == word_listened)
 0F9E                   .dbline 615
 0F9E 62D000            mov REG[0xd0],>_temp_range_2
 0FA1 5100              mov A,[_temp_range_2]
 0FA3 08                push A
 0FA4 5101              mov A,[_temp_range_2+1]
 0FA6 08                push A
 0FA7 62D000            mov REG[0xd0],>_temp_range_1
 0FAA 5100              mov A,[_temp_range_1]
 0FAC 08                push A
 0FAD 5101              mov A,[_temp_range_1+1]
 0FAF 08                push A
 0FB0 62D000            mov REG[0xd0],>_lux_range_2
 0FB3 5100              mov A,[_lux_range_2]
 0FB5 08                push A
 0FB6 5101              mov A,[_lux_range_2+1]
 0FB8 08                push A
 0FB9 62D000            mov REG[0xd0],>__r0
 0FBC 5200              mov A,[X+0]
 0FBE 08                push A
 0FBF 5201              mov A,[X+1]
 0FC1 08                push A
 0FC2 5202              mov A,[X+2]
 0FC4 08                push A
 0FC5 5203              mov A,[X+3]
 0FC7 08                push A
 0FC8 7C0000            xcall __fp2long
 0FCB 18                pop A
 0FCC 5300              mov [__r1],A
 0FCE 18                pop A
 0FCF 38FE              add SP,-2
 0FD1 08                push A
 0FD2 5100              mov A,[__r1]
 0FD4 08                push A
 0FD5 5206              mov A,[X+6]
 0FD7 08                push A
 0FD8 5207              mov A,[X+7]
 0FDA 08                push A
 0FDB 5204              mov A,[X+4]
 0FDD 08                push A
 0FDE 5205              mov A,[X+5]
 0FE0 08                push A
 0FE1 5200              mov A,[X+0]
 0FE3 08                push A
 0FE4 5201              mov A,[X+1]
 0FE6 08                push A
 0FE7 5202              mov A,[X+2]
 0FE9 08                push A
 0FEA 5203              mov A,[X+3]
 0FEC 08                push A
 0FED 7C016F            xcall _create_word
 0FF0 38F0              add SP,-16
 0FF2 62D000            mov REG[0xd0],>__r0
 0FF5 5300              mov [__r1],A
 0FF7 5000              mov A,0
 0FF9 3BFB              cmp A,[X-5]
 0FFB B026              jnz L137
 0FFD 5100              mov A,[__r1]
 0FFF 3BFC              cmp A,[X-4]
 1001 B020              jnz L137
 1003           X45:
 1003                   .dbline 617
 1003           ;               {
 1003           ;                       lux_range_1 = luxValue;
 1003                   .dbline 617
 1003 5200              mov A,[X+0]
 1005 08                push A
 1006 5201              mov A,[X+1]
 1008 08                push A
 1009 5202              mov A,[X+2]
 100B 08                push A
 100C 5203              mov A,[X+3]
 100E 08                push A
 100F 62D000            mov REG[0xd0],>__r0
 1012 7C0000            xcall __fp2long
 1015 18                pop A
 1016 62D000            mov REG[0xd0],>_lux_range_1
 1019 5301              mov [_lux_range_1+1],A
 101B 18                pop A
 101C 5300              mov [_lux_range_1],A
 101E 38FE              add SP,-2
 1020                   .dbline 618
 1020           ;               }
 1020 832F              xjmp L136
 1022           L137:
 1022                   .dbline 619
 1022           ;               else if (create_word(luxValue, tempValue,label,lux_range_1,luxValue,temp_range_1,temp_range_2) == word_listened)
 1022 62D000            mov REG[0xd0],>_temp_range_2
 1025 5100              mov A,[_temp_range_2]
 1027 08                push A
 1028 5101              mov A,[_temp_range_2+1]
 102A 08                push A
 102B 62D000            mov REG[0xd0],>_temp_range_1
 102E 5100              mov A,[_temp_range_1]
 1030 08                push A
 1031 5101              mov A,[_temp_range_1+1]
 1033 08                push A
 1034 62D000            mov REG[0xd0],>__r0
 1037 5200              mov A,[X+0]
 1039 08                push A
 103A 5201              mov A,[X+1]
 103C 08                push A
 103D 5202              mov A,[X+2]
 103F 08                push A
 1040 5203              mov A,[X+3]
 1042 08                push A
 1043 7C0000            xcall __fp2long
 1046 18                pop A
 1047 5300              mov [__r1],A
 1049 18                pop A
 104A 38FE              add SP,-2
 104C 08                push A
 104D 5100              mov A,[__r1]
 104F 08                push A
 1050 62D000            mov REG[0xd0],>_lux_range_1
 1053 5100              mov A,[_lux_range_1]
 1055 08                push A
 1056 5101              mov A,[_lux_range_1+1]
 1058 08                push A
 1059 5206              mov A,[X+6]
 105B 08                push A
 105C 5207              mov A,[X+7]
 105E 08                push A
 105F 5204              mov A,[X+4]
 1061 08                push A
 1062 5205              mov A,[X+5]
 1064 08                push A
 1065 5200              mov A,[X+0]
 1067 08                push A
 1068 5201              mov A,[X+1]
 106A 08                push A
 106B 5202              mov A,[X+2]
 106D 08                push A
 106E 5203              mov A,[X+3]
 1070 08                push A
 1071 7C016F            xcall _create_word
 1074 38F0              add SP,-16
 1076 62D000            mov REG[0xd0],>__r0
 1079 5300              mov [__r1],A
 107B 5000              mov A,0
 107D 3BFB              cmp A,[X-5]
 107F B026              jnz L139
 1081 5100              mov A,[__r1]
 1083 3BFC              cmp A,[X-4]
 1085 B020              jnz L139
 1087           X46:
 1087                   .dbline 621
 1087           ;               {
 1087           ;                       lux_range_2 = luxValue;
 1087                   .dbline 621
 1087 5200              mov A,[X+0]
 1089 08                push A
 108A 5201              mov A,[X+1]
 108C 08                push A
 108D 5202              mov A,[X+2]
 108F 08                push A
 1090 5203              mov A,[X+3]
 1092 08                push A
 1093 62D000            mov REG[0xd0],>__r0
 1096 7C0000            xcall __fp2long
 1099 18                pop A
 109A 62D000            mov REG[0xd0],>_lux_range_2
 109D 5301              mov [_lux_range_2+1],A
 109F 18                pop A
 10A0 5300              mov [_lux_range_2],A
 10A2 38FE              add SP,-2
 10A4                   .dbline 622
 10A4           ;               }
 10A4 82AB              xjmp L136
 10A6           L139:
 10A6                   .dbline 623
 10A6           ;               else if (create_word(luxValue, tempValue,label,lux_range_1,lux_range_2,tempValue,temp_range_2) == word_listened)
 10A6 62D000            mov REG[0xd0],>_temp_range_2
 10A9 5100              mov A,[_temp_range_2]
 10AB 08                push A
 10AC 5101              mov A,[_temp_range_2+1]
 10AE 08                push A
 10AF 5204              mov A,[X+4]
 10B1 08                push A
 10B2 5205              mov A,[X+5]
 10B4 08                push A
 10B5 62D000            mov REG[0xd0],>_lux_range_2
 10B8 5100              mov A,[_lux_range_2]
 10BA 08                push A
 10BB 5101              mov A,[_lux_range_2+1]
 10BD 08                push A
 10BE 62D000            mov REG[0xd0],>_lux_range_1
 10C1 5100              mov A,[_lux_range_1]
 10C3 08                push A
 10C4 5101              mov A,[_lux_range_1+1]
 10C6 08                push A
 10C7 5206              mov A,[X+6]
 10C9 08                push A
 10CA 5207              mov A,[X+7]
 10CC 08                push A
 10CD 5204              mov A,[X+4]
 10CF 08                push A
 10D0 5205              mov A,[X+5]
 10D2 08                push A
 10D3 5200              mov A,[X+0]
 10D5 08                push A
 10D6 5201              mov A,[X+1]
 10D8 08                push A
 10D9 5202              mov A,[X+2]
 10DB 08                push A
 10DC 5203              mov A,[X+3]
 10DE 08                push A
 10DF 7C016F            xcall _create_word
 10E2 38F0              add SP,-16
 10E4 62D000            mov REG[0xd0],>__r0
 10E7 5300              mov [__r1],A
 10E9 5000              mov A,0
 10EB 3BFB              cmp A,[X-5]
 10ED B014              jnz L141
 10EF 5100              mov A,[__r1]
 10F1 3BFC              cmp A,[X-4]
 10F3 B00E              jnz L141
 10F5           X47:
 10F5                   .dbline 625
 10F5           ;               {
 10F5           ;                       temp_range_1 = tempValue;
 10F5                   .dbline 625
 10F5 62D000            mov REG[0xd0],>_temp_range_1
 10F8 5205              mov A,[X+5]
 10FA 5301              mov [_temp_range_1+1],A
 10FC 5204              mov A,[X+4]
 10FE 5300              mov [_temp_range_1],A
 1100                   .dbline 626
 1100           ;               }
 1100 824F              xjmp L136
 1102           L141:
 1102                   .dbline 627
 1102           ;               else if (create_word(luxValue, tempValue,label,lux_range_1,lux_range_2,temp_range_1,tempValue) == word_listened)
 1102 5204              mov A,[X+4]
 1104 08                push A
 1105 5205              mov A,[X+5]
 1107 08                push A
 1108 62D000            mov REG[0xd0],>_temp_range_1
 110B 5100              mov A,[_temp_range_1]
 110D 08                push A
 110E 5101              mov A,[_temp_range_1+1]
 1110 08                push A
 1111 62D000            mov REG[0xd0],>_lux_range_2
 1114 5100              mov A,[_lux_range_2]
 1116 08                push A
 1117 5101              mov A,[_lux_range_2+1]
 1119 08                push A
 111A 62D000            mov REG[0xd0],>_lux_range_1
 111D 5100              mov A,[_lux_range_1]
 111F 08                push A
 1120 5101              mov A,[_lux_range_1+1]
 1122 08                push A
 1123 5206              mov A,[X+6]
 1125 08                push A
 1126 5207              mov A,[X+7]
 1128 08                push A
 1129 5204              mov A,[X+4]
 112B 08                push A
 112C 5205              mov A,[X+5]
 112E 08                push A
 112F 5200              mov A,[X+0]
 1131 08                push A
 1132 5201              mov A,[X+1]
 1134 08                push A
 1135 5202              mov A,[X+2]
 1137 08                push A
 1138 5203              mov A,[X+3]
 113A 08                push A
 113B 7C016F            xcall _create_word
 113E 38F0              add SP,-16
 1140 62D000            mov REG[0xd0],>__r0
 1143 5300              mov [__r1],A
 1145 5000              mov A,0
 1147 3BFB              cmp A,[X-5]
 1149 B206              jnz L136
 114B 5100              mov A,[__r1]
 114D 3BFC              cmp A,[X-4]
 114F B200              jnz L136
 1151           X48:
 1151                   .dbline 629
 1151           ;               {
 1151           ;                       temp_range_2 = tempValue;
 1151                   .dbline 629
 1151 62D000            mov REG[0xd0],>_temp_range_2
 1154 5205              mov A,[X+5]
 1156 5301              mov [_temp_range_2+1],A
 1158 5204              mov A,[X+4]
 115A 5300              mov [_temp_range_2],A
 115C                   .dbline 630
 115C           ;               }
 115C                   .dbline 631
 115C           ;       }
 115C 81F3              xjmp L136
 115E           L135:
 115E                   .dbline 632
 115E           ;       else if((word_listened & MS_NIBBLE_MASK ==0) && (word_listened & LS_NIBBLE_MASK != 0))
 115E 5000              mov A,0
 1160 A0CF              jz L145
 1162 62D000            mov REG[0xd0],>__r0
 1165 52FC              mov A,[X-4]
 1167 2101              and A,1
 1169 5300              mov [__r1],A
 116B 52FB              mov A,[X-5]
 116D 2100              and A,0
 116F 3900              cmp A,0
 1171 B006              jnz X49
 1173 3C0000            cmp [__r1],0
 1176 A0B9              jz L145
 1178           X49:
 1178                   .dbline 635
 1178           ;       {
 1178           ;               //relearn only temperature ranges
 1178           ;               if (create_word(luxValue, tempValue,label,lux_range_1,lux_range_2,tempValue,temp_range_2) == word_listened)
 1178                   .dbline 635
 1178 62D000            mov REG[0xd0],>_temp_range_2
 117B 5100              mov A,[_temp_range_2]
 117D 08                push A
 117E 5101              mov A,[_temp_range_2+1]
 1180 08                push A
 1181 5204              mov A,[X+4]
 1183 08                push A
 1184 5205              mov A,[X+5]
 1186 08                push A
 1187 62D000            mov REG[0xd0],>_lux_range_2
 118A 5100              mov A,[_lux_range_2]
 118C 08                push A
 118D 5101              mov A,[_lux_range_2+1]
 118F 08                push A
 1190 62D000            mov REG[0xd0],>_lux_range_1
 1193 5100              mov A,[_lux_range_1]
 1195 08                push A
 1196 5101              mov A,[_lux_range_1+1]
 1198 08                push A
 1199 5206              mov A,[X+6]
 119B 08                push A
 119C 5207              mov A,[X+7]
 119E 08                push A
 119F 5204              mov A,[X+4]
 11A1 08                push A
 11A2 5205              mov A,[X+5]
 11A4 08                push A
 11A5 5200              mov A,[X+0]
 11A7 08                push A
 11A8 5201              mov A,[X+1]
 11AA 08                push A
 11AB 5202              mov A,[X+2]
 11AD 08                push A
 11AE 5203              mov A,[X+3]
 11B0 08                push A
 11B1 7C016F            xcall _create_word
 11B4 38F0              add SP,-16
 11B6 62D000            mov REG[0xd0],>__r0
 11B9 5300              mov [__r1],A
 11BB 5000              mov A,0
 11BD 3BFB              cmp A,[X-5]
 11BF B014              jnz L147
 11C1 5100              mov A,[__r1]
 11C3 3BFC              cmp A,[X-4]
 11C5 B00E              jnz L147
 11C7           X50:
 11C7                   .dbline 637
 11C7           ;               {
 11C7           ;                       temp_range_1 = tempValue;
 11C7                   .dbline 637
 11C7 62D000            mov REG[0xd0],>_temp_range_1
 11CA 5205              mov A,[X+5]
 11CC 5301              mov [_temp_range_1+1],A
 11CE 5204              mov A,[X+4]
 11D0 5300              mov [_temp_range_1],A
 11D2                   .dbline 638
 11D2           ;               }
 11D2 817D              xjmp L146
 11D4           L147:
 11D4                   .dbline 639
 11D4           ;               else if (create_word(luxValue, tempValue,label,lux_range_1,lux_range_2,temp_range_1,tempValue) == word_listened)
 11D4 5204              mov A,[X+4]
 11D6 08                push A
 11D7 5205              mov A,[X+5]
 11D9 08                push A
 11DA 62D000            mov REG[0xd0],>_temp_range_1
 11DD 5100              mov A,[_temp_range_1]
 11DF 08                push A
 11E0 5101              mov A,[_temp_range_1+1]
 11E2 08                push A
 11E3 62D000            mov REG[0xd0],>_lux_range_2
 11E6 5100              mov A,[_lux_range_2]
 11E8 08                push A
 11E9 5101              mov A,[_lux_range_2+1]
 11EB 08                push A
 11EC 62D000            mov REG[0xd0],>_lux_range_1
 11EF 5100              mov A,[_lux_range_1]
 11F1 08                push A
 11F2 5101              mov A,[_lux_range_1+1]
 11F4 08                push A
 11F5 5206              mov A,[X+6]
 11F7 08                push A
 11F8 5207              mov A,[X+7]
 11FA 08                push A
 11FB 5204              mov A,[X+4]
 11FD 08                push A
 11FE 5205              mov A,[X+5]
 1200 08                push A
 1201 5200              mov A,[X+0]
 1203 08                push A
 1204 5201              mov A,[X+1]
 1206 08                push A
 1207 5202              mov A,[X+2]
 1209 08                push A
 120A 5203              mov A,[X+3]
 120C 08                push A
 120D 7C016F            xcall _create_word
 1210 38F0              add SP,-16
 1212 62D000            mov REG[0xd0],>__r0
 1215 5300              mov [__r1],A
 1217 5000              mov A,0
 1219 3BFB              cmp A,[X-5]
 121B B134              jnz L146
 121D 5100              mov A,[__r1]
 121F 3BFC              cmp A,[X-4]
 1221 B12E              jnz L146
 1223           X51:
 1223                   .dbline 641
 1223           ;               {
 1223           ;                       temp_range_2 = tempValue;
 1223                   .dbline 641
 1223 62D000            mov REG[0xd0],>_temp_range_2
 1226 5205              mov A,[X+5]
 1228 5301              mov [_temp_range_2+1],A
 122A 5204              mov A,[X+4]
 122C 5300              mov [_temp_range_2],A
 122E                   .dbline 642
 122E           ;               }
 122E                   .dbline 643
 122E           ;       }
 122E 8121              xjmp L146
 1230           L145:
 1230                   .dbline 644
 1230           ;       else if ((word_listened & MS_NIBBLE_MASK !=0 ) && (word_listened & LS_NIBBLE_MASK == 0))
 1230 62D000            mov REG[0xd0],>__r0
 1233 52FC              mov A,[X-4]
 1235 2101              and A,1
 1237 5300              mov [__r1],A
 1239 52FB              mov A,[X-5]
 123B 2100              and A,0
 123D 3900              cmp A,0
 123F B006              jnz X52
 1241 3C0000            cmp [__r1],0
 1244 A10B              jz L151
 1246           X52:
 1246 5000              mov A,0
 1248 A107              jz L151
 124A                   .dbline 647
 124A           ;       {
 124A           ;               //relearn only light ranges
 124A           ;               if (create_word(luxValue, tempValue,label,luxValue,lux_range_2,temp_range_1,temp_range_2) == word_listened)
 124A                   .dbline 647
 124A 62D000            mov REG[0xd0],>_temp_range_2
 124D 5100              mov A,[_temp_range_2]
 124F 08                push A
 1250 5101              mov A,[_temp_range_2+1]
 1252 08                push A
 1253 62D000            mov REG[0xd0],>_temp_range_1
 1256 5100              mov A,[_temp_range_1]
 1258 08                push A
 1259 5101              mov A,[_temp_range_1+1]
 125B 08                push A
 125C 62D000            mov REG[0xd0],>_lux_range_2
 125F 5100              mov A,[_lux_range_2]
 1261 08                push A
 1262 5101              mov A,[_lux_range_2+1]
 1264 08                push A
 1265 62D000            mov REG[0xd0],>__r0
 1268 5200              mov A,[X+0]
 126A 08                push A
 126B 5201              mov A,[X+1]
 126D 08                push A
 126E 5202              mov A,[X+2]
 1270 08                push A
 1271 5203              mov A,[X+3]
 1273 08                push A
 1274 7C0000            xcall __fp2long
 1277 18                pop A
 1278 5300              mov [__r1],A
 127A 18                pop A
 127B 38FE              add SP,-2
 127D 08                push A
 127E 5100              mov A,[__r1]
 1280 08                push A
 1281 5206              mov A,[X+6]
 1283 08                push A
 1284 5207              mov A,[X+7]
 1286 08                push A
 1287 5204              mov A,[X+4]
 1289 08                push A
 128A 5205              mov A,[X+5]
 128C 08                push A
 128D 5200              mov A,[X+0]
 128F 08                push A
 1290 5201              mov A,[X+1]
 1292 08                push A
 1293 5202              mov A,[X+2]
 1295 08                push A
 1296 5203              mov A,[X+3]
 1298 08                push A
 1299 7C016F            xcall _create_word
 129C 38F0              add SP,-16
 129E 62D000            mov REG[0xd0],>__r0
 12A1 5300              mov [__r1],A
 12A3 5000              mov A,0
 12A5 3BFB              cmp A,[X-5]
 12A7 B026              jnz L153
 12A9 5100              mov A,[__r1]
 12AB 3BFC              cmp A,[X-4]
 12AD B020              jnz L153
 12AF           X53:
 12AF                   .dbline 649
 12AF           ;               {
 12AF           ;                       lux_range_1 = luxValue;
 12AF                   .dbline 649
 12AF 5200              mov A,[X+0]
 12B1 08                push A
 12B2 5201              mov A,[X+1]
 12B4 08                push A
 12B5 5202              mov A,[X+2]
 12B7 08                push A
 12B8 5203              mov A,[X+3]
 12BA 08                push A
 12BB 62D000            mov REG[0xd0],>__r0
 12BE 7C0000            xcall __fp2long
 12C1 18                pop A
 12C2 62D000            mov REG[0xd0],>_lux_range_1
 12C5 5301              mov [_lux_range_1+1],A
 12C7 18                pop A
 12C8 5300              mov [_lux_range_1],A
 12CA 38FE              add SP,-2
 12CC                   .dbline 650
 12CC           ;               }
 12CC 8083              xjmp L154
 12CE           L153:
 12CE                   .dbline 651
 12CE           ;               else if (create_word(luxValue, tempValue,label,lux_range_1,luxValue,temp_range_1,temp_range_2) == word_listened)
 12CE 62D000            mov REG[0xd0],>_temp_range_2
 12D1 5100              mov A,[_temp_range_2]
 12D3 08                push A
 12D4 5101              mov A,[_temp_range_2+1]
 12D6 08                push A
 12D7 62D000            mov REG[0xd0],>_temp_range_1
 12DA 5100              mov A,[_temp_range_1]
 12DC 08                push A
 12DD 5101              mov A,[_temp_range_1+1]
 12DF 08                push A
 12E0 62D000            mov REG[0xd0],>__r0
 12E3 5200              mov A,[X+0]
 12E5 08                push A
 12E6 5201              mov A,[X+1]
 12E8 08                push A
 12E9 5202              mov A,[X+2]
 12EB 08                push A
 12EC 5203              mov A,[X+3]
 12EE 08                push A
 12EF 7C0000            xcall __fp2long
 12F2 18                pop A
 12F3 5300              mov [__r1],A
 12F5 18                pop A
 12F6 38FE              add SP,-2
 12F8 08                push A
 12F9 5100              mov A,[__r1]
 12FB 08                push A
 12FC 62D000            mov REG[0xd0],>_lux_range_1
 12FF 5100              mov A,[_lux_range_1]
 1301 08                push A
 1302 5101              mov A,[_lux_range_1+1]
 1304 08                push A
 1305 5206              mov A,[X+6]
 1307 08                push A
 1308 5207              mov A,[X+7]
 130A 08                push A
 130B 5204              mov A,[X+4]
 130D 08                push A
 130E 5205              mov A,[X+5]
 1310 08                push A
 1311 5200              mov A,[X+0]
 1313 08                push A
 1314 5201              mov A,[X+1]
 1316 08                push A
 1317 5202              mov A,[X+2]
 1319 08                push A
 131A 5203              mov A,[X+3]
 131C 08                push A
 131D 7C016F            xcall _create_word
 1320 38F0              add SP,-16
 1322 62D000            mov REG[0xd0],>__r0
 1325 5300              mov [__r1],A
 1327 5000              mov A,0
 1329 3BFB              cmp A,[X-5]
 132B B024              jnz L155
 132D 5100              mov A,[__r1]
 132F 3BFC              cmp A,[X-4]
 1331 B01E              jnz L155
 1333           X54:
 1333                   .dbline 653
 1333           ;               {
 1333           ;                       lux_range_2 = luxValue;
 1333                   .dbline 653
 1333 5200              mov A,[X+0]
 1335 08                push A
 1336 5201              mov A,[X+1]
 1338 08                push A
 1339 5202              mov A,[X+2]
 133B 08                push A
 133C 5203              mov A,[X+3]
 133E 08                push A
 133F 62D000            mov REG[0xd0],>__r0
 1342 7C0000            xcall __fp2long
 1345 18                pop A
 1346 62D000            mov REG[0xd0],>_lux_range_2
 1349 5301              mov [_lux_range_2+1],A
 134B 18                pop A
 134C 5300              mov [_lux_range_2],A
 134E 38FE              add SP,-2
 1350                   .dbline 654
 1350           ;               }
 1350           L155:
 1350           L154:
 1350                   .dbline 655
 1350           ;       }
 1350           L151:
 1350           L146:
 1350           L136:
 1350                   .dbline -2
 1350           L134:
 1350 38F8              add SP,-8
 1352 20                pop X
 1353                   .dbline 0 ; func end
 1353 7F                ret
 1354                   .dbsym l label 6 pc
 1354                   .dbsym l tempValue 4 I
 1354                   .dbsym l luxValue 0 D
 1354                   .dbsym l word_listened -5 I
 1354                   .dbend
                        .area lit(rom, con, rel, lit)
 0000           L55:
 0000 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 0010 733A2042524947485420484F5400      .byte 's,58,32,'B,'R,'I,'G,'H,'T,32,'H,'O,'T,0
 001E           L52:
 001E 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 002E 733A20425249474854204D454449554D  .byte 's,58,32,'B,'R,'I,'G,'H,'T,32,'M,'E,'D,'I,'U,'M
 003E 00                .byte 0
 003F           L49:
 003F 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 004F 733A2042524947485420434F4C4400    .byte 's,58,32,'B,'R,'I,'G,'H,'T,32,'C,'O,'L,'D,0
 005E           L46:
 005E 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 006E 733A204E4F524D414C20484F5400      .byte 's,58,32,'N,'O,'R,'M,'A,'L,32,'H,'O,'T,0
 007C           L43:
 007C 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 008C 733A204E4F524D414C204D454449554D  .byte 's,58,32,'N,'O,'R,'M,'A,'L,32,'M,'E,'D,'I,'U,'M
 009C 00                .byte 0
 009D           L40:
 009D 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 00AD 733A204E4F524D414C20434F4C4400    .byte 's,58,32,'N,'O,'R,'M,'A,'L,32,'C,'O,'L,'D,0
 00BC           L37:
 00BC 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 00CC 733A204441524B20484F5400  .byte 's,58,32,'D,'A,'R,'K,32,'H,'O,'T,0
 00D8           L34:
 00D8 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 00E8 733A204441524B204D454449554D00    .byte 's,58,32,'D,'A,'R,'K,32,'M,'E,'D,'I,'U,'M,0
 00F7           L31:
 00F7 576F72642047656E6572617465642069  .byte 'W,'o,'r,'d,32,'G,'e,'n,'e,'r,'a,'t,'e,'d,32,'i
 0107 733A204441524B20434F4C4400        .byte 's,58,32,'D,'A,'R,'K,32,'C,'O,'L,'D,0
